{"version":3,"file":"index.js","sources":["../node_modules/@liveblocks/client/lib/esm/live.js","../node_modules/@liveblocks/client/lib/esm/types.js","../node_modules/@liveblocks/client/lib/esm/authentication.js","../node_modules/@liveblocks/client/lib/esm/room.js","../src/index.tsx"],"sourcesContent":["export var ServerMessageType;\n(function (ServerMessageType) {\n    ServerMessageType[ServerMessageType[\"UpdatePresence\"] = 100] = \"UpdatePresence\";\n    ServerMessageType[ServerMessageType[\"UserJoined\"] = 101] = \"UserJoined\";\n    ServerMessageType[ServerMessageType[\"UserLeft\"] = 102] = \"UserLeft\";\n    ServerMessageType[ServerMessageType[\"Event\"] = 103] = \"Event\";\n    ServerMessageType[ServerMessageType[\"RoomState\"] = 104] = \"RoomState\";\n    ServerMessageType[ServerMessageType[\"InitialStorageState\"] = 200] = \"InitialStorageState\";\n    ServerMessageType[ServerMessageType[\"UpdateStorage\"] = 201] = \"UpdateStorage\";\n})(ServerMessageType || (ServerMessageType = {}));\nexport var ClientMessageType;\n(function (ClientMessageType) {\n    ClientMessageType[ClientMessageType[\"UpdatePresence\"] = 100] = \"UpdatePresence\";\n    ClientMessageType[ClientMessageType[\"ClientEvent\"] = 103] = \"ClientEvent\";\n    ClientMessageType[ClientMessageType[\"FetchStorage\"] = 200] = \"FetchStorage\";\n    ClientMessageType[ClientMessageType[\"UpdateStorage\"] = 201] = \"UpdateStorage\";\n})(ClientMessageType || (ClientMessageType = {}));\nexport var CrdtType;\n(function (CrdtType) {\n    CrdtType[CrdtType[\"Record\"] = 0] = \"Record\";\n    CrdtType[CrdtType[\"List\"] = 1] = \"List\";\n    CrdtType[CrdtType[\"Register\"] = 2] = \"Register\";\n})(CrdtType || (CrdtType = {}));\nexport var OpType;\n(function (OpType) {\n    OpType[OpType[\"Init\"] = 100] = \"Init\";\n    OpType[OpType[\"ListInsert\"] = 200] = \"ListInsert\";\n    OpType[OpType[\"ListMove\"] = 201] = \"ListMove\";\n    OpType[OpType[\"ListRemove\"] = 202] = \"ListRemove\";\n    OpType[OpType[\"RecordUpdate\"] = 300] = \"RecordUpdate\";\n})(OpType || (OpType = {}));\nexport var WebsocketCloseCodes;\n(function (WebsocketCloseCodes) {\n    WebsocketCloseCodes[WebsocketCloseCodes[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"INVALID_MESSAGE_FORMAT\"] = 4000] = \"INVALID_MESSAGE_FORMAT\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n})(WebsocketCloseCodes || (WebsocketCloseCodes = {}));\n","export var LiveStorageState;\n(function (LiveStorageState) {\n    LiveStorageState[LiveStorageState[\"NotInitialized\"] = 0] = \"NotInitialized\";\n    LiveStorageState[LiveStorageState[\"Loading\"] = 1] = \"Loading\";\n    LiveStorageState[LiveStorageState[\"Loaded\"] = 2] = \"Loaded\";\n})(LiveStorageState || (LiveStorageState = {}));\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction fetchAuthorize(endpoint, room) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const res = yield fetch(endpoint, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                room,\n            }),\n        });\n        if (!res.ok) {\n            throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`);\n        }\n        let authResponse = null;\n        try {\n            authResponse = yield res.json();\n        }\n        catch (er) {\n            throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`);\n        }\n        if (typeof authResponse.token !== \"string\") {\n            throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`);\n        }\n        return authResponse.token;\n    });\n}\nexport default function auth(endpoint, room) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof endpoint === \"string\") {\n            return fetchAuthorize(endpoint, room);\n        }\n        if (typeof endpoint === \"function\") {\n            const { token } = yield endpoint(room);\n            // TODO: Validation\n            return token;\n        }\n        throw new Error(\"Authentication error. Liveblocks could not parse the response of your authentication endpoint\");\n    });\n}\nclass AuthenticationError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nexport function parseToken(token) {\n    const tokenParts = token.split(\".\");\n    if (tokenParts.length !== 3) {\n        throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication endpoint`);\n    }\n    const data = JSON.parse(atob(tokenParts[1]));\n    if (typeof data.actor !== \"number\") {\n        throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication endpoint`);\n    }\n    return data;\n}\n","var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nimport { Doc } from \"./doc\";\nimport { LiveStorageState, } from \"./types\";\nimport { createRecord as innerCreateRecord, createList as innerCreateList, } from \"./doc\";\nimport { remove } from \"./utils\";\nimport auth, { parseToken } from \"./authentication\";\nimport { ClientMessageType, ServerMessageType, } from \"./live\";\nconst BACKOFF_RETRY_DELAYS = [250, 500, 1000, 2000, 4000, 8000, 10000];\nconst HEARTBEAT_INTERVAL = 30000;\n// const WAKE_UP_CHECK_INTERVAL = 2000;\nconst PONG_TIMEOUT = 2000;\nfunction isValidRoomEventType(value) {\n    return (value === \"storage\" ||\n        value === \"my-presence\" ||\n        value === \"others\" ||\n        value === \"event\" ||\n        value === \"error\" ||\n        value === \"connection\");\n}\nfunction makeIdFactory(connectionId) {\n    let count = 0;\n    return () => `${connectionId}:${count++}`;\n}\nfunction makeOthers(presenceMap) {\n    const array = Object.values(presenceMap);\n    return {\n        get count() {\n            return array.length;\n        },\n        map(callback) {\n            return array.map(callback);\n        },\n        toArray() {\n            return array;\n        },\n    };\n}\nfunction log(...params) {\n    return;\n    console.log(...params, new Date().toString());\n}\nexport function makeStateMachine(state, context, mockedEffects) {\n    const effects = mockedEffects || {\n        authenticate() {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const token = yield auth(context.authEndpoint, context.room);\n                    const parsedToken = parseToken(token);\n                    const socket = new WebSocket(`${context.liveblocksServer}/?token=${token}`);\n                    socket.addEventListener(\"message\", onMessage);\n                    socket.addEventListener(\"open\", onOpen);\n                    socket.addEventListener(\"close\", onClose);\n                    socket.addEventListener(\"error\", onError);\n                    authenticationSuccess(parsedToken, socket);\n                }\n                catch (er) {\n                    authenticationFailure(er);\n                }\n            });\n        },\n        send(messageOrMessages) {\n            if (state.socket == null) {\n                throw new Error(\"Can't send message if socket is null\");\n            }\n            state.socket.send(JSON.stringify(messageOrMessages));\n        },\n        delayFlush(delay) {\n            return setTimeout(tryFlushing, delay);\n        },\n        startHeartbeatInterval() {\n            return setInterval(heartbeat, HEARTBEAT_INTERVAL);\n        },\n        schedulePongTimeout() {\n            return setTimeout(pongTimeout, PONG_TIMEOUT);\n        },\n        scheduleReconnect(delay) {\n            return setTimeout(connect, delay);\n        },\n    };\n    function subscribe(type, listener) {\n        if (!isValidRoomEventType(type)) {\n            throw new Error(`\"${type}\" is not a valid event name`);\n        }\n        state.listeners[type].push(listener);\n    }\n    function unsubscribe(event, callback) {\n        if (!isValidRoomEventType(event)) {\n            throw new Error(`\"${event}\" is not a valid event name`);\n        }\n        const callbacks = state.listeners[event];\n        remove(callbacks, callback);\n    }\n    function getConnectionState() {\n        return state.connection.state;\n    }\n    function getSelf() {\n        return state.connection.state === \"open\" ||\n            state.connection.state === \"connecting\"\n            ? {\n                connectionId: state.connection.id,\n                id: state.connection.userId,\n                info: state.connection.userInfo,\n                presence: getPresence(),\n            }\n            : null;\n    }\n    function connect() {\n        if (typeof window === \"undefined\") {\n            return;\n        }\n        if (state.connection.state !== \"closed\" &&\n            state.connection.state !== \"unavailable\") {\n            return null;\n        }\n        updateConnection({ state: \"authenticating\" });\n        effects.authenticate();\n    }\n    function updatePresence(overrides) {\n        const newPresence = Object.assign(Object.assign({}, state.me), overrides);\n        if (state.flushData.presence == null) {\n            state.flushData.presence = overrides;\n        }\n        else {\n            for (const key in overrides) {\n                state.flushData.presence[key] = overrides[key];\n            }\n        }\n        state.me = newPresence;\n        tryFlushing();\n        for (const listener of state.listeners[\"my-presence\"]) {\n            listener(state.me);\n        }\n    }\n    function authenticationSuccess(token, socket) {\n        updateConnection({\n            state: \"connecting\",\n            id: token.actor,\n            userInfo: token.info,\n            userId: token.id,\n        });\n        state.idFactory = makeIdFactory(token.actor);\n        state.socket = socket;\n    }\n    function authenticationFailure(error) {\n        console.error(error);\n        updateConnection({ state: \"unavailable\" });\n        state.numberOfRetry++;\n        state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());\n    }\n    function onVisibilityChange(visibilityState) {\n        if (visibilityState === \"visible\" && state.connection.state === \"open\") {\n            log(\"Heartbeat after visibility change\");\n            heartbeat();\n        }\n    }\n    function onUpdatePresenceMessage(message) {\n        const user = state.users[message.actor];\n        if (user == null) {\n            state.users[message.actor] = {\n                connectionId: message.actor,\n                presence: message.data,\n            };\n        }\n        else {\n            state.users[message.actor] = {\n                id: user.id,\n                info: user.info,\n                connectionId: message.actor,\n                presence: Object.assign(Object.assign({}, user.presence), message.data),\n            };\n        }\n        updateUsers({\n            type: \"update\",\n            updates: message.data,\n            user: state.users[message.actor],\n        });\n    }\n    function updateUsers(event) {\n        state.others = makeOthers(state.users);\n        for (const listener of state.listeners[\"others\"]) {\n            listener(state.others, event);\n        }\n    }\n    function onUserLeftMessage(message) {\n        const userLeftMessage = message;\n        const user = state.users[userLeftMessage.actor];\n        if (user) {\n            delete state.users[userLeftMessage.actor];\n            updateUsers({ type: \"leave\", user });\n        }\n    }\n    function onRoomStateMessage(message) {\n        const newUsers = {};\n        for (const key in message.users) {\n            const connectionId = Number.parseInt(key);\n            const user = message.users[key];\n            newUsers[connectionId] = {\n                connectionId,\n                info: user.info,\n                id: user.id,\n            };\n        }\n        state.users = newUsers;\n        updateUsers({ type: \"reset\" });\n    }\n    function onNavigatorOnline() {\n        if (state.connection.state === \"unavailable\") {\n            log(\"Try to reconnect after connectivity change\");\n            reconnect();\n        }\n    }\n    function onEvent(message) {\n        for (const listener of state.listeners.event) {\n            listener({ connectionId: message.actor, event: message.event });\n        }\n    }\n    function onUserJoinedMessage(message) {\n        state.users[message.actor] = {\n            connectionId: message.actor,\n            info: message.info,\n            id: message.id,\n        };\n        updateUsers({ type: \"enter\", user: state.users[message.actor] });\n        if (state.me) {\n            // Send current presence to new user\n            // TODO: Consider storing it on the backend\n            state.flushData.messages.push({\n                type: ClientMessageType.UpdatePresence,\n                data: state.me,\n                targetActor: message.actor,\n            });\n            tryFlushing();\n        }\n    }\n    function onMessage(event) {\n        if (event.data === \"pong\") {\n            clearTimeout(state.timeoutHandles.pongTimeout);\n            return;\n        }\n        const message = JSON.parse(event.data);\n        switch (message.type) {\n            case ServerMessageType.InitialStorageState: {\n                onInitialStorageState(message);\n                break;\n            }\n            case ServerMessageType.UpdateStorage: {\n                onStorageUpdates(message);\n                break;\n            }\n            case ServerMessageType.UserJoined: {\n                onUserJoinedMessage(message);\n                break;\n            }\n            case ServerMessageType.UpdatePresence: {\n                onUpdatePresenceMessage(message);\n                break;\n            }\n            case ServerMessageType.Event: {\n                onEvent(message);\n                break;\n            }\n            case ServerMessageType.UserLeft: {\n                onUserLeftMessage(message);\n                break;\n            }\n            case ServerMessageType.RoomState: {\n                onRoomStateMessage(message);\n                break;\n            }\n        }\n    }\n    // function onWakeUp() {\n    //   // Sometimes, the browser can put the webpage on pause (computer is on sleep mode for example)\n    //   // The client will not know that the server has probably close the connection even if the readyState is Open\n    //   // One way to detect this kind of pause is to ensure that a setInterval is not taking more than the delay it was configured with\n    //   if (state.connection.state === \"open\") {\n    //     log(\"Try to reconnect after laptop wake up\");\n    //     reconnect();\n    //   }\n    // }\n    function onClose(event) {\n        state.socket = null;\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        clearInterval(state.intervalHandles.heartbeat);\n        if (state.timeoutHandles.flush) {\n            clearTimeout(state.timeoutHandles.flush);\n        }\n        clearTimeout(state.timeoutHandles.reconnect);\n        state.users = {};\n        updateUsers({ type: \"reset\" });\n        if (event.code >= 4000 && event.code <= 4100) {\n            updateConnection({ state: \"failed\" });\n            const error = new LiveblocksError(event.reason, event.code);\n            for (const listener of state.listeners.error) {\n                listener(error);\n            }\n        }\n        else if (event.wasClean === false) {\n            updateConnection({ state: \"unavailable\" });\n            state.numberOfRetry++;\n            state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());\n        }\n        else {\n            updateConnection({ state: \"closed\" });\n        }\n    }\n    function updateConnection(connection) {\n        state.connection = connection;\n        for (const listener of state.listeners.connection) {\n            listener(connection.state);\n        }\n    }\n    function getRetryDelay() {\n        return BACKOFF_RETRY_DELAYS[state.numberOfRetry < BACKOFF_RETRY_DELAYS.length\n            ? state.numberOfRetry\n            : BACKOFF_RETRY_DELAYS.length - 1];\n    }\n    function onError() { }\n    function onOpen() {\n        clearInterval(state.intervalHandles.heartbeat);\n        state.intervalHandles.heartbeat = effects.startHeartbeatInterval();\n        if (state.connection.state === \"connecting\") {\n            updateConnection(Object.assign(Object.assign({}, state.connection), { state: \"open\" }));\n            state.numberOfRetry = 0;\n            tryFlushing();\n        }\n        else {\n            // TODO\n        }\n    }\n    function heartbeat() {\n        if (state.socket == null) {\n            // Should never happen, because we clear the pong timeout when the connection is dropped explictly\n            return;\n        }\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        state.timeoutHandles.pongTimeout = effects.schedulePongTimeout();\n        if (state.socket.readyState === WebSocket.OPEN) {\n            state.socket.send(\"ping\");\n        }\n    }\n    function pongTimeout() {\n        log(\"Pong timeout. Trying to reconnect.\");\n        reconnect();\n    }\n    function reconnect() {\n        if (state.socket) {\n            state.socket.removeEventListener(\"open\", onOpen);\n            state.socket.removeEventListener(\"message\", onMessage);\n            state.socket.removeEventListener(\"close\", onClose);\n            state.socket.removeEventListener(\"error\", onError);\n            state.socket.close();\n            state.socket = null;\n        }\n        updateConnection({ state: \"unavailable\" });\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        if (state.timeoutHandles.flush) {\n            clearTimeout(state.timeoutHandles.flush);\n        }\n        clearTimeout(state.timeoutHandles.reconnect);\n        clearInterval(state.intervalHandles.heartbeat);\n        connect();\n    }\n    function tryFlushing() {\n        if (state.socket == null) {\n            return;\n        }\n        if (state.socket.readyState !== WebSocket.OPEN) {\n            return;\n        }\n        const now = Date.now();\n        const elapsedTime = now - state.lastFlushTime;\n        if (elapsedTime > context.throttleDelay) {\n            const messages = flushDataToMessages(state);\n            if (messages.length === 0) {\n                return;\n            }\n            effects.send(messages);\n            state.flushData = {\n                messages: [],\n                storageOperations: [],\n                presence: null,\n            };\n            state.lastFlushTime = now;\n        }\n        else {\n            if (state.timeoutHandles.flush != null) {\n                clearTimeout(state.timeoutHandles.flush);\n            }\n            state.timeoutHandles.flush = effects.delayFlush(context.throttleDelay - (now - state.lastFlushTime));\n        }\n    }\n    function flushDataToMessages(state) {\n        const messages = [];\n        if (state.flushData.presence) {\n            messages.push({\n                type: ClientMessageType.UpdatePresence,\n                data: state.flushData.presence,\n            });\n        }\n        for (const event of state.flushData.messages) {\n            messages.push(event);\n        }\n        if (state.flushData.storageOperations.length > 0) {\n            messages.push({\n                type: ClientMessageType.UpdateStorage,\n                ops: state.flushData.storageOperations,\n            });\n        }\n        return messages;\n    }\n    function disconnect() {\n        if (state.socket) {\n            state.socket.removeEventListener(\"open\", onOpen);\n            state.socket.removeEventListener(\"message\", onMessage);\n            state.socket.removeEventListener(\"close\", onClose);\n            state.socket.removeEventListener(\"error\", onError);\n            state.socket.close();\n            state.socket = null;\n        }\n        updateConnection({ state: \"closed\" });\n        if (state.timeoutHandles.flush) {\n            clearTimeout(state.timeoutHandles.flush);\n        }\n        clearTimeout(state.timeoutHandles.reconnect);\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        clearInterval(state.intervalHandles.heartbeat);\n        state.users = {};\n        updateUsers({ type: \"reset\" });\n        clearListeners();\n    }\n    function clearListeners() {\n        for (const key in state.listeners) {\n            state.listeners[key] = [];\n        }\n    }\n    function getPresence() {\n        return state.me;\n    }\n    function getOthers() {\n        return state.others;\n    }\n    function broadcastEvent(event) {\n        if (state.socket == null) {\n            return;\n        }\n        state.flushData.messages.push({\n            type: ClientMessageType.ClientEvent,\n            event,\n        });\n        tryFlushing();\n    }\n    /**\n     * STORAGE\n     */\n    function onStorageUpdates(message) {\n        if (state.doc == null) {\n            // TODO: Cache updates in case they are coming while root is queried\n            return;\n        }\n        updateDoc(message.ops.reduce((doc, op) => doc.dispatch(op), state.doc));\n    }\n    function updateDoc(doc) {\n        state.doc = doc;\n        if (doc) {\n            for (const listener of state.listeners.storage) {\n                listener(getStorage());\n            }\n        }\n    }\n    function getStorage() {\n        if (state.storageState === LiveStorageState.Loaded) {\n            return {\n                state: state.storageState,\n                root: state.doc.root,\n            };\n        }\n        return {\n            state: state.storageState,\n        };\n    }\n    function onInitialStorageState(message) {\n        state.storageState = LiveStorageState.Loaded;\n        if (message.root == null) {\n            const rootId = makeId();\n            state.doc = Doc.empty(rootId, (op) => dispatch(op));\n            updateDoc(state.doc.updateRecord(rootId, state.initialStorageFactory({\n                createRecord: (data) => createRecord(data),\n                createList: () => createList(),\n            })));\n        }\n        else {\n            updateDoc(Doc.load(message.root, (op) => dispatch(op)));\n        }\n    }\n    function makeId() {\n        if (state.idFactory == null) {\n            throw new Error(\"Can't generate id. Id factory is missing.\");\n        }\n        return state.idFactory();\n    }\n    function dispatch(op) {\n        state.flushData.storageOperations.push(op);\n        tryFlushing();\n    }\n    function createRecord(data) {\n        return innerCreateRecord(makeId(), data);\n    }\n    function createList() {\n        return innerCreateList(makeId());\n    }\n    function fetchStorage(initialStorageFactory) {\n        state.initialStorageFactory = initialStorageFactory;\n        state.storageState = LiveStorageState.Loading;\n        state.flushData.messages.push({ type: ClientMessageType.FetchStorage });\n        tryFlushing();\n    }\n    function updateRecord(record, overrides) {\n        updateDoc(state.doc.updateRecord(record.id, overrides));\n    }\n    function pushItem(list, item) {\n        updateDoc(state.doc.pushItem(list.id, item));\n    }\n    function deleteItem(list, index) {\n        updateDoc(state.doc.deleteItem(list.id, index));\n    }\n    function deleteItemById(list, itemId) {\n        updateDoc(state.doc.deleteItemById(list.id, itemId));\n    }\n    function moveItem(list, index, targetIndex) {\n        updateDoc(state.doc.moveItem(list.id, index, targetIndex));\n    }\n    return {\n        // Internal\n        onOpen,\n        onClose,\n        onMessage,\n        authenticationSuccess,\n        heartbeat,\n        onNavigatorOnline,\n        // onWakeUp,\n        onVisibilityChange,\n        // Core\n        connect,\n        disconnect,\n        subscribe,\n        unsubscribe,\n        // Presence\n        updatePresence,\n        broadcastEvent,\n        // Storage\n        fetchStorage,\n        createRecord,\n        updateRecord,\n        createList,\n        pushItem,\n        deleteItem,\n        deleteItemById,\n        moveItem,\n        selectors: {\n            // Core\n            getConnectionState,\n            getSelf,\n            // Presence\n            getPresence,\n            getOthers,\n            // Storage\n            getStorage,\n        },\n    };\n}\nexport function defaultState(me) {\n    return {\n        connection: { state: \"closed\" },\n        socket: null,\n        listeners: {\n            storage: [],\n            event: [],\n            others: [],\n            \"my-presence\": [],\n            error: [],\n            connection: [],\n        },\n        numberOfRetry: 0,\n        lastFlushTime: 0,\n        timeoutHandles: {\n            flush: null,\n            reconnect: 0,\n            pongTimeout: 0,\n        },\n        flushData: {\n            presence: me == null ? {} : me,\n            messages: [],\n            storageOperations: [],\n        },\n        intervalHandles: {\n            heartbeat: 0,\n        },\n        me: me == null ? {} : me,\n        users: {},\n        others: makeOthers({}),\n        storageState: LiveStorageState.NotInitialized,\n        initialStorageFactory: null,\n        doc: null,\n        idFactory: null,\n    };\n}\nexport function createRoom(name, options) {\n    const throttleDelay = options.throttle || 100;\n    const liveblocksServer = options.liveblocksServer || \"wss://liveblocks.net\";\n    const authEndpoint = options.authEndpoint;\n    const state = defaultState(options.initialPresence);\n    const machine = makeStateMachine(state, {\n        throttleDelay,\n        liveblocksServer,\n        authEndpoint,\n        room: name,\n    });\n    const room = {\n        /////////////\n        // Core    //\n        /////////////\n        getConnectionState: machine.selectors.getConnectionState,\n        getSelf: machine.selectors.getSelf,\n        subscribe: machine.subscribe,\n        unsubscribe: machine.unsubscribe,\n        /////////////\n        // Storage //\n        /////////////\n        getStorage: machine.selectors.getStorage,\n        fetchStorage: machine.fetchStorage,\n        createRecord: machine.createRecord,\n        createList: machine.createList,\n        updateRecord: machine.updateRecord,\n        pushItem: machine.pushItem,\n        deleteItem: machine.deleteItem,\n        deleteItemById: machine.deleteItemById,\n        moveItem: machine.moveItem,\n        //////////////\n        // Presence //\n        //////////////\n        getPresence: machine.selectors.getPresence,\n        updatePresence: machine.updatePresence,\n        getOthers: machine.selectors.getOthers,\n        broadcastEvent: machine.broadcastEvent,\n    };\n    return {\n        connect: machine.connect,\n        disconnect: machine.disconnect,\n        onNavigatorOnline: machine.onNavigatorOnline,\n        onVisibilityChange: machine.onVisibilityChange,\n        room,\n    };\n}\nclass LiveblocksError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\n","import {\n  Client,\n  RecordData,\n  Others,\n  Presence,\n  Record,\n  InitialStorageFactory,\n  List,\n  Room,\n  LiveStorageState,\n  User,\n} from \"@liveblocks/client\";\nimport * as React from \"react\";\n\ntype LiveblocksProviderProps = {\n  children: React.ReactNode;\n  client: Client;\n};\n\nconst ClientContext = React.createContext<Client | null>(null);\nconst RoomContext = React.createContext<Room | null>(null);\n\n/**\n * Makes the Liveblocks client available in the component hierarchy below.\n */\nexport function LiveblocksProvider(props: LiveblocksProviderProps) {\n  return (\n    <ClientContext.Provider value={props.client}>\n      {props.children}\n    </ClientContext.Provider>\n  );\n}\n\n/**\n * Returns the client of the nearest LiveblocksProvider above in the react component tree\n */\nfunction useClient(): Client {\n  const client = React.useContext(ClientContext);\n  if (client == null) {\n    throw new Error(\"LiveblocksProvider is missing from the react tree\");\n  }\n\n  return client;\n}\n\ntype RoomProviderProps = {\n  /**\n   * The id of the room you want to connect to\n   */\n  id: string;\n  /**\n   * A callback that let you initialize the default presence when entering the room.\n   * If ommited, the default presence will be an empty object\n   */\n  defaultPresence?: () => Presence;\n\n  children: React.ReactNode;\n};\n\n/**\n * Makes a Room available in the component hierarchy below.\n * When this component is unmounted, the current user leave the room.\n * That means that you can't have 2 RoomProvider with the same room id in your react tree.\n */\nexport function RoomProvider({\n  id,\n  children,\n  defaultPresence,\n}: RoomProviderProps) {\n  const client = useClient();\n\n  React.useEffect(() => {\n    return () => {\n      client.leave(id);\n    };\n  }, [client, id]);\n\n  const room =\n    client.getRoom(id) ||\n    client.enter(id, defaultPresence ? defaultPresence() : undefined);\n\n  return <RoomContext.Provider value={room}>{children}</RoomContext.Provider>;\n}\n\n/**\n * Returns the room of the nearest RoomProvider above in the react component tree\n */\nfunction useRoom() {\n  const room = React.useContext(RoomContext);\n\n  if (room == null) {\n    throw new Error(\"RoomProvider is missing from the react tree\");\n  }\n\n  return room;\n}\n\n/**\n * Returns the presence of the current user of the current room, and a function to update it.\n * It is different from the setState function returned by the useState hook from React.\n * You don't need to pass the full presence object to update it.\n *\n * ### Example\n * ``` typescript\n * import { useMyPresence } from \"@liveblocks/react\";\n *\n * const [myPresence, updateMyPresence] = useMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, \"myPresence\" will be equal to \"{ x: 0, y: 0 }\"\n * ```\n */\nexport function useMyPresence<T extends Presence>(): [\n  T,\n  (overrides: Partial<T>) => void\n] {\n  const room = useRoom();\n  const presence = room.getPresence<T>();\n  const [, update] = React.useState(0);\n\n  React.useEffect(() => {\n    function onMyPresenceChange() {\n      update((x) => x + 1);\n    }\n\n    room.subscribe(\"my-presence\", onMyPresenceChange);\n\n    return () => {\n      room.unsubscribe(\"my-presence\", onMyPresenceChange);\n    };\n  }, [room]);\n\n  const setPresence = React.useCallback(\n    (overrides: Partial<T>) => room.updatePresence(overrides),\n    [room]\n  );\n\n  return [presence, setPresence];\n}\n\n/**\n * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.\n * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.\n *\n * ### Example\n * ``` typescript\n * import { useUpdateMyPresence } from \"@liveblocks/react\";\n *\n * const updateMyPresence = useUpdateMyPresence();\n * updateMyPresence({ x: 0 });\n * updateMyPresence({ y: 0 });\n *\n * // At the next render, the presence of the current user will be equal to \"{ x: 0, y: 0 }\"\n * ```\n */\nexport function useUpdateMyPresence<T extends Presence>(): (\n  overrides: Partial<T>\n) => void {\n  const room = useRoom();\n\n  return React.useCallback(\n    (overrides: Partial<T>) => {\n      room.updatePresence(overrides);\n    },\n    [room]\n  );\n}\n\n/**\n * Returns an object that lets you get information about all the the users currently connected in the room.\n *\n * ### Example\n * ``` typescript\n * import { useOthers } from \"@liveblocks/react\";\n *\n * const others = useOthers();\n *\n * // Example to map all cursors in jsx\n * {\n *   others.map(({ connectionId, presence }) => {\n *     if(presence == null || presence.cursor == null) {\n *       return null;\n *     }\n *     return <Cursor key={connectionId} cursor={presence.cursor} />\n *   })\n * }\n * ```\n */\nexport function useOthers<T extends Presence>(): Others<T> {\n  const room = useRoom();\n\n  const [, update] = React.useState(0);\n\n  React.useEffect(() => {\n    function onOthersChange() {\n      update((x) => x + 1);\n    }\n\n    room.subscribe(\"others\", onOthersChange);\n\n    return () => {\n      room.subscribe(\"others\", onOthersChange);\n    };\n  }, [room]);\n\n  return room.getOthers();\n}\n\n/**\n * Returns a callback that lets you broadcast custom events to other users in the room\n *\n * ### Example\n * ``` typescript\n * import { useBroadcastEvent } from \"@liveblocks/react\";\n *\n * const broadcast = useBroadcastEvent();\n *\n * broadcast({ type: \"CUSTOM_EVENT\", data: { x: 0, y: 0 } });\n * ```\n */\nexport function useBroadcastEvent() {\n  const room = useRoom();\n\n  return React.useCallback(\n    (event: any) => {\n      room.broadcastEvent(event);\n    },\n    [room]\n  );\n}\n\n/**\n * useErrorListener is a react hook that lets you react to potential room connection errors.\n *\n * ### Example\n * ``` typescript\n * import { useErrorListener } from \"@liveblocks/react\";\n *\n * useErrorListener(er => {\n *   console.error(er);\n * })\n * ```\n */\nexport function useErrorListener(callback: (er: Error) => void) {\n  const room = useRoom();\n  const savedCallback = React.useRef(callback);\n\n  React.useEffect(() => {\n    savedCallback.current = callback;\n  });\n\n  React.useEffect(() => {\n    const listener = (e: Error) => savedCallback.current(e);\n\n    room.subscribe(\"error\", listener);\n\n    return () => {\n      room.unsubscribe(\"error\", listener);\n    };\n  }, [room]);\n}\n\n/**\n * useEventListener is a react hook that lets you react to event broadcasted by other users in the room.\n *\n * ### Example\n * ``` typescript\n * import { useEventListener } from \"@liveblocks/react\";\n *\n * useEventListener(({ connectionId, event }) => {\n *   if (event.type === \"CUSTOM_EVENT\") {\n *     // Do something\n *   }\n * });\n * ```\n */\nexport function useEventListener<TEvent>(\n  callback: ({\n    connectionId,\n    event,\n  }: {\n    connectionId: number;\n    event: TEvent;\n  }) => void\n) {\n  const room = useRoom();\n  const savedCallback = React.useRef(callback);\n\n  React.useEffect(() => {\n    savedCallback.current = callback;\n  });\n\n  React.useEffect(() => {\n    const listener = (e: { connectionId: number; event: TEvent }) =>\n      savedCallback.current(e);\n\n    room.subscribe(\"event\", listener);\n\n    return () => {\n      room.unsubscribe(\"event\", listener);\n    };\n  }, [room]);\n}\n\n/**\n * Gets the current user once it is connected to the room.\n *\n * ### Example\n * ``` typescript\n * import { useSelf } from \"@liveblocks/react\";\n *\n * const user = useSelf();\n * ```\n */\nexport function useSelf<\n  TPresence extends Presence = Presence\n>(): User<TPresence> | null {\n  const room = useRoom();\n  const [, update] = React.useState(0);\n\n  React.useEffect(() => {\n    function onChange() {\n      update((x) => x + 1);\n    }\n\n    room.subscribe(\"my-presence\", onChange);\n    room.subscribe(\"connection\", onChange);\n\n    return () => {\n      room.unsubscribe(\"my-presence\", onChange);\n      room.unsubscribe(\"connection\", onChange);\n    };\n  }, [room]);\n\n  return room.getSelf<TPresence>();\n}\n\ntype StorageActions = {\n  createRecord: Room[\"createRecord\"];\n  updateRecord: Room[\"updateRecord\"];\n\n  createList: Room[\"createList\"];\n  moveItem: Room[\"moveItem\"];\n  deleteItem: Room[\"deleteItem\"];\n  deleteItemById: Room[\"deleteItemById\"];\n  pushItem: Room[\"pushItem\"];\n};\n\nexport function useStorage<TRoot extends RecordData>(\n  initialStorage: InitialStorageFactory<TRoot>\n): [root: Record<TRoot> | null, actions: StorageActions] {\n  const room = useRoom();\n  const storage = room.getStorage();\n  const [, update] = React.useState(0);\n\n  React.useEffect(() => {\n    function onStorageChange() {\n      update((x) => x + 1);\n    }\n\n    room.fetchStorage(initialStorage);\n    room.subscribe(\"storage\", onStorageChange);\n\n    return () => {\n      room.unsubscribe(\"storage\", onStorageChange);\n    };\n  }, [room]);\n\n  const root =\n    storage.state === LiveStorageState.Loaded\n      ? (storage.root as Record<TRoot>)\n      : null;\n\n  const actions = useStorageActions();\n  return [root, actions];\n}\n\nexport function useStorageActions(): StorageActions {\n  const room = useRoom();\n  return React.useMemo(() => {\n    function createRecord<T extends RecordData>(data: T) {\n      return room.createRecord<T>(data);\n    }\n\n    function updateRecord<T extends RecordData>(\n      record: Record<T>,\n      overrides: Partial<T>\n    ) {\n      return room.updateRecord<T>(record, overrides);\n    }\n\n    function createList<T extends RecordData>(): List<Record<T>> {\n      return room.createList<T>();\n    }\n\n    function moveItem<T extends RecordData>(\n      list: List<Record<T>>,\n      index: number,\n      targetIndex: number\n    ) {\n      return room.moveItem<T>(list, index, targetIndex);\n    }\n\n    function deleteItem<T extends RecordData>(\n      list: List<Record<T>>,\n      index: number\n    ) {\n      return room.deleteItem<T>(list, index);\n    }\n\n    function deleteItemById<T extends RecordData>(\n      list: List<Record<T>>,\n      itemId: string\n    ) {\n      return room.deleteItemById<T>(list, itemId);\n    }\n\n    function pushItem<T extends RecordData>(\n      list: List<Record<T>>,\n      item: Record<T>\n    ) {\n      return room.pushItem<T>(list, item);\n    }\n\n    return {\n      createRecord,\n      updateRecord,\n\n      createList,\n      moveItem,\n      deleteItem,\n      deleteItemById,\n      pushItem,\n    };\n  }, [room]);\n}\n"],"names":["this","React.createContext","React.createElement","React.useContext","React.useEffect","React.useState","React.useCallback","React.useRef","React.useMemo"],"mappings":"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"}