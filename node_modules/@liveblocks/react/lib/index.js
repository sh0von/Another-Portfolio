Object.defineProperty(exports, '__esModule', { value: true });

var React = require('react');

var ServerMessageType;
(function (ServerMessageType) {
    ServerMessageType[ServerMessageType["UpdatePresence"] = 100] = "UpdatePresence";
    ServerMessageType[ServerMessageType["UserJoined"] = 101] = "UserJoined";
    ServerMessageType[ServerMessageType["UserLeft"] = 102] = "UserLeft";
    ServerMessageType[ServerMessageType["Event"] = 103] = "Event";
    ServerMessageType[ServerMessageType["RoomState"] = 104] = "RoomState";
    ServerMessageType[ServerMessageType["InitialStorageState"] = 200] = "InitialStorageState";
    ServerMessageType[ServerMessageType["UpdateStorage"] = 201] = "UpdateStorage";
})(ServerMessageType || (ServerMessageType = {}));
var ClientMessageType;
(function (ClientMessageType) {
    ClientMessageType[ClientMessageType["UpdatePresence"] = 100] = "UpdatePresence";
    ClientMessageType[ClientMessageType["ClientEvent"] = 103] = "ClientEvent";
    ClientMessageType[ClientMessageType["FetchStorage"] = 200] = "FetchStorage";
    ClientMessageType[ClientMessageType["UpdateStorage"] = 201] = "UpdateStorage";
})(ClientMessageType || (ClientMessageType = {}));
var CrdtType;
(function (CrdtType) {
    CrdtType[CrdtType["Record"] = 0] = "Record";
    CrdtType[CrdtType["List"] = 1] = "List";
    CrdtType[CrdtType["Register"] = 2] = "Register";
})(CrdtType || (CrdtType = {}));
var OpType;
(function (OpType) {
    OpType[OpType["Init"] = 100] = "Init";
    OpType[OpType["ListInsert"] = 200] = "ListInsert";
    OpType[OpType["ListMove"] = 201] = "ListMove";
    OpType[OpType["ListRemove"] = 202] = "ListRemove";
    OpType[OpType["RecordUpdate"] = 300] = "RecordUpdate";
})(OpType || (OpType = {}));
var WebsocketCloseCodes;
(function (WebsocketCloseCodes) {
    WebsocketCloseCodes[WebsocketCloseCodes["CLOSE_ABNORMAL"] = 1006] = "CLOSE_ABNORMAL";
    WebsocketCloseCodes[WebsocketCloseCodes["INVALID_MESSAGE_FORMAT"] = 4000] = "INVALID_MESSAGE_FORMAT";
    WebsocketCloseCodes[WebsocketCloseCodes["NOT_ALLOWED"] = 4001] = "NOT_ALLOWED";
    WebsocketCloseCodes[WebsocketCloseCodes["MAX_NUMBER_OF_MESSAGES_PER_SECONDS"] = 4002] = "MAX_NUMBER_OF_MESSAGES_PER_SECONDS";
    WebsocketCloseCodes[WebsocketCloseCodes["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS"] = 4003] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS";
    WebsocketCloseCodes[WebsocketCloseCodes["MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP"] = 4004] = "MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP";
    WebsocketCloseCodes[WebsocketCloseCodes["MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM"] = 4005] = "MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM";
})(WebsocketCloseCodes || (WebsocketCloseCodes = {}));

var LiveStorageState;
(function (LiveStorageState) {
    LiveStorageState[LiveStorageState["NotInitialized"] = 0] = "NotInitialized";
    LiveStorageState[LiveStorageState["Loading"] = 1] = "Loading";
    LiveStorageState[LiveStorageState["Loaded"] = 2] = "Loaded";
})(LiveStorageState || (LiveStorageState = {}));

(undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

(undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

var ClientContext = React.createContext(null);
var RoomContext = React.createContext(null);
/**
 * Makes the Liveblocks client available in the component hierarchy below.
 */
function LiveblocksProvider(props) {
    return (React.createElement(ClientContext.Provider, { value: props.client }, props.children));
}
/**
 * Returns the client of the nearest LiveblocksProvider above in the react component tree
 */
function useClient() {
    var client = React.useContext(ClientContext);
    if (client == null) {
        throw new Error("LiveblocksProvider is missing from the react tree");
    }
    return client;
}
/**
 * Makes a Room available in the component hierarchy below.
 * When this component is unmounted, the current user leave the room.
 * That means that you can't have 2 RoomProvider with the same room id in your react tree.
 */
function RoomProvider(_a) {
    var id = _a.id, children = _a.children, defaultPresence = _a.defaultPresence;
    var client = useClient();
    React.useEffect(function () {
        return function () {
            client.leave(id);
        };
    }, [client, id]);
    var room = client.getRoom(id) ||
        client.enter(id, defaultPresence ? defaultPresence() : undefined);
    return React.createElement(RoomContext.Provider, { value: room }, children);
}
/**
 * Returns the room of the nearest RoomProvider above in the react component tree
 */
function useRoom() {
    var room = React.useContext(RoomContext);
    if (room == null) {
        throw new Error("RoomProvider is missing from the react tree");
    }
    return room;
}
/**
 * Returns the presence of the current user of the current room, and a function to update it.
 * It is different from the setState function returned by the useState hook from React.
 * You don't need to pass the full presence object to update it.
 *
 * ### Example
 * ``` typescript
 * import { useMyPresence } from "@liveblocks/react";
 *
 * const [myPresence, updateMyPresence] = useMyPresence();
 * updateMyPresence({ x: 0 });
 * updateMyPresence({ y: 0 });
 *
 * // At the next render, "myPresence" will be equal to "{ x: 0, y: 0 }"
 * ```
 */
function useMyPresence() {
    var room = useRoom();
    var presence = room.getPresence();
    var _a = React.useState(0), update = _a[1];
    React.useEffect(function () {
        function onMyPresenceChange() {
            update(function (x) { return x + 1; });
        }
        room.subscribe("my-presence", onMyPresenceChange);
        return function () {
            room.unsubscribe("my-presence", onMyPresenceChange);
        };
    }, [room]);
    var setPresence = React.useCallback(function (overrides) { return room.updatePresence(overrides); }, [room]);
    return [presence, setPresence];
}
/**
 * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.
 * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.
 *
 * ### Example
 * ``` typescript
 * import { useUpdateMyPresence } from "@liveblocks/react";
 *
 * const updateMyPresence = useUpdateMyPresence();
 * updateMyPresence({ x: 0 });
 * updateMyPresence({ y: 0 });
 *
 * // At the next render, the presence of the current user will be equal to "{ x: 0, y: 0 }"
 * ```
 */
function useUpdateMyPresence() {
    var room = useRoom();
    return React.useCallback(function (overrides) {
        room.updatePresence(overrides);
    }, [room]);
}
/**
 * Returns an object that lets you get information about all the the users currently connected in the room.
 *
 * ### Example
 * ``` typescript
 * import { useOthers } from "@liveblocks/react";
 *
 * const others = useOthers();
 *
 * // Example to map all cursors in jsx
 * {
 *   others.map(({ connectionId, presence }) => {
 *     if(presence == null || presence.cursor == null) {
 *       return null;
 *     }
 *     return <Cursor key={connectionId} cursor={presence.cursor} />
 *   })
 * }
 * ```
 */
function useOthers() {
    var room = useRoom();
    var _a = React.useState(0), update = _a[1];
    React.useEffect(function () {
        function onOthersChange() {
            update(function (x) { return x + 1; });
        }
        room.subscribe("others", onOthersChange);
        return function () {
            room.subscribe("others", onOthersChange);
        };
    }, [room]);
    return room.getOthers();
}
/**
 * Returns a callback that lets you broadcast custom events to other users in the room
 *
 * ### Example
 * ``` typescript
 * import { useBroadcastEvent } from "@liveblocks/react";
 *
 * const broadcast = useBroadcastEvent();
 *
 * broadcast({ type: "CUSTOM_EVENT", data: { x: 0, y: 0 } });
 * ```
 */
function useBroadcastEvent() {
    var room = useRoom();
    return React.useCallback(function (event) {
        room.broadcastEvent(event);
    }, [room]);
}
/**
 * useErrorListener is a react hook that lets you react to potential room connection errors.
 *
 * ### Example
 * ``` typescript
 * import { useErrorListener } from "@liveblocks/react";
 *
 * useErrorListener(er => {
 *   console.error(er);
 * })
 * ```
 */
function useErrorListener(callback) {
    var room = useRoom();
    var savedCallback = React.useRef(callback);
    React.useEffect(function () {
        savedCallback.current = callback;
    });
    React.useEffect(function () {
        var listener = function (e) { return savedCallback.current(e); };
        room.subscribe("error", listener);
        return function () {
            room.unsubscribe("error", listener);
        };
    }, [room]);
}
/**
 * useEventListener is a react hook that lets you react to event broadcasted by other users in the room.
 *
 * ### Example
 * ``` typescript
 * import { useEventListener } from "@liveblocks/react";
 *
 * useEventListener(({ connectionId, event }) => {
 *   if (event.type === "CUSTOM_EVENT") {
 *     // Do something
 *   }
 * });
 * ```
 */
function useEventListener(callback) {
    var room = useRoom();
    var savedCallback = React.useRef(callback);
    React.useEffect(function () {
        savedCallback.current = callback;
    });
    React.useEffect(function () {
        var listener = function (e) {
            return savedCallback.current(e);
        };
        room.subscribe("event", listener);
        return function () {
            room.unsubscribe("event", listener);
        };
    }, [room]);
}
/**
 * Gets the current user once it is connected to the room.
 *
 * ### Example
 * ``` typescript
 * import { useSelf } from "@liveblocks/react";
 *
 * const user = useSelf();
 * ```
 */
function useSelf() {
    var room = useRoom();
    var _a = React.useState(0), update = _a[1];
    React.useEffect(function () {
        function onChange() {
            update(function (x) { return x + 1; });
        }
        room.subscribe("my-presence", onChange);
        room.subscribe("connection", onChange);
        return function () {
            room.unsubscribe("my-presence", onChange);
            room.unsubscribe("connection", onChange);
        };
    }, [room]);
    return room.getSelf();
}
function useStorage(initialStorage) {
    var room = useRoom();
    var storage = room.getStorage();
    var _a = React.useState(0), update = _a[1];
    React.useEffect(function () {
        function onStorageChange() {
            update(function (x) { return x + 1; });
        }
        room.fetchStorage(initialStorage);
        room.subscribe("storage", onStorageChange);
        return function () {
            room.unsubscribe("storage", onStorageChange);
        };
    }, [room]);
    var root = storage.state === LiveStorageState.Loaded
        ? storage.root
        : null;
    var actions = useStorageActions();
    return [root, actions];
}
function useStorageActions() {
    var room = useRoom();
    return React.useMemo(function () {
        function createRecord(data) {
            return room.createRecord(data);
        }
        function updateRecord(record, overrides) {
            return room.updateRecord(record, overrides);
        }
        function createList() {
            return room.createList();
        }
        function moveItem(list, index, targetIndex) {
            return room.moveItem(list, index, targetIndex);
        }
        function deleteItem(list, index) {
            return room.deleteItem(list, index);
        }
        function deleteItemById(list, itemId) {
            return room.deleteItemById(list, itemId);
        }
        function pushItem(list, item) {
            return room.pushItem(list, item);
        }
        return {
            createRecord: createRecord,
            updateRecord: updateRecord,
            createList: createList,
            moveItem: moveItem,
            deleteItem: deleteItem,
            deleteItemById: deleteItemById,
            pushItem: pushItem,
        };
    }, [room]);
}

exports.LiveblocksProvider = LiveblocksProvider;
exports.RoomProvider = RoomProvider;
exports.useBroadcastEvent = useBroadcastEvent;
exports.useErrorListener = useErrorListener;
exports.useEventListener = useEventListener;
exports.useMyPresence = useMyPresence;
exports.useOthers = useOthers;
exports.useSelf = useSelf;
exports.useStorage = useStorage;
exports.useStorageActions = useStorageActions;
exports.useUpdateMyPresence = useUpdateMyPresence;
//# sourceMappingURL=index.js.map
