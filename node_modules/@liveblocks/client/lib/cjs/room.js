"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.createRoom = exports.defaultState = exports.makeStateMachine = void 0;
const doc_1 = require("./doc");
const types_1 = require("./types");
const doc_2 = require("./doc");
const utils_1 = require("./utils");
const authentication_1 = __importStar(require("./authentication"));
const live_1 = require("./live");
const BACKOFF_RETRY_DELAYS = [250, 500, 1000, 2000, 4000, 8000, 10000];
const HEARTBEAT_INTERVAL = 30000;
// const WAKE_UP_CHECK_INTERVAL = 2000;
const PONG_TIMEOUT = 2000;
function isValidRoomEventType(value) {
    return (value === "storage" ||
        value === "my-presence" ||
        value === "others" ||
        value === "event" ||
        value === "error" ||
        value === "connection");
}
function makeIdFactory(connectionId) {
    let count = 0;
    return () => `${connectionId}:${count++}`;
}
function makeOthers(presenceMap) {
    const array = Object.values(presenceMap);
    return {
        get count() {
            return array.length;
        },
        map(callback) {
            return array.map(callback);
        },
        toArray() {
            return array;
        },
    };
}
function log(...params) {
    return;
    console.log(...params, new Date().toString());
}
function makeStateMachine(state, context, mockedEffects) {
    const effects = mockedEffects || {
        authenticate() {
            return __awaiter(this, void 0, void 0, function* () {
                try {
                    const token = yield authentication_1.default(context.authEndpoint, context.room);
                    const parsedToken = authentication_1.parseToken(token);
                    const socket = new WebSocket(`${context.liveblocksServer}/?token=${token}`);
                    socket.addEventListener("message", onMessage);
                    socket.addEventListener("open", onOpen);
                    socket.addEventListener("close", onClose);
                    socket.addEventListener("error", onError);
                    authenticationSuccess(parsedToken, socket);
                }
                catch (er) {
                    authenticationFailure(er);
                }
            });
        },
        send(messageOrMessages) {
            if (state.socket == null) {
                throw new Error("Can't send message if socket is null");
            }
            state.socket.send(JSON.stringify(messageOrMessages));
        },
        delayFlush(delay) {
            return setTimeout(tryFlushing, delay);
        },
        startHeartbeatInterval() {
            return setInterval(heartbeat, HEARTBEAT_INTERVAL);
        },
        schedulePongTimeout() {
            return setTimeout(pongTimeout, PONG_TIMEOUT);
        },
        scheduleReconnect(delay) {
            return setTimeout(connect, delay);
        },
    };
    function subscribe(type, listener) {
        if (!isValidRoomEventType(type)) {
            throw new Error(`"${type}" is not a valid event name`);
        }
        state.listeners[type].push(listener);
    }
    function unsubscribe(event, callback) {
        if (!isValidRoomEventType(event)) {
            throw new Error(`"${event}" is not a valid event name`);
        }
        const callbacks = state.listeners[event];
        utils_1.remove(callbacks, callback);
    }
    function getConnectionState() {
        return state.connection.state;
    }
    function getSelf() {
        return state.connection.state === "open" ||
            state.connection.state === "connecting"
            ? {
                connectionId: state.connection.id,
                id: state.connection.userId,
                info: state.connection.userInfo,
                presence: getPresence(),
            }
            : null;
    }
    function connect() {
        if (typeof window === "undefined") {
            return;
        }
        if (state.connection.state !== "closed" &&
            state.connection.state !== "unavailable") {
            return null;
        }
        updateConnection({ state: "authenticating" });
        effects.authenticate();
    }
    function updatePresence(overrides) {
        const newPresence = Object.assign(Object.assign({}, state.me), overrides);
        if (state.flushData.presence == null) {
            state.flushData.presence = overrides;
        }
        else {
            for (const key in overrides) {
                state.flushData.presence[key] = overrides[key];
            }
        }
        state.me = newPresence;
        tryFlushing();
        for (const listener of state.listeners["my-presence"]) {
            listener(state.me);
        }
    }
    function authenticationSuccess(token, socket) {
        updateConnection({
            state: "connecting",
            id: token.actor,
            userInfo: token.info,
            userId: token.id,
        });
        state.idFactory = makeIdFactory(token.actor);
        state.socket = socket;
    }
    function authenticationFailure(error) {
        console.error(error);
        updateConnection({ state: "unavailable" });
        state.numberOfRetry++;
        state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());
    }
    function onVisibilityChange(visibilityState) {
        if (visibilityState === "visible" && state.connection.state === "open") {
            log("Heartbeat after visibility change");
            heartbeat();
        }
    }
    function onUpdatePresenceMessage(message) {
        const user = state.users[message.actor];
        if (user == null) {
            state.users[message.actor] = {
                connectionId: message.actor,
                presence: message.data,
            };
        }
        else {
            state.users[message.actor] = {
                id: user.id,
                info: user.info,
                connectionId: message.actor,
                presence: Object.assign(Object.assign({}, user.presence), message.data),
            };
        }
        updateUsers({
            type: "update",
            updates: message.data,
            user: state.users[message.actor],
        });
    }
    function updateUsers(event) {
        state.others = makeOthers(state.users);
        for (const listener of state.listeners["others"]) {
            listener(state.others, event);
        }
    }
    function onUserLeftMessage(message) {
        const userLeftMessage = message;
        const user = state.users[userLeftMessage.actor];
        if (user) {
            delete state.users[userLeftMessage.actor];
            updateUsers({ type: "leave", user });
        }
    }
    function onRoomStateMessage(message) {
        const newUsers = {};
        for (const key in message.users) {
            const connectionId = Number.parseInt(key);
            const user = message.users[key];
            newUsers[connectionId] = {
                connectionId,
                info: user.info,
                id: user.id,
            };
        }
        state.users = newUsers;
        updateUsers({ type: "reset" });
    }
    function onNavigatorOnline() {
        if (state.connection.state === "unavailable") {
            log("Try to reconnect after connectivity change");
            reconnect();
        }
    }
    function onEvent(message) {
        for (const listener of state.listeners.event) {
            listener({ connectionId: message.actor, event: message.event });
        }
    }
    function onUserJoinedMessage(message) {
        state.users[message.actor] = {
            connectionId: message.actor,
            info: message.info,
            id: message.id,
        };
        updateUsers({ type: "enter", user: state.users[message.actor] });
        if (state.me) {
            // Send current presence to new user
            // TODO: Consider storing it on the backend
            state.flushData.messages.push({
                type: live_1.ClientMessageType.UpdatePresence,
                data: state.me,
                targetActor: message.actor,
            });
            tryFlushing();
        }
    }
    function onMessage(event) {
        if (event.data === "pong") {
            clearTimeout(state.timeoutHandles.pongTimeout);
            return;
        }
        const message = JSON.parse(event.data);
        switch (message.type) {
            case live_1.ServerMessageType.InitialStorageState: {
                onInitialStorageState(message);
                break;
            }
            case live_1.ServerMessageType.UpdateStorage: {
                onStorageUpdates(message);
                break;
            }
            case live_1.ServerMessageType.UserJoined: {
                onUserJoinedMessage(message);
                break;
            }
            case live_1.ServerMessageType.UpdatePresence: {
                onUpdatePresenceMessage(message);
                break;
            }
            case live_1.ServerMessageType.Event: {
                onEvent(message);
                break;
            }
            case live_1.ServerMessageType.UserLeft: {
                onUserLeftMessage(message);
                break;
            }
            case live_1.ServerMessageType.RoomState: {
                onRoomStateMessage(message);
                break;
            }
        }
    }
    // function onWakeUp() {
    //   // Sometimes, the browser can put the webpage on pause (computer is on sleep mode for example)
    //   // The client will not know that the server has probably close the connection even if the readyState is Open
    //   // One way to detect this kind of pause is to ensure that a setInterval is not taking more than the delay it was configured with
    //   if (state.connection.state === "open") {
    //     log("Try to reconnect after laptop wake up");
    //     reconnect();
    //   }
    // }
    function onClose(event) {
        state.socket = null;
        clearTimeout(state.timeoutHandles.pongTimeout);
        clearInterval(state.intervalHandles.heartbeat);
        if (state.timeoutHandles.flush) {
            clearTimeout(state.timeoutHandles.flush);
        }
        clearTimeout(state.timeoutHandles.reconnect);
        state.users = {};
        updateUsers({ type: "reset" });
        if (event.code >= 4000 && event.code <= 4100) {
            updateConnection({ state: "failed" });
            const error = new LiveblocksError(event.reason, event.code);
            for (const listener of state.listeners.error) {
                listener(error);
            }
        }
        else if (event.wasClean === false) {
            updateConnection({ state: "unavailable" });
            state.numberOfRetry++;
            state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());
        }
        else {
            updateConnection({ state: "closed" });
        }
    }
    function updateConnection(connection) {
        state.connection = connection;
        for (const listener of state.listeners.connection) {
            listener(connection.state);
        }
    }
    function getRetryDelay() {
        return BACKOFF_RETRY_DELAYS[state.numberOfRetry < BACKOFF_RETRY_DELAYS.length
            ? state.numberOfRetry
            : BACKOFF_RETRY_DELAYS.length - 1];
    }
    function onError() { }
    function onOpen() {
        clearInterval(state.intervalHandles.heartbeat);
        state.intervalHandles.heartbeat = effects.startHeartbeatInterval();
        if (state.connection.state === "connecting") {
            updateConnection(Object.assign(Object.assign({}, state.connection), { state: "open" }));
            state.numberOfRetry = 0;
            tryFlushing();
        }
        else {
            // TODO
        }
    }
    function heartbeat() {
        if (state.socket == null) {
            // Should never happen, because we clear the pong timeout when the connection is dropped explictly
            return;
        }
        clearTimeout(state.timeoutHandles.pongTimeout);
        state.timeoutHandles.pongTimeout = effects.schedulePongTimeout();
        if (state.socket.readyState === WebSocket.OPEN) {
            state.socket.send("ping");
        }
    }
    function pongTimeout() {
        log("Pong timeout. Trying to reconnect.");
        reconnect();
    }
    function reconnect() {
        if (state.socket) {
            state.socket.removeEventListener("open", onOpen);
            state.socket.removeEventListener("message", onMessage);
            state.socket.removeEventListener("close", onClose);
            state.socket.removeEventListener("error", onError);
            state.socket.close();
            state.socket = null;
        }
        updateConnection({ state: "unavailable" });
        clearTimeout(state.timeoutHandles.pongTimeout);
        if (state.timeoutHandles.flush) {
            clearTimeout(state.timeoutHandles.flush);
        }
        clearTimeout(state.timeoutHandles.reconnect);
        clearInterval(state.intervalHandles.heartbeat);
        connect();
    }
    function tryFlushing() {
        if (state.socket == null) {
            return;
        }
        if (state.socket.readyState !== WebSocket.OPEN) {
            return;
        }
        const now = Date.now();
        const elapsedTime = now - state.lastFlushTime;
        if (elapsedTime > context.throttleDelay) {
            const messages = flushDataToMessages(state);
            if (messages.length === 0) {
                return;
            }
            effects.send(messages);
            state.flushData = {
                messages: [],
                storageOperations: [],
                presence: null,
            };
            state.lastFlushTime = now;
        }
        else {
            if (state.timeoutHandles.flush != null) {
                clearTimeout(state.timeoutHandles.flush);
            }
            state.timeoutHandles.flush = effects.delayFlush(context.throttleDelay - (now - state.lastFlushTime));
        }
    }
    function flushDataToMessages(state) {
        const messages = [];
        if (state.flushData.presence) {
            messages.push({
                type: live_1.ClientMessageType.UpdatePresence,
                data: state.flushData.presence,
            });
        }
        for (const event of state.flushData.messages) {
            messages.push(event);
        }
        if (state.flushData.storageOperations.length > 0) {
            messages.push({
                type: live_1.ClientMessageType.UpdateStorage,
                ops: state.flushData.storageOperations,
            });
        }
        return messages;
    }
    function disconnect() {
        if (state.socket) {
            state.socket.removeEventListener("open", onOpen);
            state.socket.removeEventListener("message", onMessage);
            state.socket.removeEventListener("close", onClose);
            state.socket.removeEventListener("error", onError);
            state.socket.close();
            state.socket = null;
        }
        updateConnection({ state: "closed" });
        if (state.timeoutHandles.flush) {
            clearTimeout(state.timeoutHandles.flush);
        }
        clearTimeout(state.timeoutHandles.reconnect);
        clearTimeout(state.timeoutHandles.pongTimeout);
        clearInterval(state.intervalHandles.heartbeat);
        state.users = {};
        updateUsers({ type: "reset" });
        clearListeners();
    }
    function clearListeners() {
        for (const key in state.listeners) {
            state.listeners[key] = [];
        }
    }
    function getPresence() {
        return state.me;
    }
    function getOthers() {
        return state.others;
    }
    function broadcastEvent(event) {
        if (state.socket == null) {
            return;
        }
        state.flushData.messages.push({
            type: live_1.ClientMessageType.ClientEvent,
            event,
        });
        tryFlushing();
    }
    /**
     * STORAGE
     */
    function onStorageUpdates(message) {
        if (state.doc == null) {
            // TODO: Cache updates in case they are coming while root is queried
            return;
        }
        updateDoc(message.ops.reduce((doc, op) => doc.dispatch(op), state.doc));
    }
    function updateDoc(doc) {
        state.doc = doc;
        if (doc) {
            for (const listener of state.listeners.storage) {
                listener(getStorage());
            }
        }
    }
    function getStorage() {
        if (state.storageState === types_1.LiveStorageState.Loaded) {
            return {
                state: state.storageState,
                root: state.doc.root,
            };
        }
        return {
            state: state.storageState,
        };
    }
    function onInitialStorageState(message) {
        state.storageState = types_1.LiveStorageState.Loaded;
        if (message.root == null) {
            const rootId = makeId();
            state.doc = doc_1.Doc.empty(rootId, (op) => dispatch(op));
            updateDoc(state.doc.updateRecord(rootId, state.initialStorageFactory({
                createRecord: (data) => createRecord(data),
                createList: () => createList(),
            })));
        }
        else {
            updateDoc(doc_1.Doc.load(message.root, (op) => dispatch(op)));
        }
    }
    function makeId() {
        if (state.idFactory == null) {
            throw new Error("Can't generate id. Id factory is missing.");
        }
        return state.idFactory();
    }
    function dispatch(op) {
        state.flushData.storageOperations.push(op);
        tryFlushing();
    }
    function createRecord(data) {
        return doc_2.createRecord(makeId(), data);
    }
    function createList() {
        return doc_2.createList(makeId());
    }
    function fetchStorage(initialStorageFactory) {
        state.initialStorageFactory = initialStorageFactory;
        state.storageState = types_1.LiveStorageState.Loading;
        state.flushData.messages.push({ type: live_1.ClientMessageType.FetchStorage });
        tryFlushing();
    }
    function updateRecord(record, overrides) {
        updateDoc(state.doc.updateRecord(record.id, overrides));
    }
    function pushItem(list, item) {
        updateDoc(state.doc.pushItem(list.id, item));
    }
    function deleteItem(list, index) {
        updateDoc(state.doc.deleteItem(list.id, index));
    }
    function deleteItemById(list, itemId) {
        updateDoc(state.doc.deleteItemById(list.id, itemId));
    }
    function moveItem(list, index, targetIndex) {
        updateDoc(state.doc.moveItem(list.id, index, targetIndex));
    }
    return {
        // Internal
        onOpen,
        onClose,
        onMessage,
        authenticationSuccess,
        heartbeat,
        onNavigatorOnline,
        // onWakeUp,
        onVisibilityChange,
        // Core
        connect,
        disconnect,
        subscribe,
        unsubscribe,
        // Presence
        updatePresence,
        broadcastEvent,
        // Storage
        fetchStorage,
        createRecord,
        updateRecord,
        createList,
        pushItem,
        deleteItem,
        deleteItemById,
        moveItem,
        selectors: {
            // Core
            getConnectionState,
            getSelf,
            // Presence
            getPresence,
            getOthers,
            // Storage
            getStorage,
        },
    };
}
exports.makeStateMachine = makeStateMachine;
function defaultState(me) {
    return {
        connection: { state: "closed" },
        socket: null,
        listeners: {
            storage: [],
            event: [],
            others: [],
            "my-presence": [],
            error: [],
            connection: [],
        },
        numberOfRetry: 0,
        lastFlushTime: 0,
        timeoutHandles: {
            flush: null,
            reconnect: 0,
            pongTimeout: 0,
        },
        flushData: {
            presence: me == null ? {} : me,
            messages: [],
            storageOperations: [],
        },
        intervalHandles: {
            heartbeat: 0,
        },
        me: me == null ? {} : me,
        users: {},
        others: makeOthers({}),
        storageState: types_1.LiveStorageState.NotInitialized,
        initialStorageFactory: null,
        doc: null,
        idFactory: null,
    };
}
exports.defaultState = defaultState;
function createRoom(name, options) {
    const throttleDelay = options.throttle || 100;
    const liveblocksServer = options.liveblocksServer || "wss://liveblocks.net";
    const authEndpoint = options.authEndpoint;
    const state = defaultState(options.initialPresence);
    const machine = makeStateMachine(state, {
        throttleDelay,
        liveblocksServer,
        authEndpoint,
        room: name,
    });
    const room = {
        /////////////
        // Core    //
        /////////////
        getConnectionState: machine.selectors.getConnectionState,
        getSelf: machine.selectors.getSelf,
        subscribe: machine.subscribe,
        unsubscribe: machine.unsubscribe,
        /////////////
        // Storage //
        /////////////
        getStorage: machine.selectors.getStorage,
        fetchStorage: machine.fetchStorage,
        createRecord: machine.createRecord,
        createList: machine.createList,
        updateRecord: machine.updateRecord,
        pushItem: machine.pushItem,
        deleteItem: machine.deleteItem,
        deleteItemById: machine.deleteItemById,
        moveItem: machine.moveItem,
        //////////////
        // Presence //
        //////////////
        getPresence: machine.selectors.getPresence,
        updatePresence: machine.updatePresence,
        getOthers: machine.selectors.getOthers,
        broadcastEvent: machine.broadcastEvent,
    };
    return {
        connect: machine.connect,
        disconnect: machine.disconnect,
        onNavigatorOnline: machine.onNavigatorOnline,
        onVisibilityChange: machine.onVisibilityChange,
        room,
    };
}
exports.createRoom = createRoom;
class LiveblocksError extends Error {
    constructor(message, code) {
        super(message);
        this.code = code;
    }
}
