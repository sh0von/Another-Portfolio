{
  "version": 3,
  "sources": ["../../src/live.ts", "../../src/position.ts", "../../src/doc.ts", "../../src/types.ts", "../../src/utils.ts", "../../src/authentication.ts", "../../src/room.ts", "../../src/client.ts"],
  "sourcesContent": ["import { Presence } from \"./types\";\n\nexport type ServerMessage =\n  | UpdatePresenceMessage\n  | UserJoinMessage\n  | UserLeftMessage\n  | EventMessage\n  | RoomStateMessage\n  | InitialDocumentStateMessage\n  | UpdateStorageMessage;\n\nexport enum ServerMessageType {\n  UpdatePresence = 100,\n  UserJoined = 101,\n  UserLeft = 102,\n  Event = 103,\n  RoomState = 104,\n\n  InitialStorageState = 200,\n  UpdateStorage = 201,\n}\n\nexport type RoomStateMessage = {\n  type: ServerMessageType.RoomState;\n  users: {\n    [actor: number]: {\n      id?: string;\n      info?: any;\n    };\n  };\n};\n\nexport type UpdatePresenceMessage = {\n  type: ServerMessageType.UpdatePresence;\n  actor: number;\n  data: Presence;\n};\n\nexport type UserJoinMessage = {\n  type: ServerMessageType.UserJoined;\n  actor: number;\n  id?: string;\n  info?: string;\n};\n\nexport type UserLeftMessage = {\n  type: ServerMessageType.UserLeft;\n  actor: number;\n};\n\nexport type EventMessage = {\n  type: ServerMessageType.Event;\n  actor: number;\n  event: any;\n};\n\nexport type InitialDocumentStateMessage = {\n  type: ServerMessageType.InitialStorageState;\n  root: SerializedRecord | null;\n};\n\nexport type UpdateStorageMessage = {\n  type: ServerMessageType.UpdateStorage;\n  ops: Op[];\n};\n\nexport type ClientMessage =\n  | ClientEventMessage\n  | UpdatePresenceClientMessage\n  | UpdateStorageClientMessage\n  | FetchStorageClientMessage;\n\nexport enum ClientMessageType {\n  UpdatePresence = 100,\n  ClientEvent = 103,\n\n  FetchStorage = 200,\n  UpdateStorage = 201,\n}\n\nexport type ClientEventMessage = {\n  type: ClientMessageType.ClientEvent;\n  event: any;\n};\n\nexport type UpdatePresenceClientMessage = {\n  type: ClientMessageType.UpdatePresence;\n  data: Presence;\n  targetActor?: number;\n};\n\nexport type UpdateStorageClientMessage = {\n  type: ClientMessageType.UpdateStorage;\n  ops: Op[];\n};\n\nexport type FetchStorageClientMessage = {\n  type: ClientMessageType.FetchStorage;\n};\n\nexport enum CrdtType {\n  Record = 0,\n  List = 1,\n  Register = 2,\n}\n\nexport type SerializedRecord = {\n  id: string;\n  type: CrdtType.Record;\n  data: {\n    [key: string]: SerializedCrdt;\n  };\n};\n\nexport type SerializedList = {\n  id: string;\n  type: CrdtType.List;\n  data: {\n    [position: string]: SerializedCrdt;\n  };\n};\n\nexport type SerializedRegister = {\n  id?: string;\n  type: CrdtType.Register;\n  data: any;\n};\n\nexport type SerializedCrdt =\n  | SerializedRecord\n  | SerializedList\n  | SerializedRegister;\n\nexport enum OpType {\n  Init = 100,\n\n  ListInsert = 200,\n  ListMove = 201,\n  ListRemove = 202,\n\n  RecordUpdate = 300,\n}\n\nexport type Op = RecordUpdateOp | ListInsertOp | ListDeleteOp | ListMoveOp;\n\nexport type RecordUpdateOp = {\n  id: string;\n  type: OpType.RecordUpdate;\n  data: {\n    [key: string]: SerializedCrdt;\n  };\n};\n\nexport type ListInsertOp = {\n  id: string;\n  type: OpType.ListInsert;\n  position: string;\n  data: SerializedCrdt;\n};\n\nexport type ListMoveOp = {\n  id: string;\n  type: OpType.ListMove;\n  itemId: string;\n  position: string;\n};\n\nexport type ListDeleteOp = {\n  id: string;\n  type: OpType.ListRemove;\n  itemId: string;\n};\n\nexport enum WebsocketCloseCodes {\n  CLOSE_ABNORMAL = 1006,\n\n  INVALID_MESSAGE_FORMAT = 4000,\n  NOT_ALLOWED = 4001,\n  MAX_NUMBER_OF_MESSAGES_PER_SECONDS = 4002,\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS = 4003,\n  MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP = 4004,\n  MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM = 4005,\n}\n", "export const min = 32;\nexport const max = 127;\nexport const mid = 79;\n\nexport function middle(a: number, b: number) {\n  return (a + b) / 2;\n}\n\nexport function makePosition(before?: string, after?: string): string {\n  // No children\n  if (before == null && after == null) {\n    return pos([min + 1]);\n  }\n\n  // Insert at the end\n  if (before != null && after == null) {\n    return getNextPosition(before);\n  }\n\n  // Insert at the start\n  if (before == null && after != null) {\n    return getPreviousPosition(after);\n  }\n\n  return pos(makePositionFromCodes(posCodes(before!), posCodes(after!)));\n}\n\nfunction getPreviousPosition(after: string) {\n  const result = [];\n  const afterCodes = posCodes(after);\n  for (let i = 0; i < afterCodes.length; i++) {\n    const code = afterCodes[i];\n\n    if (code <= min + 1) {\n      result.push(min);\n      if (afterCodes.length - 1 === i) {\n        result.push(max - 1);\n        break;\n      }\n    } else {\n      result.push(code - 1);\n      break;\n    }\n  }\n\n  return pos(result);\n}\n\nfunction getNextPosition(before: string) {\n  const result = [];\n  const beforeCodes = posCodes(before);\n  for (let i = 0; i < beforeCodes.length; i++) {\n    const code = beforeCodes[i];\n\n    if (code === max - 1) {\n      result.push(code);\n      if (beforeCodes.length - 1 === i) {\n        result.push(min + 1);\n        break;\n      }\n    } else {\n      result.push(code + 1);\n      break;\n    }\n  }\n\n  return pos(result);\n}\n\nfunction makePositionFromCodes(before: number[], after: number[]): number[] {\n  let index = 0;\n  const result = [];\n\n  while (true) {\n    const beforeDigit: number = before[index] || min;\n    const afterDigit: number = after[index] || max;\n\n    if (beforeDigit > afterDigit) {\n      throw new Error(\n        `Impossible to generate position between ${before} and ${after}`\n      );\n    }\n\n    if (beforeDigit === afterDigit) {\n      result.push(beforeDigit);\n      index++;\n      continue;\n    }\n\n    if (afterDigit - beforeDigit === 1) {\n      result.push(beforeDigit);\n      result.push(...makePositionFromCodes(before.slice(index + 1), []));\n      break;\n    }\n\n    const mid = beforeDigit + Math.floor((afterDigit - beforeDigit) / 2);\n    result.push(mid);\n    break;\n  }\n\n  return result;\n}\n\nexport function posCodes(str: string) {\n  const codes: number[] = [];\n  for (let i = 0; i < str.length; i++) {\n    codes.push(str.charCodeAt(i));\n  }\n  return codes;\n}\n\nexport function pos(codes: number[]) {\n  return String.fromCharCode(...codes);\n}\n\nexport function compare(\n  itemA: { position: string },\n  itemB: { position: string }\n): number {\n  const aCodes = posCodes(itemA.position);\n  const bCodes = posCodes(itemB.position);\n\n  const maxLength = Math.max(aCodes.length, bCodes.length);\n\n  for (let i = 0; i < maxLength; i++) {\n    const a = aCodes[i] == null ? min : aCodes[i];\n    const b = bCodes[i] == null ? min : bCodes[i];\n\n    if (a === b) {\n      continue;\n    } else {\n      return a - b;\n    }\n  }\n\n  throw new Error(\n    `Impossible to compare similar position \"${itemA.position}\" and \"${itemB.position}\"`\n  );\n}\n", "import {\n  Op,\n  SerializedRecord,\n  OpType,\n  SerializedCrdt,\n  RecordUpdateOp,\n  ListInsertOp,\n  SerializedList,\n  ListMoveOp,\n  ListDeleteOp,\n  CrdtType,\n} from \"./live\";\nimport { compare, makePosition } from \"./position\";\nimport { Serializable, SerializablePrimitive } from \"./types\";\n\ntype Link = {\n  parentId: string;\n  parentKey: string;\n};\n\ntype Links = Map<string, Link>;\ntype ListCache = Map<string, Map<string, Crdt>>;\n\ntype Cache = {\n  links: Links;\n  listCache: ListCache;\n};\n\ntype Crdt = Record | List<any>;\n\nconst RECORD = Symbol(\"liveblocks.record\");\nconst LIST = Symbol(\"liveblocks.list\");\n\nexport function createRecord<T extends RecordData>(\n  id: string,\n  data: T\n): Record<T> {\n  return {\n    id,\n    $$type: RECORD,\n    ...data,\n  } as Record<T>;\n}\n\nexport function createList<T>(id: string, items: T[] = []): List<T> {\n  return {\n    id,\n    $$type: LIST,\n    length: items.length,\n    toArray: () => items,\n    map: <U>(callback: (value: T, index: number) => U) => items.map(callback),\n  };\n}\n\nexport type RecordData = { [key: string]: RecordValue };\n\ntype RecordValue =\n  | SerializablePrimitive\n  | Array<SerializablePrimitive>\n  | Serializable\n  | Record<any>\n  | List<any>;\n\nexport type Record<T extends RecordData = RecordData> = {\n  readonly id: string;\n  readonly $$type: typeof RECORD;\n} & T;\n\nexport type List<T> = {\n  readonly id: string;\n  readonly $$type: typeof LIST;\n  toArray(): Array<T>;\n  map<U>(callback: (value: T, index: number) => U): U[];\n\n  readonly length: number;\n};\n\ntype Emit = (op: Op) => void;\nfunction noop() {}\nexport class Doc<T extends RecordData> {\n  constructor(\n    public root: Record<T>,\n    private _cache: Cache,\n    private _emit: Emit\n  ) {}\n\n  static empty<T extends RecordData>(\n    id: string = \"root\",\n    emit: Emit = noop\n  ): Doc<T> {\n    const root = {\n      id,\n      $$type: RECORD,\n    } as Record<T>;\n    return new Doc<T>(root, { links: new Map(), listCache: new Map() }, emit);\n  }\n\n  static createFromRoot<T extends RecordData>(\n    data: T,\n    id: string = \"root\",\n    emit: Emit = noop\n  ) {\n    let doc = Doc.empty<T>(id, emit);\n    doc = doc.updateRecord(doc.root.id, data);\n    return doc;\n  }\n\n  static load<T extends RecordData>(\n    root: SerializedRecord,\n    emit: Emit = noop\n  ): Doc<T> {\n    let doc = Doc.empty<T>(root.id, emit);\n    return doc.dispatch({\n      type: OpType.RecordUpdate,\n      id: root.id,\n      data: root.data,\n    });\n  }\n\n  get data() {\n    return this.root;\n  }\n\n  dispatch(op: Op, shouldEmit = false): Doc<T> {\n    if (shouldEmit) {\n      this._emit(op);\n    }\n\n    if (op.id === this.root.id) {\n      const node = dispatch(this.root, op, this._cache, []);\n      return new Doc(node as Record<T>, this._cache, this._emit);\n    } else {\n      const links = getAllLinks(op.id, this.root.id, this._cache.links);\n      const node = dispatch(this.root, op, this._cache, links);\n      return new Doc(node as Record<T>, this._cache, this._emit);\n    }\n  }\n\n  private getChild(id: string) {\n    if (id === this.root.id) {\n      return this.root;\n    }\n\n    const allLinks = getAllLinks(id, this.root.id, this._cache.links);\n\n    return getChildDeep(this.root, id, allLinks, this._cache);\n  }\n\n  updateRecord<TRecord>(id: string, overrides: Partial<TRecord>) {\n    const currentRecord = this.getChild(id);\n\n    if (currentRecord == null) {\n      throw new Error(`Record with id \"${id}\" does not exist`);\n    }\n\n    let data: { [key: string]: SerializedCrdt } = {};\n\n    for (const key in overrides) {\n      const value = overrides[key];\n      data[key] = serialize(value);\n    }\n\n    const op: RecordUpdateOp = {\n      id: currentRecord.id,\n      type: OpType.RecordUpdate,\n      data,\n    };\n\n    return this.dispatch(op, true);\n  }\n\n  pushItem<TItem>(id: string, item: TItem) {\n    const list = this.getChild(id) as List<any>;\n\n    if (list == null) {\n      throw new Error(`List with id \"${id}\" does not exist`);\n    }\n\n    if (list.$$type !== LIST) {\n      throw new Error(`Node with id \"${id}\" is not a list`);\n    }\n\n    if (!isRecord(item)) {\n      throw new Error(\"List can't only have Record as children\");\n    }\n\n    const data = serialize(item);\n\n    if (list.length === 0) {\n      return this.dispatch(\n        {\n          type: OpType.ListInsert,\n          id: list.id,\n          position: makePosition(),\n          data,\n        },\n        true\n      );\n    }\n\n    const items = sortedListItems(getListItems(this._cache, id));\n    const [tailPosition] = items[items.length - 1];\n\n    const position = makePosition(tailPosition);\n\n    const operation: ListInsertOp = {\n      type: OpType.ListInsert,\n      id: list.id,\n      position,\n      data,\n    };\n\n    return this.dispatch(operation, true);\n  }\n\n  moveItem(id: string, index: number, targetIndex: number) {\n    const list = this.getChild(id);\n\n    if (list == null) {\n      throw new Error(`List with id \"${id}\" does not exist`);\n    }\n\n    if (list.$$type !== LIST) {\n      throw new Error(`Node with id \"${id}\" is not a list`);\n    }\n\n    const items = sortedListItems(getListItems(this._cache, id));\n\n    if (targetIndex < 0) {\n      throw new Error(\"targetIndex cannot be less than 0\");\n    }\n\n    if (targetIndex >= items.length) {\n      throw new Error(\n        \"targetIndex cannot be greater or equal than the list length\"\n      );\n    }\n\n    if (index < 0) {\n      throw new Error(\"index cannot be less than 0\");\n    }\n\n    if (index >= items.length) {\n      throw new Error(\"index cannot be greater or equal than the list length\");\n    }\n\n    if (index === targetIndex) {\n      return this;\n    }\n\n    let beforePosition = null;\n    let afterPosition = null;\n\n    if (index < targetIndex) {\n      afterPosition =\n        targetIndex === items.length - 1\n          ? undefined\n          : items[targetIndex + 1][0];\n      beforePosition = items[targetIndex][0];\n    } else {\n      afterPosition = items[targetIndex][0];\n      beforePosition =\n        targetIndex === 0 ? undefined : items[targetIndex - 1][0];\n    }\n\n    const position = makePosition(beforePosition, afterPosition);\n\n    const [, item] = items[index];\n    return this.dispatch(\n      {\n        type: OpType.ListMove,\n        id: list.id,\n        itemId: item.id,\n        position,\n      },\n      true\n    );\n  }\n\n  deleteItem(id: string, index: number) {\n    const list = this.getChild(id);\n\n    if (list == null) {\n      throw new Error(`List with id \"${id}\" does not exist`);\n    }\n\n    if (list.$$type !== LIST) {\n      throw new Error(`Node with id \"${id}\" is not a list`);\n    }\n\n    const items = sortedListItems(getListItems(this._cache, id));\n\n    const [, item] = items[index];\n\n    return this.dispatch(\n      {\n        type: OpType.ListRemove,\n        id: list.id,\n        itemId: item.id,\n      },\n      true\n    );\n  }\n\n  deleteItemById(id: string, itemId: string) {\n    const list = this.getChild(id);\n\n    if (list == null) {\n      throw new Error(`List with id \"${id}\" does not exist`);\n    }\n\n    if (list.$$type !== LIST) {\n      throw new Error(`Node with id \"${id}\" is not a list`);\n    }\n\n    const itemsMap = getListItems(this._cache, id);\n\n    let item = null;\n\n    for (const [, crdt] of itemsMap) {\n      if (crdt.id === itemId) {\n        item = crdt;\n        break;\n      }\n    }\n\n    if (item == null) {\n      throw new Error(\n        `List with id \"${id}\" does not have an item with id \"${itemId}\"`\n      );\n    }\n\n    return this.dispatch(\n      {\n        type: OpType.ListRemove,\n        id: list.id,\n        itemId: item.id,\n      },\n      true\n    );\n  }\n}\n\nfunction getAllLinks(id: string, rootId: string, links: Links) {\n  let currentId = id;\n  const result: Link[] = [];\n  do {\n    const link = links.get(currentId);\n    if (link == null) {\n      throw new Error(`Can't find link for id \"${currentId}\"`);\n    }\n\n    currentId = link.parentId;\n    result.push(link);\n  } while (currentId !== rootId);\n\n  return result;\n}\n\nfunction deserializeList(serialized: SerializedList, cache: Cache): List<any> {\n  const listItems = new Map<string, Crdt>();\n\n  for (const position in serialized.data) {\n    const item = deserialize(serialized.data[position], cache);\n    if (!isRecord(item)) {\n      throw new Error(\"TODO\");\n    }\n    listItems.set(position, item);\n    cache.links.set(item.id, { parentId: serialized.id, parentKey: position });\n  }\n\n  cache.listCache.set(serialized.id, listItems);\n\n  return createList(serialized.id, listItemsToArray(listItems));\n}\n\nfunction getListItems(cache: Cache, listId: string) {\n  const items = cache.listCache.get(listId);\n  if (items == null) {\n    throw new Error(`Can't find list cache for id \"${listId}\"`);\n  }\n  return items;\n}\n\nfunction deserializeRecord(serialized: SerializedRecord, cache: Cache): Record {\n  const result: any = {\n    id: serialized.id,\n    $$type: RECORD,\n  };\n\n  for (const key in serialized.data) {\n    const item = deserialize(serialized.data[key], cache);\n    if (isCrdt(item)) {\n      cache.links.set(item.id, {\n        parentId: serialized.id,\n        parentKey: key,\n      });\n    }\n    result[key] = item;\n  }\n\n  return result;\n}\n\nfunction deserialize(\n  serialized: SerializedCrdt,\n  cache: Cache\n): Record | List<any> | string {\n  switch (serialized.type) {\n    case CrdtType.Register: {\n      return serialized.data;\n    }\n    case CrdtType.Record: {\n      return deserializeRecord(serialized, cache);\n    }\n    case CrdtType.List: {\n      return deserializeList(serialized, cache);\n    }\n    default: {\n      throw new Error(\"TODO\");\n    }\n  }\n}\n\nfunction dispatchOnRecord(\n  record: Record<any>,\n  op: Op,\n  cache: Cache,\n  links: Link[]\n): Record {\n  if (links.length === 0) {\n    if (record.id !== op.id) {\n      throw new Error(\"TODO\");\n    }\n\n    switch (op.type) {\n      case OpType.RecordUpdate: {\n        return updateRecord(record, op, cache);\n      }\n      default: {\n        console.warn(\"Unsupported operation\");\n        return record;\n      }\n    }\n  }\n\n  const currentLink = links.pop()!;\n\n  const child = record[currentLink.parentKey];\n\n  const newNode = dispatch(child, op, cache, links);\n\n  return {\n    ...record,\n    [currentLink.parentKey]: newNode,\n  };\n}\n\nfunction dispatchOnList(\n  list: List<any>,\n  op: Op,\n  cache: Cache,\n  links: Link[]\n): List<any> {\n  if (links.length === 0) {\n    if (list.id !== op.id) {\n      throw new Error(\"TODO\");\n    }\n\n    switch (op.type) {\n      case OpType.ListInsert: {\n        return listInsert(list, op, cache);\n      }\n      case OpType.ListMove: {\n        return listMove(list, op, cache);\n      }\n      case OpType.ListRemove: {\n        return listDelete(list, op, cache);\n      }\n      default: {\n        console.warn(\"Unsupported operation\");\n        return list;\n      }\n    }\n  }\n\n  const currentLink = links.pop()!;\n\n  const position = currentLink.parentKey;\n\n  const items = getListItems(cache, list.id);\n\n  const item = items.get(position);\n\n  if (item == null) {\n    throw new Error(\"TODO\");\n  }\n\n  const newItem = dispatch(item, op, cache, links);\n\n  items.set(position, newItem);\n\n  return createList(list.id, listItemsToArray(items));\n}\n\nfunction dispatch(node: Crdt, op: Op, cache: Cache, links: Link[]): Crdt {\n  switch (node.$$type) {\n    case RECORD:\n      return dispatchOnRecord(node, op, cache, links);\n    case LIST:\n      return dispatchOnList(node, op, cache, links);\n    default: {\n      throw new Error(\"Unknown CRDT\");\n    }\n  }\n}\n\nfunction updateRecord(\n  node: Record<any>,\n  op: RecordUpdateOp,\n  cache: Cache\n): Record {\n  const result = { ...node };\n\n  for (const key in op.data) {\n    const value = op.data[key];\n    const item = deserialize(value, cache);\n    if (isCrdt(item)) {\n      cache.links.set(item.id, { parentId: node.id, parentKey: key });\n    }\n    result[key] = item;\n  }\n\n  return result;\n}\n\nfunction listInsert(\n  list: List<any>,\n  op: ListInsertOp,\n  cache: Cache\n): List<any> {\n  const items = getListItems(cache, list.id);\n\n  const item = deserialize(op.data, cache);\n  if (isCrdt(item)) {\n    items.set(op.position, item);\n    cache.links.set(item.id, { parentId: list.id, parentKey: op.position });\n  }\n\n  return createList(list.id, listItemsToArray(items));\n}\n\nfunction listMove(list: List<any>, op: ListMoveOp, cache: Cache): List<any> {\n  const items = getListItems(cache, list.id);\n  const link = getLinkOrThrow(cache, op.itemId);\n\n  const item = items.get(link.parentKey);\n\n  if (item == null) {\n    throw new Error(\"TODO\");\n  }\n\n  // Delete old position cache entry\n  items.delete(link.parentKey);\n\n  // Insert new position in cache\n  items.set(op.position, item);\n\n  // Update link\n  cache.links.set(op.itemId, { parentId: list.id, parentKey: op.position });\n\n  return createList(list.id, listItemsToArray(items));\n}\n\nfunction getLinkOrThrow(cache: Cache, id: string): Link {\n  const link = cache.links.get(id);\n\n  if (link == null) {\n    throw new Error(`Can't find link with id \"${id}\"`);\n  }\n\n  return link;\n}\n\nfunction listDelete(\n  list: List<any>,\n  op: ListDeleteOp,\n  cache: Cache\n): List<any> {\n  const items = getListItems(cache, list.id);\n  const link = getLinkOrThrow(cache, op.itemId);\n\n  items.delete(link.parentKey);\n  cache.links.delete(op.itemId);\n\n  return createList(list.id, listItemsToArray(items));\n}\n\nfunction listItemsToArray(items: Map<string, Crdt>) {\n  return sortedListItems(items).map((entry) => entry[1]);\n}\n\nfunction sortedListItems(items: Map<string, Crdt>) {\n  return Array.from(items.entries()).sort((entryA, entryB) =>\n    compare({ position: entryA[0] }, { position: entryB[0] })\n  );\n}\n\nfunction getChildDeep(\n  node: Crdt,\n  id: string,\n  links: Link[],\n  cache: Cache\n): Crdt {\n  let currentNode = node;\n\n  while (currentNode.id !== id) {\n    const link = links.pop();\n\n    if (link == null || link.parentId !== currentNode.id) {\n      throw new Error(\"TODO\");\n    }\n\n    if (currentNode.$$type === RECORD) {\n      currentNode = (currentNode as Record<any>)[link.parentKey];\n    } else {\n      const listItems = getListItems(cache, currentNode.id);\n      const item = listItems.get(link.parentKey);\n      if (item == null) {\n        throw new Error(\"TODO\");\n      }\n      currentNode = item;\n    }\n  }\n\n  return currentNode;\n}\n\nfunction isRecord(value: any): value is Record {\n  return value != null && typeof value === \"object\" && value.$$type === RECORD;\n}\n\nfunction isList(value: any): value is List<any> {\n  return value != null && typeof value === \"object\" && value.$$type === LIST;\n}\n\nfunction isCrdt(value: any): value is Crdt {\n  return isRecord(value) || isList(value);\n}\n\nfunction serializeRecord(record: Record): SerializedRecord {\n  const serializedData: any = {};\n  for (const key in record) {\n    if (key !== \"id\" && key !== \"$$type\") {\n      const value = record[key]!; // TODO: Find out why typescript does not like that\n      serializedData[key] = serialize(value);\n    }\n  }\n  return {\n    id: record.id,\n    type: CrdtType.Record,\n    data: serializedData,\n  };\n}\n\nfunction serializeList(list: List<any>): SerializedList {\n  return {\n    id: list.id,\n    type: CrdtType.List,\n    data: {},\n  };\n}\n\nfunction serialize(value: any): SerializedCrdt {\n  if (isRecord(value)) {\n    return serializeRecord(value);\n  } else if (isList(value)) {\n    return serializeList(value);\n  } else {\n    return { type: CrdtType.Register, data: value };\n  }\n}\n", "import { RecordData, Record, List } from \"./doc\";\n\n/**\n * Represents all the other users connected in the room. Treated as immutable.\n */\nexport interface Others<TPresence extends Presence = Presence> {\n  /**\n   * Number of other users in the room.\n   */\n  readonly count: number;\n  /**\n   * Returns the array of connected users in room.\n   */\n  toArray(): User<TPresence>[];\n  /**\n   * This function let you map over the connected users in the room.\n   */\n  map<U>(callback: (user: User<TPresence>) => U): U[];\n}\n\n/**\n * Represents a user connected in a room. Treated as immutable.\n */\nexport type User<TPresence extends Presence = Presence> = {\n  /**\n   * The connection id of the user. It is unique and increment at every new connection.\n   */\n  readonly connectionId: number;\n  /**\n   * The id of the user that has been set in the authentication endpoint.\n   * Useful to get additional information about the connected user.\n   */\n  readonly id?: string;\n  /**\n   * Additional user information that has been set in the authentication endpoint.\n   */\n  readonly info?: any;\n  /**\n   * The user presence.\n   */\n  readonly presence?: TPresence;\n};\n\nexport type Presence = Serializable;\nexport type SerializablePrimitive = boolean | string | number | null;\nexport type Serializable = {\n  [key: string]: SerializablePrimitive | Serializable | SerializablePrimitive[];\n};\n\ntype AuthEndpointCallback = (room: string) => Promise<string>;\n\nexport type AuthEndpoint = string | AuthEndpointCallback;\n\nexport type ClientOptions = {\n  /**\n   * The authentication endpoint that is called to ensure that the current user has access to a room.\n   * Can be an url or a callback if you need to attach additional headers.\n   */\n  authEndpoint: AuthEndpoint;\n  throttle?: number;\n};\n\nexport type AuthorizeResponse = {\n  token: string;\n};\n\nexport enum LiveStorageState {\n  NotInitialized = 0,\n  Loading = 1,\n  Loaded = 2,\n}\n\nexport type LiveStorage<T extends RecordData = RecordData> =\n  | {\n      state: LiveStorageState.Loading | LiveStorageState.NotInitialized;\n    }\n  | {\n      state: LiveStorageState.Loaded;\n      root: Record<T>;\n    };\n\nexport type Connection =\n  | {\n      state: \"closed\" | \"authenticating\" | \"unavailable\" | \"failed\";\n    }\n  | {\n      state: \"open\" | \"connecting\";\n      id: number;\n    };\n\nexport type OthersEvent<T extends Presence = Presence> =\n  | {\n      type: \"leave\";\n      user: User<T>;\n    }\n  | {\n      type: \"enter\";\n      user: User<T>;\n    }\n  | {\n      type: \"update\";\n      user: User<T>;\n      updates: Partial<T>;\n    }\n  | {\n      type: \"reset\";\n    };\n\nexport type Room = {\n  connect(): void;\n  disconnect(): void;\n  getConnectionState(): Connection;\n  subscribe: {\n    <T extends Presence>(\n      type: \"my-presence\",\n      listener: MyPresenceCallback<T>\n    ): void;\n    <T extends Presence>(\n      type: \"others\",\n      listener: OthersEventCallback<T>\n    ): void;\n    (type: \"event\", listener: EventCallback): void;\n    <T extends RecordData>(type: \"storage\", listener: StorageCallback<T>): void;\n    (type: \"error\", listener: (error: Error) => void): void;\n  };\n  unsubscribe: {\n    <T extends Presence>(\n      type: \"my-presence\",\n      listener: MyPresenceCallback<T>\n    ): void;\n    <T extends Presence>(\n      type: \"others\",\n      listener: OthersEventCallback<T>\n    ): void;\n    (type: \"event\", listener: EventCallback): void;\n    <T extends RecordData>(type: \"storage\", listener: StorageCallback<T>): void;\n    (type: \"error\", listener: (error: Error) => void): void;\n  };\n\n  getPresence: <T extends Presence>() => T;\n  getOthers: <T extends Presence>() => Others<T>;\n  updatePresence: <T extends Presence>(overrides: Partial<T>) => void;\n  broadcastEvent: (event: any) => void;\n\n  getStorage: () => LiveStorage;\n  fetchStorage(initialStorageFactory: InitialStorageFactory): void;\n  createRecord: <T extends RecordData>(data: T) => Record<T>;\n  createList: <T extends RecordData>() => List<Record<T>>;\n  updateRecord<T extends RecordData>(\n    record: Record<T>,\n    overrides: Partial<T>\n  ): void;\n  pushItem<T extends RecordData>(list: List<Record<T>>, item: Record<T>): void;\n  deleteItem<T extends RecordData>(list: List<Record<T>>, index: number): void;\n  deleteItemById<T extends RecordData>(\n    list: List<Record<T>>,\n    itemId: string\n  ): void;\n  moveItem<T extends RecordData>(\n    list: List<Record<T>>,\n    index: number,\n    targetIndex: number\n  ): void;\n};\n\nexport type StorageCallback<T extends RecordData = RecordData> = (\n  storage: LiveStorage<T>\n) => void;\nexport type MyPresenceCallback<T extends Presence = Presence> = (me: T) => void;\nexport type OthersEventCallback<T extends Presence = Presence> = (\n  others: Others<T>,\n  event: OthersEvent<T>\n) => void;\nexport type EventCallback = ({\n  connectionId,\n  event,\n}: {\n  connectionId: number;\n  event: any;\n}) => void;\nexport type ErrorCallback = (error: Error) => void;\n\nexport type RoomEventCallbackMap = {\n  storage: StorageCallback;\n  \"my-presence\": MyPresenceCallback;\n  others: OthersEventCallback;\n  event: EventCallback;\n  error: ErrorCallback;\n};\n\nexport type CreateRecord = Room[\"createRecord\"];\nexport type CreateList = Room[\"createList\"];\n\nexport type InitialStorageFactory<TRoot = RecordData> = (factories: {\n  createRecord: CreateRecord;\n  createList: CreateList;\n}) => TRoot;\n\nexport type Client = {\n  getRoom(roomId: string): Room | null;\n  enter(roomId: string, defaultPresence?: Presence): Room;\n  leave(roomId: string): void;\n};\n", "export function remove<T>(array: T[], item: T) {\n  for (let i = 0; i < array.length; i++) {\n    if (array[i] === item) {\n      array.splice(i, 1);\n      break;\n    }\n  }\n}\n", "import { AuthEndpoint } from \"./types\";\n\nasync function fetchAuthorize(endpoint: string, room: string): Promise<string> {\n  const res = await fetch(endpoint, {\n    method: \"POST\",\n    headers: {\n      \"Content-Type\": \"application/json\",\n    },\n    body: JSON.stringify({\n      room,\n    }),\n  });\n\n  if (!res.ok) {\n    throw new AuthenticationError(\n      `Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`\n    );\n  }\n\n  let authResponse = null;\n  try {\n    authResponse = await res.json();\n  } catch (er) {\n    throw new AuthenticationError(\n      `Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`\n    );\n  }\n\n  if (typeof authResponse.token !== \"string\") {\n    throw new AuthenticationError(\n      `Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`\n    );\n  }\n\n  return authResponse.token;\n}\n\nexport default async function auth(\n  endpoint: AuthEndpoint,\n  room: string\n): Promise<string> {\n  if (typeof endpoint === \"string\") {\n    return fetchAuthorize(endpoint, room);\n  }\n\n  if (typeof endpoint === \"function\") {\n    return endpoint(room);\n  }\n\n  throw new Error(\n    \"Authentication error. Liveblocks could not parse the response of your authentication endpoint\"\n  );\n}\n\nclass AuthenticationError extends Error {\n  constructor(message: string) {\n    super(message);\n  }\n}\n\nexport function parseToken(token: string): { actor: number } {\n  const tokenParts = token.split(\".\");\n  if (tokenParts.length !== 3) {\n    throw new AuthenticationError(\n      `Authentication error. Liveblocks could not parse the response of your authentication endpoint`\n    );\n  }\n\n  const data = JSON.parse(atob(tokenParts[1]));\n  if (typeof data.actor !== \"number\") {\n    throw new AuthenticationError(\n      `Authentication error. Liveblocks could not parse the response of your authentication endpoint`\n    );\n  }\n\n  return data;\n}\n", "import { RecordData, List } from \".\";\nimport { Doc, Record } from \"./doc\";\nimport {\n  Others,\n  Presence,\n  ClientOptions,\n  Room,\n  InitialStorageFactory,\n  MyPresenceCallback,\n  OthersEventCallback,\n  RoomEventCallbackMap,\n  StorageCallback,\n  AuthEndpoint,\n  LiveStorageState,\n  LiveStorage,\n  EventCallback,\n  User,\n  Connection,\n  Serializable,\n  ErrorCallback,\n  OthersEvent,\n} from \"./types\";\nimport {\n  createRecord as innerCreateRecord,\n  createList as innerCreateList,\n} from \"./doc\";\nimport { remove } from \"./utils\";\nimport auth, { parseToken } from \"./authentication\";\nimport {\n  ClientMessage,\n  ClientMessageType,\n  InitialDocumentStateMessage,\n  UpdateStorageMessage,\n  ServerMessageType,\n  UserLeftMessage,\n  Op,\n  EventMessage,\n  RoomStateMessage,\n  UpdatePresenceMessage,\n  UserJoinMessage,\n} from \"./live\";\n\nconst BACKOFF_RETRY_DELAYS = [250, 500, 1000, 2000, 4000, 8000, 10000];\n\nconst HEARTBEAT_INTERVAL = 30000;\n// const WAKE_UP_CHECK_INTERVAL = 2000;\nconst PONG_TIMEOUT = 2000;\n\nfunction isValidRoomEventType(value: string) {\n  return (\n    value === \"storage\" ||\n    value === \"my-presence\" ||\n    value === \"others\" ||\n    value === \"event\" ||\n    value === \"error\"\n  );\n}\n\nfunction makeIdFactory(connectionId: number): IdFactory {\n  let count = 0;\n  return () => `${connectionId}:${count++}`;\n}\n\nfunction makeOthers<T extends Presence>(presenceMap: {\n  [key: number]: User<T>;\n}): Others<T> {\n  const array = Object.values(presenceMap);\n\n  return {\n    get count() {\n      return array.length;\n    },\n    map(callback) {\n      return array.map(callback);\n    },\n    toArray() {\n      return array;\n    },\n  };\n}\n\nfunction log(...params: any[]) {\n  return;\n  console.log(...params, new Date().toString());\n}\n\ntype IdFactory = () => string;\n\nexport type State = {\n  connection: Connection;\n  socket: WebSocket | null;\n  lastFlushTime: number;\n  flushData: {\n    presence: Presence | null;\n    messages: ClientMessage[];\n    storageOperations: Op[];\n  };\n  timeoutHandles: {\n    flush: number | null;\n    reconnect: number;\n    pongTimeout: number;\n  };\n  intervalHandles: {\n    heartbeat: number;\n  };\n  listeners: {\n    storage: StorageCallback[];\n    event: EventCallback[];\n    others: OthersEventCallback[];\n    \"my-presence\": MyPresenceCallback[];\n    error: ErrorCallback[];\n  };\n  me: Presence;\n  others: Others;\n  users: {\n    [connectionId: number]: User;\n  };\n  idFactory: IdFactory | null;\n  numberOfRetry: number;\n  doc: Doc<any> | null;\n  storageState: LiveStorageState;\n  initialStorageFactory: InitialStorageFactory | null;\n};\n\nexport type Effects = {\n  authenticate(): void;\n  send(messages: ClientMessage[]): void;\n  delayFlush(delay: number): number;\n  startHeartbeatInterval(): number;\n  schedulePongTimeout(): number;\n  scheduleReconnect(delay: number): number;\n};\n\ntype Context = {\n  room: string;\n  authEndpoint: AuthEndpoint;\n  liveblocksServer: string;\n  throttleDelay: number;\n};\n\nexport function makeStateMachine(\n  state: State,\n  context: Context,\n  mockedEffects?: Effects\n) {\n  const effects: Effects = mockedEffects || {\n    async authenticate() {\n      try {\n        const token = await auth(context.authEndpoint, context.room);\n        const connectionId = parseToken(token).actor;\n        const socket = new WebSocket(\n          `${context.liveblocksServer}/?token=${token}`\n        );\n        socket.addEventListener(\"message\", onMessage);\n        socket.addEventListener(\"open\", onOpen);\n        socket.addEventListener(\"close\", onClose);\n        socket.addEventListener(\"error\", onError);\n        authenticationSuccess(connectionId, socket);\n      } catch (er) {\n        authenticationFailure(er);\n      }\n    },\n    send(messageOrMessages: ClientMessage | ClientMessage[]) {\n      if (state.socket == null) {\n        throw new Error(\"Can't send message if socket is null\");\n      }\n      state.socket.send(JSON.stringify(messageOrMessages));\n    },\n    delayFlush(delay: number) {\n      return setTimeout(tryFlushing, delay) as any;\n    },\n    startHeartbeatInterval() {\n      return setInterval(heartbeat, HEARTBEAT_INTERVAL) as any;\n    },\n    schedulePongTimeout() {\n      return setTimeout(pongTimeout, PONG_TIMEOUT) as any;\n    },\n    scheduleReconnect(delay: number) {\n      return setTimeout(connect, delay) as any;\n    },\n  };\n\n  function subscribe<T extends Presence>(\n    type: \"my-presence\",\n    listener: MyPresenceCallback<T>\n  ): void;\n  function subscribe<T extends Presence>(\n    type: \"others\",\n    listener: OthersEventCallback<T>\n  ): void;\n  function subscribe(type: \"event\", listener: EventCallback): void;\n  function subscribe<T extends RecordData>(\n    type: \"storage\",\n    listener: StorageCallback<T>\n  ): void;\n  function subscribe(type: \"error\", listener: ErrorCallback): void;\n  function subscribe<T extends keyof RoomEventCallbackMap>(\n    type: T,\n    listener: RoomEventCallbackMap[T]\n  ) {\n    if (!isValidRoomEventType(type)) {\n      throw new Error(`\"${type}\" is not a valid event name`);\n    }\n    (state.listeners[type] as RoomEventCallbackMap[T][]).push(listener);\n  }\n\n  function unsubscribe<T extends Presence>(\n    type: \"my-presence\",\n    listener: MyPresenceCallback<T>\n  ): void;\n  function unsubscribe<T extends Presence>(\n    type: \"others\",\n    listener: OthersEventCallback<T>\n  ): void;\n  function unsubscribe(type: \"event\", listener: EventCallback): void;\n  function unsubscribe<T extends RecordData>(\n    type: \"storage\",\n    listener: StorageCallback<T>\n  ): void;\n  function unsubscribe(type: \"error\", listener: ErrorCallback): void;\n  function unsubscribe<T extends keyof RoomEventCallbackMap>(\n    event: T,\n    callback: RoomEventCallbackMap[T]\n  ) {\n    if (!isValidRoomEventType(event)) {\n      throw new Error(`\"${event}\" is not a valid event name`);\n    }\n    const callbacks = state.listeners[event] as RoomEventCallbackMap[T][];\n    remove(callbacks, callback);\n  }\n\n  function getConnectionState() {\n    return state.connection;\n  }\n\n  function connect() {\n    if (typeof window === \"undefined\") {\n      return;\n    }\n\n    if (\n      state.connection.state !== \"closed\" &&\n      state.connection.state !== \"unavailable\"\n    ) {\n      return null;\n    }\n\n    updateConnection({ state: \"authenticating\" });\n    effects.authenticate();\n  }\n\n  function updatePresence<T extends Presence>(overrides: Partial<T>) {\n    const newPresence = { ...state.me, ...overrides };\n\n    if (state.flushData.presence == null) {\n      state.flushData.presence = overrides as Serializable;\n    } else {\n      for (const key in overrides) {\n        state.flushData.presence[key] = overrides[key] as any;\n      }\n    }\n\n    state.me = newPresence;\n\n    tryFlushing();\n\n    for (const listener of state.listeners[\"my-presence\"]) {\n      listener(state.me);\n    }\n  }\n\n  function authenticationSuccess(connectionId: number, socket: WebSocket) {\n    updateConnection({ state: \"connecting\", id: connectionId });\n    state.idFactory = makeIdFactory(connectionId);\n    state.socket = socket;\n  }\n\n  function authenticationFailure(error: Error) {\n    console.error(error);\n    updateConnection({ state: \"unavailable\" });\n    state.numberOfRetry++;\n    state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());\n  }\n\n  function onVisibilityChange(visibilityState: VisibilityState) {\n    if (visibilityState === \"visible\" && state.connection.state === \"open\") {\n      log(\"Heartbeat after visibility change\");\n      heartbeat();\n    }\n  }\n\n  function onUpdatePresenceMessage(message: UpdatePresenceMessage) {\n    const user = state.users[message.actor];\n    if (user == null) {\n      state.users[message.actor] = {\n        connectionId: message.actor,\n        presence: message.data,\n      };\n    } else {\n      state.users[message.actor] = {\n        id: user.id,\n        info: user.info,\n        connectionId: message.actor,\n        presence: {\n          ...user.presence,\n          ...message.data,\n        },\n      };\n    }\n    updateUsers({\n      type: \"update\",\n      updates: message.data,\n      user: state.users[message.actor],\n    });\n  }\n\n  function updateUsers(event: OthersEvent) {\n    state.others = makeOthers(state.users);\n\n    for (const listener of state.listeners[\"others\"]) {\n      listener(state.others, event);\n    }\n  }\n\n  function onUserLeftMessage(message: UserLeftMessage) {\n    const userLeftMessage: UserLeftMessage = message;\n    const user = state.users[userLeftMessage.actor];\n    if (user) {\n      delete state.users[userLeftMessage.actor];\n      updateUsers({ type: \"leave\", user });\n    }\n  }\n\n  function onRoomStateMessage(message: RoomStateMessage) {\n    const newUsers: { [connectionId: number]: User } = {};\n    for (const key in message.users) {\n      const connectionId = Number.parseInt(key);\n      const user = message.users[key];\n      newUsers[connectionId] = {\n        connectionId,\n        info: user.info,\n        id: user.id,\n      };\n    }\n    state.users = newUsers;\n    updateUsers({ type: \"reset\" });\n  }\n\n  function onNavigatorOnline() {\n    if (state.connection.state === \"unavailable\") {\n      log(\"Try to reconnect after connectivity change\");\n      reconnect();\n    }\n  }\n\n  function onEvent(message: EventMessage) {\n    for (const listener of state.listeners.event) {\n      listener({ connectionId: message.actor, event: message.event });\n    }\n  }\n\n  function onUserJoinedMessage(message: UserJoinMessage) {\n    state.users[message.actor] = {\n      connectionId: message.actor,\n      info: message.info,\n      id: message.id,\n    };\n    updateUsers({ type: \"enter\", user: state.users[message.actor] });\n\n    if (state.me) {\n      // Send current presence to new user\n      // TODO: Consider storing it on the backend\n      state.flushData.messages.push({\n        type: ClientMessageType.UpdatePresence,\n        data: state.me!,\n        targetActor: message.actor,\n      });\n      tryFlushing();\n    }\n  }\n\n  function onMessage(event: MessageEvent) {\n    if (event.data === \"pong\") {\n      clearTimeout(state.timeoutHandles.pongTimeout);\n      return;\n    }\n\n    const message = JSON.parse(event.data);\n    switch (message.type) {\n      case ServerMessageType.InitialStorageState: {\n        onInitialStorageState(message);\n        break;\n      }\n      case ServerMessageType.UpdateStorage: {\n        onStorageUpdates(message);\n        break;\n      }\n      case ServerMessageType.UserJoined: {\n        onUserJoinedMessage(message as UserJoinMessage);\n        break;\n      }\n      case ServerMessageType.UpdatePresence: {\n        onUpdatePresenceMessage(message as UpdatePresenceMessage);\n        break;\n      }\n      case ServerMessageType.Event: {\n        onEvent(message);\n        break;\n      }\n      case ServerMessageType.UserLeft: {\n        onUserLeftMessage(message as UserLeftMessage);\n        break;\n      }\n      case ServerMessageType.RoomState: {\n        onRoomStateMessage(message as RoomStateMessage);\n        break;\n      }\n    }\n  }\n\n  // function onWakeUp() {\n  //   // Sometimes, the browser can put the webpage on pause (computer is on sleep mode for example)\n  //   // The client will not know that the server has probably close the connection even if the readyState is Open\n  //   // One way to detect this kind of pause is to ensure that a setInterval is not taking more than the delay it was configured with\n  //   if (state.connection.state === \"open\") {\n  //     log(\"Try to reconnect after laptop wake up\");\n  //     reconnect();\n  //   }\n  // }\n\n  function onClose(event: { code: number; wasClean: boolean; reason: any }) {\n    state.socket = null;\n\n    clearTimeout(state.timeoutHandles.pongTimeout);\n    clearInterval(state.intervalHandles.heartbeat);\n    if (state.timeoutHandles.flush) {\n      clearTimeout(state.timeoutHandles.flush);\n    }\n    clearTimeout(state.timeoutHandles.reconnect);\n\n    state.users = {};\n    updateUsers({ type: \"reset\" });\n\n    if (event.code >= 4000 && event.code <= 4100) {\n      updateConnection({ state: \"failed\" });\n\n      const error = new LiveblocksError(event.reason, event.code);\n      for (const listener of state.listeners.error) {\n        listener(error);\n      }\n    } else if (event.wasClean === false) {\n      updateConnection({ state: \"unavailable\" });\n      state.numberOfRetry++;\n      state.timeoutHandles.reconnect = effects.scheduleReconnect(\n        getRetryDelay()\n      );\n    } else {\n      updateConnection({ state: \"closed\" });\n    }\n  }\n\n  function updateConnection(connection: Connection) {\n    state.connection = connection;\n  }\n\n  function getRetryDelay() {\n    return BACKOFF_RETRY_DELAYS[\n      state.numberOfRetry < BACKOFF_RETRY_DELAYS.length\n        ? state.numberOfRetry\n        : BACKOFF_RETRY_DELAYS.length - 1\n    ];\n  }\n\n  function onError() {}\n\n  function onOpen() {\n    clearInterval(state.intervalHandles.heartbeat);\n\n    state.intervalHandles.heartbeat = effects.startHeartbeatInterval();\n\n    updateConnection({ state: \"open\", id: (state.connection as any).id });\n    state.numberOfRetry = 0;\n    tryFlushing();\n  }\n\n  function heartbeat() {\n    if (state.socket == null) {\n      // Should never happen, because we clear the pong timeout when the connection is dropped explictly\n      return;\n    }\n\n    clearTimeout(state.timeoutHandles.pongTimeout);\n    state.timeoutHandles.pongTimeout = effects.schedulePongTimeout();\n\n    if (state.socket.readyState === WebSocket.OPEN) {\n      state.socket.send(\"ping\");\n    }\n  }\n\n  function pongTimeout() {\n    log(\"Pong timeout. Trying to reconnect.\");\n    reconnect();\n  }\n\n  function reconnect() {\n    if (state.socket) {\n      state.socket.removeEventListener(\"open\", onOpen);\n      state.socket.removeEventListener(\"message\", onMessage);\n      state.socket.removeEventListener(\"close\", onClose);\n      state.socket.removeEventListener(\"error\", onError);\n      state.socket.close();\n      state.socket = null;\n    }\n\n    updateConnection({ state: \"unavailable\" });\n    clearTimeout(state.timeoutHandles.pongTimeout);\n    if (state.timeoutHandles.flush) {\n      clearTimeout(state.timeoutHandles.flush);\n    }\n    clearTimeout(state.timeoutHandles.reconnect);\n    clearInterval(state.intervalHandles.heartbeat);\n    connect();\n  }\n\n  function tryFlushing() {\n    if (state.socket == null) {\n      return;\n    }\n\n    if (state.socket.readyState !== WebSocket.OPEN) {\n      return;\n    }\n\n    const now = Date.now();\n\n    const elapsedTime = now - state.lastFlushTime;\n\n    if (elapsedTime > context.throttleDelay) {\n      const messages = flushDataToMessages(state);\n      if (messages.length === 0) {\n        return;\n      }\n      effects.send(messages);\n      state.flushData = {\n        messages: [],\n        storageOperations: [],\n        presence: null,\n      };\n      state.lastFlushTime = now;\n    } else {\n      if (state.timeoutHandles.flush != null) {\n        clearTimeout(state.timeoutHandles.flush);\n      }\n\n      state.timeoutHandles.flush = effects.delayFlush(\n        context.throttleDelay - (now - state.lastFlushTime)\n      );\n    }\n  }\n\n  function flushDataToMessages(state: State) {\n    const messages: ClientMessage[] = [];\n    if (state.flushData.presence) {\n      messages.push({\n        type: ClientMessageType.UpdatePresence,\n        data: state.flushData.presence,\n      });\n    }\n    for (const event of state.flushData.messages) {\n      messages.push(event);\n    }\n    if (state.flushData.storageOperations.length > 0) {\n      messages.push({\n        type: ClientMessageType.UpdateStorage,\n        ops: state.flushData.storageOperations,\n      });\n    }\n    return messages;\n  }\n\n  function disconnect() {\n    if (state.socket) {\n      state.socket.removeEventListener(\"open\", onOpen);\n      state.socket.removeEventListener(\"message\", onMessage);\n      state.socket.removeEventListener(\"close\", onClose);\n      state.socket.removeEventListener(\"error\", onError);\n      state.socket.close();\n      state.socket = null;\n    }\n    updateConnection({ state: \"closed\" });\n    if (state.timeoutHandles.flush) {\n      clearTimeout(state.timeoutHandles.flush);\n    }\n    clearTimeout(state.timeoutHandles.reconnect);\n    clearTimeout(state.timeoutHandles.pongTimeout);\n    clearInterval(state.intervalHandles.heartbeat);\n    state.users = {};\n    updateUsers({ type: \"reset\" });\n    clearListeners();\n  }\n\n  function clearListeners() {\n    for (const key in state.listeners) {\n      state.listeners[key as keyof State[\"listeners\"]] = [];\n    }\n  }\n\n  function getPresence<T extends Presence>(): T {\n    return state.me as T;\n  }\n\n  function getOthers<T extends Presence>(): Others<T> {\n    return state.others as Others<T>;\n  }\n\n  function broadcastEvent(event: any) {\n    if (state.socket == null) {\n      return;\n    }\n\n    state.flushData.messages.push({\n      type: ClientMessageType.ClientEvent,\n      event,\n    });\n    tryFlushing();\n  }\n\n  /**\n   * STORAGE\n   */\n\n  function onStorageUpdates(message: UpdateStorageMessage) {\n    if (state.doc == null) {\n      // TODO: Cache updates in case they are coming while root is queried\n      return;\n    }\n    updateDoc(message.ops.reduce((doc, op) => doc.dispatch(op), state.doc));\n  }\n\n  function updateDoc(doc: Doc<any> | null) {\n    state.doc = doc;\n    if (doc) {\n      for (const listener of state.listeners.storage) {\n        listener(getStorage());\n      }\n    }\n  }\n\n  function getStorage(): LiveStorage {\n    if (state.storageState === LiveStorageState.Loaded) {\n      return {\n        state: state.storageState,\n        root: state.doc!.root,\n      };\n    }\n\n    return {\n      state: state.storageState,\n    };\n  }\n\n  function onInitialStorageState(message: InitialDocumentStateMessage) {\n    state.storageState = LiveStorageState.Loaded;\n    if (message.root == null) {\n      const rootId = makeId();\n      state.doc = Doc.empty<any>(rootId, (op) => dispatch(op));\n      updateDoc(\n        state.doc.updateRecord(\n          rootId,\n          state.initialStorageFactory!({\n            createRecord: <T extends RecordData>(data: T) =>\n              createRecord<T>(data),\n            createList: () => createList(),\n          })\n        )\n      );\n    } else {\n      updateDoc(Doc.load<any>(message.root, (op) => dispatch(op)));\n    }\n  }\n\n  function makeId() {\n    if (state.idFactory == null) {\n      throw new Error(\"Can't generate id. Id factory is missing.\");\n    }\n    return state.idFactory();\n  }\n\n  function dispatch(op: Op) {\n    state.flushData.storageOperations.push(op);\n\n    tryFlushing();\n  }\n\n  function createRecord<T extends RecordData>(data: any): Record<T> {\n    return innerCreateRecord(makeId(), data);\n  }\n\n  function createList<T extends RecordData>(): List<Record<T>> {\n    return innerCreateList(makeId());\n  }\n\n  function fetchStorage(initialStorageFactory: InitialStorageFactory) {\n    state.initialStorageFactory = initialStorageFactory;\n    state.storageState = LiveStorageState.Loading;\n    state.flushData.messages.push({ type: ClientMessageType.FetchStorage });\n    tryFlushing();\n  }\n\n  function updateRecord<T extends RecordData>(\n    record: Record<T>,\n    overrides: Partial<T>\n  ) {\n    updateDoc(state.doc!.updateRecord(record.id, overrides));\n  }\n\n  function pushItem<T extends RecordData>(\n    list: List<Record<T>>,\n    item: Record<T>\n  ) {\n    updateDoc(state.doc!.pushItem(list.id, item));\n  }\n  function deleteItem<T extends RecordData>(\n    list: List<Record<T>>,\n    index: number\n  ) {\n    updateDoc(state.doc!.deleteItem(list.id, index));\n  }\n  function deleteItemById<T extends RecordData>(\n    list: List<Record<T>>,\n    itemId: string\n  ) {\n    updateDoc(state.doc!.deleteItemById(list.id, itemId));\n  }\n  function moveItem<T extends RecordData>(\n    list: List<Record<T>>,\n    index: number,\n    targetIndex: number\n  ) {\n    updateDoc(state.doc!.moveItem(list.id, index, targetIndex));\n  }\n\n  return {\n    // Internal\n    onOpen,\n    onClose,\n    onMessage,\n    authenticationSuccess,\n    heartbeat,\n    onNavigatorOnline,\n    // onWakeUp,\n    onVisibilityChange,\n\n    // Core\n    connect,\n    disconnect,\n    subscribe,\n    unsubscribe,\n\n    // Presence\n    updatePresence,\n    broadcastEvent,\n\n    // Storage\n    fetchStorage,\n    createRecord,\n    updateRecord,\n    createList,\n    pushItem,\n    deleteItem,\n    deleteItemById,\n    moveItem,\n\n    selectors: {\n      // Core\n      getConnectionState,\n\n      // Presence\n      getPresence,\n      getOthers,\n\n      // Storage\n      getStorage,\n    },\n  };\n}\n\nexport function defaultState(me?: Presence): State {\n  return {\n    connection: { state: \"closed\" },\n    socket: null,\n    listeners: {\n      storage: [],\n      event: [],\n      others: [],\n      \"my-presence\": [],\n      error: [],\n    },\n    numberOfRetry: 0,\n    lastFlushTime: 0,\n    timeoutHandles: {\n      flush: null,\n      reconnect: 0,\n      pongTimeout: 0,\n    },\n    flushData: {\n      presence: null,\n      messages: [],\n      storageOperations: [],\n    },\n    intervalHandles: {\n      heartbeat: 0,\n    },\n    me: me == null ? {} : me,\n    users: {},\n    others: makeOthers({}),\n    storageState: LiveStorageState.NotInitialized,\n    initialStorageFactory: null,\n    doc: null,\n    idFactory: null,\n  };\n}\n\nexport function createRoom(\n  name: string,\n  options: ClientOptions & {\n    initialPresence?: Presence;\n  }\n): Room {\n  const throttleDelay = options.throttle || 100;\n  const liveblocksServer: string =\n    (options as any).liveblocksServer || \"wss://live.liveblocks.io\";\n  const authEndpoint: AuthEndpoint = options.authEndpoint;\n\n  const state = defaultState(options.initialPresence);\n\n  const machine = makeStateMachine(state, {\n    throttleDelay,\n    liveblocksServer,\n    authEndpoint,\n    room: name,\n  });\n\n  const room: Room = {\n    /////////////\n    // Core    //\n    /////////////\n    connect: machine.connect,\n    disconnect: machine.disconnect,\n    getConnectionState: machine.selectors.getConnectionState,\n    subscribe: machine.subscribe,\n    unsubscribe: machine.unsubscribe,\n\n    /////////////\n    // Storage //\n    /////////////\n    getStorage: machine.selectors.getStorage,\n    fetchStorage: machine.fetchStorage,\n    createRecord: machine.createRecord,\n    createList: machine.createList,\n    updateRecord: machine.updateRecord,\n    pushItem: machine.pushItem,\n    deleteItem: machine.deleteItem,\n    deleteItemById: machine.deleteItemById,\n    moveItem: machine.moveItem,\n\n    //////////////\n    // Presence //\n    //////////////\n    getPresence: machine.selectors.getPresence,\n    updatePresence: machine.updatePresence,\n    getOthers: machine.selectors.getOthers,\n    broadcastEvent: machine.broadcastEvent,\n  };\n\n  (room as any)._onNavigatorOnline = machine.onNavigatorOnline;\n  (room as any)._onVisibilityChange = machine.onVisibilityChange;\n\n  return room;\n}\n\nclass LiveblocksError extends Error {\n  constructor(message: string, public code: number) {\n    super(message);\n  }\n}\n", "import { createRoom } from \"./room\";\nimport { ClientOptions, Room, Client, Presence } from \"./types\";\n\nexport function createClient(options: ClientOptions): Client {\n  if (typeof options.throttle === \"number\") {\n    if (options.throttle < 80 || options.throttle > 1000) {\n      throw new Error(\n        \"Liveblocks client throttle should be between 80 and 1000 ms\"\n      );\n    }\n  }\n\n  const rooms = new Map<string, Room>();\n\n  function getRoom(roomId: string): Room | null {\n    return rooms.get(roomId) || null;\n  }\n\n  function enter(roomId: string, initialPresence?: Presence) {\n    let room = rooms.get(roomId);\n    if (room) {\n      return room;\n    }\n    room = createRoom(roomId, { ...options, initialPresence });\n    rooms.set(roomId, room);\n    room.connect();\n    return room;\n  }\n\n  function leave(roomId: string) {\n    let room = rooms.get(roomId);\n    if (room) {\n      room.disconnect();\n      rooms.delete(roomId);\n    }\n  }\n\n  if (typeof window !== \"undefined\") {\n    // TODO: Expose a way to clear these\n    window.addEventListener(\"online\", () => {\n      for (const [, room] of rooms) {\n        (room as any)._onNavigatorOnline();\n      }\n    });\n  }\n\n  if (typeof document !== \"undefined\") {\n    document.addEventListener(\"visibilitychange\", () => {\n      for (const [, room] of rooms) {\n        (room as any)._onVisibilityChange(document.visibilityState);\n      }\n    });\n  }\n\n  return {\n    getRoom,\n    enter,\n    leave,\n  };\n}\n"],
  "mappings": "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",
  "names": []
}
