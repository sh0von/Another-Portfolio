import { Op, SerializedRecord } from "./live";
import { Serializable, SerializablePrimitive } from "./types";
declare type Link = {
    parentId: string;
    parentKey: string;
};
declare type Links = Map<string, Link>;
declare type ListCache = Map<string, Map<string, Crdt>>;
declare type Cache = {
    links: Links;
    listCache: ListCache;
};
declare type Crdt = Record | List<any>;
declare const RECORD: unique symbol;
declare const LIST: unique symbol;
export declare function createRecord<T extends RecordData>(id: string, data: T): Record<T>;
export declare function createList<T>(id: string, items?: T[]): List<T>;
export declare type RecordData = {
    [key: string]: RecordValue;
};
declare type RecordValue = SerializablePrimitive | Array<SerializablePrimitive> | Serializable | Record<any> | List<any>;
export declare type Record<T extends RecordData = RecordData> = {
    readonly id: string;
    readonly $$type: typeof RECORD;
} & T;
export declare type List<T> = {
    readonly id: string;
    readonly $$type: typeof LIST;
    toArray(): Array<T>;
    map<U>(callback: (value: T, index: number) => U): U[];
    readonly length: number;
};
declare type Emit = (op: Op) => void;
export declare class Doc<T extends RecordData> {
    root: Record<T>;
    private _cache;
    private _emit;
    constructor(root: Record<T>, _cache: Cache, _emit: Emit);
    static empty<T extends RecordData>(id?: string, emit?: Emit): Doc<T>;
    static createFromRoot<T extends RecordData>(data: T, id?: string, emit?: Emit): Doc<T>;
    static load<T extends RecordData>(root: SerializedRecord, emit?: Emit): Doc<T>;
    get data(): Record<T>;
    dispatch(op: Op, shouldEmit?: boolean): Doc<T>;
    private getChild;
    updateRecord<TRecord>(id: string, overrides: Partial<TRecord>): Doc<T>;
    pushItem<TItem>(id: string, item: TItem): Doc<T>;
    moveItem(id: string, index: number, targetIndex: number): Doc<T>;
    deleteItem(id: string, index: number): Doc<T>;
    deleteItemById(id: string, itemId: string): Doc<T>;
}
export {};
