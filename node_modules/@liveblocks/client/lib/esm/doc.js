import { OpType, CrdtType, } from "./live";
import { compare, makePosition } from "./position";
const RECORD = Symbol("liveblocks.record");
const LIST = Symbol("liveblocks.list");
export function createRecord(id, data) {
    return Object.assign({ id, $$type: RECORD }, data);
}
export function createList(id, items = []) {
    return {
        id,
        $$type: LIST,
        length: items.length,
        toArray: () => items,
        map: (callback) => items.map(callback),
    };
}
function noop() { }
export class Doc {
    constructor(root, _cache, _emit) {
        this.root = root;
        this._cache = _cache;
        this._emit = _emit;
    }
    static empty(id = "root", emit = noop) {
        const root = {
            id,
            $$type: RECORD,
        };
        return new Doc(root, { links: new Map(), listCache: new Map() }, emit);
    }
    static createFromRoot(data, id = "root", emit = noop) {
        let doc = Doc.empty(id, emit);
        doc = doc.updateRecord(doc.root.id, data);
        return doc;
    }
    static load(root, emit = noop) {
        let doc = Doc.empty(root.id, emit);
        return doc.dispatch({
            type: OpType.RecordUpdate,
            id: root.id,
            data: root.data,
        });
    }
    get data() {
        return this.root;
    }
    dispatch(op, shouldEmit = false) {
        if (shouldEmit) {
            this._emit(op);
        }
        if (op.id === this.root.id) {
            const node = dispatch(this.root, op, this._cache, []);
            return new Doc(node, this._cache, this._emit);
        }
        else {
            const links = getAllLinks(op.id, this.root.id, this._cache.links);
            const node = dispatch(this.root, op, this._cache, links);
            return new Doc(node, this._cache, this._emit);
        }
    }
    getChild(id) {
        if (id === this.root.id) {
            return this.root;
        }
        const allLinks = getAllLinks(id, this.root.id, this._cache.links);
        return getChildDeep(this.root, id, allLinks, this._cache);
    }
    updateRecord(id, overrides) {
        const currentRecord = this.getChild(id);
        if (currentRecord == null) {
            throw new Error(`Record with id "${id}" does not exist`);
        }
        let data = {};
        for (const key in overrides) {
            const value = overrides[key];
            data[key] = serialize(value);
        }
        const op = {
            id: currentRecord.id,
            type: OpType.RecordUpdate,
            data,
        };
        return this.dispatch(op, true);
    }
    pushItem(id, item) {
        const list = this.getChild(id);
        if (list == null) {
            throw new Error(`List with id "${id}" does not exist`);
        }
        if (list.$$type !== LIST) {
            throw new Error(`Node with id "${id}" is not a list`);
        }
        if (!isRecord(item)) {
            throw new Error("List can't only have Record as children");
        }
        const data = serialize(item);
        if (list.length === 0) {
            return this.dispatch({
                type: OpType.ListInsert,
                id: list.id,
                position: makePosition(),
                data,
            }, true);
        }
        const items = sortedListItems(getListItems(this._cache, id));
        const [tailPosition] = items[items.length - 1];
        const position = makePosition(tailPosition);
        const operation = {
            type: OpType.ListInsert,
            id: list.id,
            position,
            data,
        };
        return this.dispatch(operation, true);
    }
    moveItem(id, index, targetIndex) {
        const list = this.getChild(id);
        if (list == null) {
            throw new Error(`List with id "${id}" does not exist`);
        }
        if (list.$$type !== LIST) {
            throw new Error(`Node with id "${id}" is not a list`);
        }
        const items = sortedListItems(getListItems(this._cache, id));
        if (targetIndex < 0) {
            throw new Error("targetIndex cannot be less than 0");
        }
        if (targetIndex >= items.length) {
            throw new Error("targetIndex cannot be greater or equal than the list length");
        }
        if (index < 0) {
            throw new Error("index cannot be less than 0");
        }
        if (index >= items.length) {
            throw new Error("index cannot be greater or equal than the list length");
        }
        if (index === targetIndex) {
            return this;
        }
        let beforePosition = null;
        let afterPosition = null;
        if (index < targetIndex) {
            afterPosition =
                targetIndex === items.length - 1
                    ? undefined
                    : items[targetIndex + 1][0];
            beforePosition = items[targetIndex][0];
        }
        else {
            afterPosition = items[targetIndex][0];
            beforePosition =
                targetIndex === 0 ? undefined : items[targetIndex - 1][0];
        }
        const position = makePosition(beforePosition, afterPosition);
        const [, item] = items[index];
        return this.dispatch({
            type: OpType.ListMove,
            id: list.id,
            itemId: item.id,
            position,
        }, true);
    }
    deleteItem(id, index) {
        const list = this.getChild(id);
        if (list == null) {
            throw new Error(`List with id "${id}" does not exist`);
        }
        if (list.$$type !== LIST) {
            throw new Error(`Node with id "${id}" is not a list`);
        }
        const items = sortedListItems(getListItems(this._cache, id));
        const [, item] = items[index];
        return this.dispatch({
            type: OpType.ListRemove,
            id: list.id,
            itemId: item.id,
        }, true);
    }
    deleteItemById(id, itemId) {
        const list = this.getChild(id);
        if (list == null) {
            throw new Error(`List with id "${id}" does not exist`);
        }
        if (list.$$type !== LIST) {
            throw new Error(`Node with id "${id}" is not a list`);
        }
        const itemsMap = getListItems(this._cache, id);
        let item = null;
        for (const [, crdt] of itemsMap) {
            if (crdt.id === itemId) {
                item = crdt;
                break;
            }
        }
        if (item == null) {
            throw new Error(`List with id "${id}" does not have an item with id "${itemId}"`);
        }
        return this.dispatch({
            type: OpType.ListRemove,
            id: list.id,
            itemId: item.id,
        }, true);
    }
}
function getAllLinks(id, rootId, links) {
    let currentId = id;
    const result = [];
    do {
        const link = links.get(currentId);
        if (link == null) {
            throw new Error(`Can't find link for id "${currentId}"`);
        }
        currentId = link.parentId;
        result.push(link);
    } while (currentId !== rootId);
    return result;
}
function deserializeList(serialized, cache) {
    const listItems = new Map();
    for (const position in serialized.data) {
        const item = deserialize(serialized.data[position], cache);
        if (!isRecord(item)) {
            throw new Error("TODO");
        }
        listItems.set(position, item);
        cache.links.set(item.id, { parentId: serialized.id, parentKey: position });
    }
    cache.listCache.set(serialized.id, listItems);
    return createList(serialized.id, listItemsToArray(listItems));
}
function getListItems(cache, listId) {
    const items = cache.listCache.get(listId);
    if (items == null) {
        throw new Error(`Can't find list cache for id "${listId}"`);
    }
    return items;
}
function deserializeRecord(serialized, cache) {
    const result = {
        id: serialized.id,
        $$type: RECORD,
    };
    for (const key in serialized.data) {
        const item = deserialize(serialized.data[key], cache);
        if (isCrdt(item)) {
            cache.links.set(item.id, {
                parentId: serialized.id,
                parentKey: key,
            });
        }
        result[key] = item;
    }
    return result;
}
function deserialize(serialized, cache) {
    switch (serialized.type) {
        case CrdtType.Register: {
            return serialized.data;
        }
        case CrdtType.Record: {
            return deserializeRecord(serialized, cache);
        }
        case CrdtType.List: {
            return deserializeList(serialized, cache);
        }
        default: {
            throw new Error("TODO");
        }
    }
}
function dispatchOnRecord(record, op, cache, links) {
    if (links.length === 0) {
        if (record.id !== op.id) {
            throw new Error("TODO");
        }
        switch (op.type) {
            case OpType.RecordUpdate: {
                return updateRecord(record, op, cache);
            }
            default: {
                console.warn("Unsupported operation");
                return record;
            }
        }
    }
    const currentLink = links.pop();
    const child = record[currentLink.parentKey];
    const newNode = dispatch(child, op, cache, links);
    return Object.assign(Object.assign({}, record), { [currentLink.parentKey]: newNode });
}
function dispatchOnList(list, op, cache, links) {
    if (links.length === 0) {
        if (list.id !== op.id) {
            throw new Error("TODO");
        }
        switch (op.type) {
            case OpType.ListInsert: {
                return listInsert(list, op, cache);
            }
            case OpType.ListMove: {
                return listMove(list, op, cache);
            }
            case OpType.ListRemove: {
                return listDelete(list, op, cache);
            }
            default: {
                console.warn("Unsupported operation");
                return list;
            }
        }
    }
    const currentLink = links.pop();
    const position = currentLink.parentKey;
    const items = getListItems(cache, list.id);
    const item = items.get(position);
    if (item == null) {
        throw new Error("TODO");
    }
    const newItem = dispatch(item, op, cache, links);
    items.set(position, newItem);
    return createList(list.id, listItemsToArray(items));
}
function dispatch(node, op, cache, links) {
    switch (node.$$type) {
        case RECORD:
            return dispatchOnRecord(node, op, cache, links);
        case LIST:
            return dispatchOnList(node, op, cache, links);
        default: {
            throw new Error("Unknown CRDT");
        }
    }
}
function updateRecord(node, op, cache) {
    const result = Object.assign({}, node);
    for (const key in op.data) {
        const value = op.data[key];
        const item = deserialize(value, cache);
        if (isCrdt(item)) {
            cache.links.set(item.id, { parentId: node.id, parentKey: key });
        }
        result[key] = item;
    }
    return result;
}
function listInsert(list, op, cache) {
    const items = getListItems(cache, list.id);
    const item = deserialize(op.data, cache);
    if (isCrdt(item)) {
        items.set(op.position, item);
        cache.links.set(item.id, { parentId: list.id, parentKey: op.position });
    }
    return createList(list.id, listItemsToArray(items));
}
function listMove(list, op, cache) {
    const items = getListItems(cache, list.id);
    const link = getLinkOrThrow(cache, op.itemId);
    const item = items.get(link.parentKey);
    if (item == null) {
        throw new Error("TODO");
    }
    // Delete old position cache entry
    items.delete(link.parentKey);
    // Insert new position in cache
    items.set(op.position, item);
    // Update link
    cache.links.set(op.itemId, { parentId: list.id, parentKey: op.position });
    return createList(list.id, listItemsToArray(items));
}
function getLinkOrThrow(cache, id) {
    const link = cache.links.get(id);
    if (link == null) {
        throw new Error(`Can't find link with id "${id}"`);
    }
    return link;
}
function listDelete(list, op, cache) {
    const items = getListItems(cache, list.id);
    const link = getLinkOrThrow(cache, op.itemId);
    items.delete(link.parentKey);
    cache.links.delete(op.itemId);
    return createList(list.id, listItemsToArray(items));
}
function listItemsToArray(items) {
    return sortedListItems(items).map((entry) => entry[1]);
}
function sortedListItems(items) {
    return Array.from(items.entries()).sort((entryA, entryB) => compare({ position: entryA[0] }, { position: entryB[0] }));
}
function getChildDeep(node, id, links, cache) {
    let currentNode = node;
    while (currentNode.id !== id) {
        const link = links.pop();
        if (link == null || link.parentId !== currentNode.id) {
            throw new Error("TODO");
        }
        if (currentNode.$$type === RECORD) {
            currentNode = currentNode[link.parentKey];
        }
        else {
            const listItems = getListItems(cache, currentNode.id);
            const item = listItems.get(link.parentKey);
            if (item == null) {
                throw new Error("TODO");
            }
            currentNode = item;
        }
    }
    return currentNode;
}
function isRecord(value) {
    return value != null && typeof value === "object" && value.$$type === RECORD;
}
function isList(value) {
    return value != null && typeof value === "object" && value.$$type === LIST;
}
function isCrdt(value) {
    return isRecord(value) || isList(value);
}
function serializeRecord(record) {
    const serializedData = {};
    for (const key in record) {
        if (key !== "id" && key !== "$$type") {
            const value = record[key]; // TODO: Find out why typescript does not like that
            serializedData[key] = serialize(value);
        }
    }
    return {
        id: record.id,
        type: CrdtType.Record,
        data: serializedData,
    };
}
function serializeList(list) {
    return {
        id: list.id,
        type: CrdtType.List,
        data: {},
    };
}
function serialize(value) {
    if (isRecord(value)) {
        return serializeRecord(value);
    }
    else if (isList(value)) {
        return serializeList(value);
    }
    else {
        return { type: CrdtType.Register, data: value };
    }
}
