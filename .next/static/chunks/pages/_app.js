/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/_app"],{

/***/ "./node_modules/@liveblocks/client/lib/esm/authentication.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/authentication.js ***!
  \*******************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ auth; },\n/* harmony export */   \"parseToken\": function() { return /* binding */ parseToken; }\n/* harmony export */ });\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\nfunction fetchAuthorize(endpoint, room) {\n    return __awaiter(this, void 0, void 0, function* () {\n        const res = yield fetch(endpoint, {\n            method: \"POST\",\n            headers: {\n                \"Content-Type\": \"application/json\",\n            },\n            body: JSON.stringify({\n                room,\n            }),\n        });\n        if (!res.ok) {\n            throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`);\n        }\n        let authResponse = null;\n        try {\n            authResponse = yield res.json();\n        }\n        catch (er) {\n            throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`);\n        }\n        if (typeof authResponse.token !== \"string\") {\n            throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication \"${endpoint}\"`);\n        }\n        return authResponse.token;\n    });\n}\nfunction auth(endpoint, room) {\n    return __awaiter(this, void 0, void 0, function* () {\n        if (typeof endpoint === \"string\") {\n            return fetchAuthorize(endpoint, room);\n        }\n        if (typeof endpoint === \"function\") {\n            const { token } = yield endpoint(room);\n            // TODO: Validation\n            return token;\n        }\n        throw new Error(\"Authentication error. Liveblocks could not parse the response of your authentication endpoint\");\n    });\n}\nclass AuthenticationError extends Error {\n    constructor(message) {\n        super(message);\n    }\n}\nfunction parseToken(token) {\n    const tokenParts = token.split(\".\");\n    if (tokenParts.length !== 3) {\n        throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication endpoint`);\n    }\n    const data = JSON.parse(atob(tokenParts[1]));\n    if (typeof data.actor !== \"number\") {\n        throw new AuthenticationError(`Authentication error. Liveblocks could not parse the response of your authentication endpoint`);\n    }\n    return data;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vYXV0aGVudGljYXRpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQSxtSUFBbUksU0FBUztBQUM1STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUksU0FBUztBQUM1STtBQUNBO0FBQ0EsbUlBQW1JLFNBQVM7QUFDNUk7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixRQUFRO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NsaWVudC9saWIvZXNtL2F1dGhlbnRpY2F0aW9uLmpzPzVjNWEiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fYXdhaXRlciA9ICh0aGlzICYmIHRoaXMuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5mdW5jdGlvbiBmZXRjaEF1dGhvcml6ZShlbmRwb2ludCwgcm9vbSkge1xuICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHJlcyA9IHlpZWxkIGZldGNoKGVuZHBvaW50LCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgICAgICAgICByb29tLFxuICAgICAgICAgICAgfSksXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIXJlcy5vaykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3IoYEF1dGhlbnRpY2F0aW9uIGVycm9yLiBMaXZlYmxvY2tzIGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2Ugb2YgeW91ciBhdXRoZW50aWNhdGlvbiBcIiR7ZW5kcG9pbnR9XCJgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgYXV0aFJlc3BvbnNlID0gbnVsbDtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF1dGhSZXNwb25zZSA9IHlpZWxkIHJlcy5qc29uKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVyKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihgQXV0aGVudGljYXRpb24gZXJyb3IuIExpdmVibG9ja3MgY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZSBvZiB5b3VyIGF1dGhlbnRpY2F0aW9uIFwiJHtlbmRwb2ludH1cImApO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgYXV0aFJlc3BvbnNlLnRva2VuICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgQXV0aGVudGljYXRpb25FcnJvcihgQXV0aGVudGljYXRpb24gZXJyb3IuIExpdmVibG9ja3MgY291bGQgbm90IHBhcnNlIHRoZSByZXNwb25zZSBvZiB5b3VyIGF1dGhlbnRpY2F0aW9uIFwiJHtlbmRwb2ludH1cImApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhdXRoUmVzcG9uc2UudG9rZW47XG4gICAgfSk7XG59XG5leHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBhdXRoKGVuZHBvaW50LCByb29tKSB7XG4gICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBlbmRwb2ludCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgcmV0dXJuIGZldGNoQXV0aG9yaXplKGVuZHBvaW50LCByb29tKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGVuZHBvaW50ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgdG9rZW4gfSA9IHlpZWxkIGVuZHBvaW50KHJvb20pO1xuICAgICAgICAgICAgLy8gVE9ETzogVmFsaWRhdGlvblxuICAgICAgICAgICAgcmV0dXJuIHRva2VuO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkF1dGhlbnRpY2F0aW9uIGVycm9yLiBMaXZlYmxvY2tzIGNvdWxkIG5vdCBwYXJzZSB0aGUgcmVzcG9uc2Ugb2YgeW91ciBhdXRoZW50aWNhdGlvbiBlbmRwb2ludFwiKTtcbiAgICB9KTtcbn1cbmNsYXNzIEF1dGhlbnRpY2F0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICB9XG59XG5leHBvcnQgZnVuY3Rpb24gcGFyc2VUb2tlbih0b2tlbikge1xuICAgIGNvbnN0IHRva2VuUGFydHMgPSB0b2tlbi5zcGxpdChcIi5cIik7XG4gICAgaWYgKHRva2VuUGFydHMubGVuZ3RoICE9PSAzKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKGBBdXRoZW50aWNhdGlvbiBlcnJvci4gTGl2ZWJsb2NrcyBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlIG9mIHlvdXIgYXV0aGVudGljYXRpb24gZW5kcG9pbnRgKTtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9IEpTT04ucGFyc2UoYXRvYih0b2tlblBhcnRzWzFdKSk7XG4gICAgaWYgKHR5cGVvZiBkYXRhLmFjdG9yICE9PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHRocm93IG5ldyBBdXRoZW50aWNhdGlvbkVycm9yKGBBdXRoZW50aWNhdGlvbiBlcnJvci4gTGl2ZWJsb2NrcyBjb3VsZCBub3QgcGFyc2UgdGhlIHJlc3BvbnNlIG9mIHlvdXIgYXV0aGVudGljYXRpb24gZW5kcG9pbnRgKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/authentication.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/client.js":
/*!***********************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/client.js ***!
  \***********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createClient\": function() { return /* binding */ createClient; }\n/* harmony export */ });\n/* harmony import */ var _room__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./room */ \"./node_modules/@liveblocks/client/lib/esm/room.js\");\n\n/**\n * Create a client that will be responsible to communicate with liveblocks servers.\n *\n * ### Example\n * ```\n * const client = createClient({\n *   authEndpoint: \"/api/auth\"\n * });\n *\n * // It's also possible to use a function to call your authentication endpoint.\n * // Useful to add additional headers or use an API wrapper (like Firebase functions)\n * const client = createClient({\n *   authEndpoint: async (room) => {\n *     const response = await fetch(\"/api/auth\", {\n *       method: \"POST\",\n *       headers: {\n *          Authentication: \"token\",\n *          \"Content-Type\": \"application/json\"\n *       },\n *       body: JSON.stringify({ room })\n *     });\n *\n *     return await response.json();\n *   }\n * });\n * ```\n */\nfunction createClient(options) {\n    if (typeof options.throttle === \"number\") {\n        if (options.throttle < 80 || options.throttle > 1000) {\n            throw new Error(\"Liveblocks client throttle should be between 80 and 1000 ms\");\n        }\n    }\n    const rooms = new Map();\n    function getRoom(roomId) {\n        const internalRoom = rooms.get(roomId);\n        return internalRoom ? internalRoom.room : null;\n    }\n    function enter(roomId, initialPresence) {\n        let internalRoom = rooms.get(roomId);\n        if (internalRoom) {\n            return internalRoom.room;\n        }\n        internalRoom = (0,_room__WEBPACK_IMPORTED_MODULE_0__.createRoom)(roomId, Object.assign(Object.assign({}, options), { initialPresence }));\n        rooms.set(roomId, internalRoom);\n        internalRoom.connect();\n        return internalRoom.room;\n    }\n    function leave(roomId) {\n        let room = rooms.get(roomId);\n        if (room) {\n            room.disconnect();\n            rooms.delete(roomId);\n        }\n    }\n    if (typeof window !== \"undefined\") {\n        // TODO: Expose a way to clear these\n        window.addEventListener(\"online\", () => {\n            for (const [, room] of rooms) {\n                room.onNavigatorOnline();\n            }\n        });\n    }\n    if (typeof document !== \"undefined\") {\n        document.addEventListener(\"visibilitychange\", () => {\n            for (const [, room] of rooms) {\n                room.onVisibilityChange(document.visibilityState);\n            }\n        });\n    }\n    return {\n        getRoom,\n        enter,\n        leave,\n    };\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vY2xpZW50LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdDQUFnQyxNQUFNO0FBQ3RDLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLGlEQUFVLHVDQUF1QyxjQUFjLGlCQUFpQjtBQUN2RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vY2xpZW50LmpzP2Y4ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgY3JlYXRlUm9vbSB9IGZyb20gXCIuL3Jvb21cIjtcbi8qKlxuICogQ3JlYXRlIGEgY2xpZW50IHRoYXQgd2lsbCBiZSByZXNwb25zaWJsZSB0byBjb21tdW5pY2F0ZSB3aXRoIGxpdmVibG9ja3Mgc2VydmVycy5cbiAqXG4gKiAjIyMgRXhhbXBsZVxuICogYGBgXG4gKiBjb25zdCBjbGllbnQgPSBjcmVhdGVDbGllbnQoe1xuICogICBhdXRoRW5kcG9pbnQ6IFwiL2FwaS9hdXRoXCJcbiAqIH0pO1xuICpcbiAqIC8vIEl0J3MgYWxzbyBwb3NzaWJsZSB0byB1c2UgYSBmdW5jdGlvbiB0byBjYWxsIHlvdXIgYXV0aGVudGljYXRpb24gZW5kcG9pbnQuXG4gKiAvLyBVc2VmdWwgdG8gYWRkIGFkZGl0aW9uYWwgaGVhZGVycyBvciB1c2UgYW4gQVBJIHdyYXBwZXIgKGxpa2UgRmlyZWJhc2UgZnVuY3Rpb25zKVxuICogY29uc3QgY2xpZW50ID0gY3JlYXRlQ2xpZW50KHtcbiAqICAgYXV0aEVuZHBvaW50OiBhc3luYyAocm9vbSkgPT4ge1xuICogICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2goXCIvYXBpL2F1dGhcIiwge1xuICogICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAqICAgICAgIGhlYWRlcnM6IHtcbiAqICAgICAgICAgIEF1dGhlbnRpY2F0aW9uOiBcInRva2VuXCIsXG4gKiAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIlxuICogICAgICAgfSxcbiAqICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHsgcm9vbSB9KVxuICogICAgIH0pO1xuICpcbiAqICAgICByZXR1cm4gYXdhaXQgcmVzcG9uc2UuanNvbigpO1xuICogICB9XG4gKiB9KTtcbiAqIGBgYFxuICovXG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlQ2xpZW50KG9wdGlvbnMpIHtcbiAgICBpZiAodHlwZW9mIG9wdGlvbnMudGhyb3R0bGUgPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMudGhyb3R0bGUgPCA4MCB8fCBvcHRpb25zLnRocm90dGxlID4gMTAwMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGl2ZWJsb2NrcyBjbGllbnQgdGhyb3R0bGUgc2hvdWxkIGJlIGJldHdlZW4gODAgYW5kIDEwMDAgbXNcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3Qgcm9vbXMgPSBuZXcgTWFwKCk7XG4gICAgZnVuY3Rpb24gZ2V0Um9vbShyb29tSWQpIHtcbiAgICAgICAgY29uc3QgaW50ZXJuYWxSb29tID0gcm9vbXMuZ2V0KHJvb21JZCk7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbFJvb20gPyBpbnRlcm5hbFJvb20ucm9vbSA6IG51bGw7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGVudGVyKHJvb21JZCwgaW5pdGlhbFByZXNlbmNlKSB7XG4gICAgICAgIGxldCBpbnRlcm5hbFJvb20gPSByb29tcy5nZXQocm9vbUlkKTtcbiAgICAgICAgaWYgKGludGVybmFsUm9vbSkge1xuICAgICAgICAgICAgcmV0dXJuIGludGVybmFsUm9vbS5yb29tO1xuICAgICAgICB9XG4gICAgICAgIGludGVybmFsUm9vbSA9IGNyZWF0ZVJvb20ocm9vbUlkLCBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMpLCB7IGluaXRpYWxQcmVzZW5jZSB9KSk7XG4gICAgICAgIHJvb21zLnNldChyb29tSWQsIGludGVybmFsUm9vbSk7XG4gICAgICAgIGludGVybmFsUm9vbS5jb25uZWN0KCk7XG4gICAgICAgIHJldHVybiBpbnRlcm5hbFJvb20ucm9vbTtcbiAgICB9XG4gICAgZnVuY3Rpb24gbGVhdmUocm9vbUlkKSB7XG4gICAgICAgIGxldCByb29tID0gcm9vbXMuZ2V0KHJvb21JZCk7XG4gICAgICAgIGlmIChyb29tKSB7XG4gICAgICAgICAgICByb29tLmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgICAgIHJvb21zLmRlbGV0ZShyb29tSWQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIC8vIFRPRE86IEV4cG9zZSBhIHdheSB0byBjbGVhciB0aGVzZVxuICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcIm9ubGluZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHJvb21dIG9mIHJvb21zKSB7XG4gICAgICAgICAgICAgICAgcm9vbS5vbk5hdmlnYXRvck9ubGluZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidmlzaWJpbGl0eWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IFssIHJvb21dIG9mIHJvb21zKSB7XG4gICAgICAgICAgICAgICAgcm9vbS5vblZpc2liaWxpdHlDaGFuZ2UoZG9jdW1lbnQudmlzaWJpbGl0eVN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAgIGdldFJvb20sXG4gICAgICAgIGVudGVyLFxuICAgICAgICBsZWF2ZSxcbiAgICB9O1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/client.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/doc.js":
/*!********************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/doc.js ***!
  \********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createRecord\": function() { return /* binding */ createRecord; },\n/* harmony export */   \"createList\": function() { return /* binding */ createList; },\n/* harmony export */   \"Doc\": function() { return /* binding */ Doc; }\n/* harmony export */ });\n/* harmony import */ var _live__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./live */ \"./node_modules/@liveblocks/client/lib/esm/live.js\");\n/* harmony import */ var _position__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./position */ \"./node_modules/@liveblocks/client/lib/esm/position.js\");\n\n\nconst RECORD = Symbol(\"liveblocks.record\");\nconst LIST = Symbol(\"liveblocks.list\");\nfunction createRecord(id, data) {\n    return Object.assign({ id, $$type: RECORD }, data);\n}\nfunction createList(id, items = []) {\n    return {\n        id,\n        $$type: LIST,\n        length: items.length,\n        toArray: () => items,\n        map: (callback) => items.map(callback),\n    };\n}\nfunction noop() { }\nclass Doc {\n    constructor(root, _cache, _emit) {\n        this.root = root;\n        this._cache = _cache;\n        this._emit = _emit;\n    }\n    static empty(id = \"root\", emit = noop) {\n        const root = {\n            id,\n            $$type: RECORD,\n        };\n        return new Doc(root, { links: new Map(), listCache: new Map() }, emit);\n    }\n    static createFromRoot(data, id = \"root\", emit = noop) {\n        let doc = Doc.empty(id, emit);\n        doc = doc.updateRecord(doc.root.id, data);\n        return doc;\n    }\n    static load(root, emit = noop) {\n        let doc = Doc.empty(root.id, emit);\n        return doc.dispatch({\n            type: _live__WEBPACK_IMPORTED_MODULE_0__.OpType.RecordUpdate,\n            id: root.id,\n            data: root.data,\n        });\n    }\n    get data() {\n        return this.root;\n    }\n    dispatch(op, shouldEmit = false) {\n        if (shouldEmit) {\n            this._emit(op);\n        }\n        if (op.id === this.root.id) {\n            const node = dispatch(this.root, op, this._cache, []);\n            return new Doc(node, this._cache, this._emit);\n        }\n        else {\n            const links = getAllLinks(op.id, this.root.id, this._cache.links);\n            const node = dispatch(this.root, op, this._cache, links);\n            return new Doc(node, this._cache, this._emit);\n        }\n    }\n    getChild(id) {\n        if (id === this.root.id) {\n            return this.root;\n        }\n        const allLinks = getAllLinks(id, this.root.id, this._cache.links);\n        return getChildDeep(this.root, id, allLinks, this._cache);\n    }\n    updateRecord(id, overrides) {\n        const currentRecord = this.getChild(id);\n        if (currentRecord == null) {\n            throw new Error(`Record with id \"${id}\" does not exist`);\n        }\n        let data = {};\n        for (const key in overrides) {\n            const value = overrides[key];\n            data[key] = serialize(value);\n        }\n        const op = {\n            id: currentRecord.id,\n            type: _live__WEBPACK_IMPORTED_MODULE_0__.OpType.RecordUpdate,\n            data,\n        };\n        return this.dispatch(op, true);\n    }\n    pushItem(id, item) {\n        const list = this.getChild(id);\n        if (list == null) {\n            throw new Error(`List with id \"${id}\" does not exist`);\n        }\n        if (list.$$type !== LIST) {\n            throw new Error(`Node with id \"${id}\" is not a list`);\n        }\n        if (!isRecord(item)) {\n            throw new Error(\"List can't only have Record as children\");\n        }\n        const data = serialize(item);\n        if (list.length === 0) {\n            return this.dispatch({\n                type: _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListInsert,\n                id: list.id,\n                position: (0,_position__WEBPACK_IMPORTED_MODULE_1__.makePosition)(),\n                data,\n            }, true);\n        }\n        const items = sortedListItems(getListItems(this._cache, id));\n        const [tailPosition] = items[items.length - 1];\n        const position = (0,_position__WEBPACK_IMPORTED_MODULE_1__.makePosition)(tailPosition);\n        const operation = {\n            type: _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListInsert,\n            id: list.id,\n            position,\n            data,\n        };\n        return this.dispatch(operation, true);\n    }\n    moveItem(id, index, targetIndex) {\n        const list = this.getChild(id);\n        if (list == null) {\n            throw new Error(`List with id \"${id}\" does not exist`);\n        }\n        if (list.$$type !== LIST) {\n            throw new Error(`Node with id \"${id}\" is not a list`);\n        }\n        const items = sortedListItems(getListItems(this._cache, id));\n        if (targetIndex < 0) {\n            throw new Error(\"targetIndex cannot be less than 0\");\n        }\n        if (targetIndex >= items.length) {\n            throw new Error(\"targetIndex cannot be greater or equal than the list length\");\n        }\n        if (index < 0) {\n            throw new Error(\"index cannot be less than 0\");\n        }\n        if (index >= items.length) {\n            throw new Error(\"index cannot be greater or equal than the list length\");\n        }\n        if (index === targetIndex) {\n            return this;\n        }\n        let beforePosition = null;\n        let afterPosition = null;\n        if (index < targetIndex) {\n            afterPosition =\n                targetIndex === items.length - 1\n                    ? undefined\n                    : items[targetIndex + 1][0];\n            beforePosition = items[targetIndex][0];\n        }\n        else {\n            afterPosition = items[targetIndex][0];\n            beforePosition =\n                targetIndex === 0 ? undefined : items[targetIndex - 1][0];\n        }\n        const position = (0,_position__WEBPACK_IMPORTED_MODULE_1__.makePosition)(beforePosition, afterPosition);\n        const [, item] = items[index];\n        return this.dispatch({\n            type: _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListMove,\n            id: list.id,\n            itemId: item.id,\n            position,\n        }, true);\n    }\n    deleteItem(id, index) {\n        const list = this.getChild(id);\n        if (list == null) {\n            throw new Error(`List with id \"${id}\" does not exist`);\n        }\n        if (list.$$type !== LIST) {\n            throw new Error(`Node with id \"${id}\" is not a list`);\n        }\n        const items = sortedListItems(getListItems(this._cache, id));\n        const [, item] = items[index];\n        return this.dispatch({\n            type: _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListRemove,\n            id: list.id,\n            itemId: item.id,\n        }, true);\n    }\n    deleteItemById(id, itemId) {\n        const list = this.getChild(id);\n        if (list == null) {\n            throw new Error(`List with id \"${id}\" does not exist`);\n        }\n        if (list.$$type !== LIST) {\n            throw new Error(`Node with id \"${id}\" is not a list`);\n        }\n        const itemsMap = getListItems(this._cache, id);\n        let item = null;\n        for (const [, crdt] of itemsMap) {\n            if (crdt.id === itemId) {\n                item = crdt;\n                break;\n            }\n        }\n        if (item == null) {\n            throw new Error(`List with id \"${id}\" does not have an item with id \"${itemId}\"`);\n        }\n        return this.dispatch({\n            type: _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListRemove,\n            id: list.id,\n            itemId: item.id,\n        }, true);\n    }\n}\nfunction getAllLinks(id, rootId, links) {\n    let currentId = id;\n    const result = [];\n    do {\n        const link = links.get(currentId);\n        if (link == null) {\n            throw new Error(`Can't find link for id \"${currentId}\"`);\n        }\n        currentId = link.parentId;\n        result.push(link);\n    } while (currentId !== rootId);\n    return result;\n}\nfunction deserializeList(serialized, cache) {\n    const listItems = new Map();\n    for (const position in serialized.data) {\n        const item = deserialize(serialized.data[position], cache);\n        if (!isRecord(item)) {\n            throw new Error(\"TODO\");\n        }\n        listItems.set(position, item);\n        cache.links.set(item.id, { parentId: serialized.id, parentKey: position });\n    }\n    cache.listCache.set(serialized.id, listItems);\n    return createList(serialized.id, listItemsToArray(listItems));\n}\nfunction getListItems(cache, listId) {\n    const items = cache.listCache.get(listId);\n    if (items == null) {\n        throw new Error(`Can't find list cache for id \"${listId}\"`);\n    }\n    return items;\n}\nfunction deserializeRecord(serialized, cache) {\n    const result = {\n        id: serialized.id,\n        $$type: RECORD,\n    };\n    for (const key in serialized.data) {\n        const item = deserialize(serialized.data[key], cache);\n        if (isCrdt(item)) {\n            cache.links.set(item.id, {\n                parentId: serialized.id,\n                parentKey: key,\n            });\n        }\n        result[key] = item;\n    }\n    return result;\n}\nfunction deserialize(serialized, cache) {\n    switch (serialized.type) {\n        case _live__WEBPACK_IMPORTED_MODULE_0__.CrdtType.Register: {\n            return serialized.data;\n        }\n        case _live__WEBPACK_IMPORTED_MODULE_0__.CrdtType.Record: {\n            return deserializeRecord(serialized, cache);\n        }\n        case _live__WEBPACK_IMPORTED_MODULE_0__.CrdtType.List: {\n            return deserializeList(serialized, cache);\n        }\n        default: {\n            throw new Error(\"TODO\");\n        }\n    }\n}\nfunction dispatchOnRecord(record, op, cache, links) {\n    if (links.length === 0) {\n        if (record.id !== op.id) {\n            throw new Error(\"TODO\");\n        }\n        switch (op.type) {\n            case _live__WEBPACK_IMPORTED_MODULE_0__.OpType.RecordUpdate: {\n                return updateRecord(record, op, cache);\n            }\n            default: {\n                console.warn(\"Unsupported operation\");\n                return record;\n            }\n        }\n    }\n    const currentLink = links.pop();\n    const child = record[currentLink.parentKey];\n    const newNode = dispatch(child, op, cache, links);\n    return Object.assign(Object.assign({}, record), { [currentLink.parentKey]: newNode });\n}\nfunction dispatchOnList(list, op, cache, links) {\n    if (links.length === 0) {\n        if (list.id !== op.id) {\n            throw new Error(\"TODO\");\n        }\n        switch (op.type) {\n            case _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListInsert: {\n                return listInsert(list, op, cache);\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListMove: {\n                return listMove(list, op, cache);\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_0__.OpType.ListRemove: {\n                return listDelete(list, op, cache);\n            }\n            default: {\n                console.warn(\"Unsupported operation\");\n                return list;\n            }\n        }\n    }\n    const currentLink = links.pop();\n    const position = currentLink.parentKey;\n    const items = getListItems(cache, list.id);\n    const item = items.get(position);\n    if (item == null) {\n        throw new Error(\"TODO\");\n    }\n    const newItem = dispatch(item, op, cache, links);\n    items.set(position, newItem);\n    return createList(list.id, listItemsToArray(items));\n}\nfunction dispatch(node, op, cache, links) {\n    switch (node.$$type) {\n        case RECORD:\n            return dispatchOnRecord(node, op, cache, links);\n        case LIST:\n            return dispatchOnList(node, op, cache, links);\n        default: {\n            throw new Error(\"Unknown CRDT\");\n        }\n    }\n}\nfunction updateRecord(node, op, cache) {\n    const result = Object.assign({}, node);\n    for (const key in op.data) {\n        const value = op.data[key];\n        const item = deserialize(value, cache);\n        if (isCrdt(item)) {\n            cache.links.set(item.id, { parentId: node.id, parentKey: key });\n        }\n        result[key] = item;\n    }\n    return result;\n}\nfunction listInsert(list, op, cache) {\n    const items = getListItems(cache, list.id);\n    const item = deserialize(op.data, cache);\n    if (isCrdt(item)) {\n        items.set(op.position, item);\n        cache.links.set(item.id, { parentId: list.id, parentKey: op.position });\n    }\n    return createList(list.id, listItemsToArray(items));\n}\nfunction listMove(list, op, cache) {\n    const items = getListItems(cache, list.id);\n    const link = getLinkOrThrow(cache, op.itemId);\n    const item = items.get(link.parentKey);\n    if (item == null) {\n        throw new Error(\"TODO\");\n    }\n    // Delete old position cache entry\n    items.delete(link.parentKey);\n    // Insert new position in cache\n    items.set(op.position, item);\n    // Update link\n    cache.links.set(op.itemId, { parentId: list.id, parentKey: op.position });\n    return createList(list.id, listItemsToArray(items));\n}\nfunction getLinkOrThrow(cache, id) {\n    const link = cache.links.get(id);\n    if (link == null) {\n        throw new Error(`Can't find link with id \"${id}\"`);\n    }\n    return link;\n}\nfunction listDelete(list, op, cache) {\n    const items = getListItems(cache, list.id);\n    const link = getLinkOrThrow(cache, op.itemId);\n    items.delete(link.parentKey);\n    cache.links.delete(op.itemId);\n    return createList(list.id, listItemsToArray(items));\n}\nfunction listItemsToArray(items) {\n    return sortedListItems(items).map((entry) => entry[1]);\n}\nfunction sortedListItems(items) {\n    return Array.from(items.entries()).sort((entryA, entryB) => (0,_position__WEBPACK_IMPORTED_MODULE_1__.compare)({ position: entryA[0] }, { position: entryB[0] }));\n}\nfunction getChildDeep(node, id, links, cache) {\n    let currentNode = node;\n    while (currentNode.id !== id) {\n        const link = links.pop();\n        if (link == null || link.parentId !== currentNode.id) {\n            throw new Error(\"TODO\");\n        }\n        if (currentNode.$$type === RECORD) {\n            currentNode = currentNode[link.parentKey];\n        }\n        else {\n            const listItems = getListItems(cache, currentNode.id);\n            const item = listItems.get(link.parentKey);\n            if (item == null) {\n                throw new Error(\"TODO\");\n            }\n            currentNode = item;\n        }\n    }\n    return currentNode;\n}\nfunction isRecord(value) {\n    return value != null && typeof value === \"object\" && value.$$type === RECORD;\n}\nfunction isList(value) {\n    return value != null && typeof value === \"object\" && value.$$type === LIST;\n}\nfunction isCrdt(value) {\n    return isRecord(value) || isList(value);\n}\nfunction serializeRecord(record) {\n    const serializedData = {};\n    for (const key in record) {\n        if (key !== \"id\" && key !== \"$$type\") {\n            const value = record[key]; // TODO: Find out why typescript does not like that\n            serializedData[key] = serialize(value);\n        }\n    }\n    return {\n        id: record.id,\n        type: _live__WEBPACK_IMPORTED_MODULE_0__.CrdtType.Record,\n        data: serializedData,\n    };\n}\nfunction serializeList(list) {\n    return {\n        id: list.id,\n        type: _live__WEBPACK_IMPORTED_MODULE_0__.CrdtType.List,\n        data: {},\n    };\n}\nfunction serialize(value) {\n    if (isRecord(value)) {\n        return serializeRecord(value);\n    }\n    else if (isList(value)) {\n        return serializeList(value);\n    }\n    else {\n        return { type: _live__WEBPACK_IMPORTED_MODULE_0__.CrdtType.Register, data: value };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vZG9jLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQTJDO0FBQ1E7QUFDbkQ7QUFDQTtBQUNPO0FBQ1AsMkJBQTJCLG9CQUFvQjtBQUMvQztBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3Q0FBd0M7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLHNEQUFtQjtBQUNyQztBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDLEdBQUc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixzREFBbUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkMsR0FBRztBQUNoRDtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0Isb0RBQWlCO0FBQ3ZDO0FBQ0EsMEJBQTBCLHVEQUFZO0FBQ3RDO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLHlCQUF5Qix1REFBWTtBQUNyQztBQUNBLGtCQUFrQixvREFBaUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLEdBQUc7QUFDaEQ7QUFDQTtBQUNBLDZDQUE2QyxHQUFHO0FB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrREFBZTtBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLGdEQUFhO0FBQzNCLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQixNQUFNLG9EQUFpQjtBQUN4QztBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jbGllbnQvbGliL2VzbS9kb2MuanM/NDAxYyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBPcFR5cGUsIENyZHRUeXBlLCB9IGZyb20gXCIuL2xpdmVcIjtcbmltcG9ydCB7IGNvbXBhcmUsIG1ha2VQb3NpdGlvbiB9IGZyb20gXCIuL3Bvc2l0aW9uXCI7XG5jb25zdCBSRUNPUkQgPSBTeW1ib2woXCJsaXZlYmxvY2tzLnJlY29yZFwiKTtcbmNvbnN0IExJU1QgPSBTeW1ib2woXCJsaXZlYmxvY2tzLmxpc3RcIik7XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGlkLCBkYXRhKSB7XG4gICAgcmV0dXJuIE9iamVjdC5hc3NpZ24oeyBpZCwgJCR0eXBlOiBSRUNPUkQgfSwgZGF0YSk7XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlTGlzdChpZCwgaXRlbXMgPSBbXSkge1xuICAgIHJldHVybiB7XG4gICAgICAgIGlkLFxuICAgICAgICAkJHR5cGU6IExJU1QsXG4gICAgICAgIGxlbmd0aDogaXRlbXMubGVuZ3RoLFxuICAgICAgICB0b0FycmF5OiAoKSA9PiBpdGVtcyxcbiAgICAgICAgbWFwOiAoY2FsbGJhY2spID0+IGl0ZW1zLm1hcChjYWxsYmFjayksXG4gICAgfTtcbn1cbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbmV4cG9ydCBjbGFzcyBEb2Mge1xuICAgIGNvbnN0cnVjdG9yKHJvb3QsIF9jYWNoZSwgX2VtaXQpIHtcbiAgICAgICAgdGhpcy5yb290ID0gcm9vdDtcbiAgICAgICAgdGhpcy5fY2FjaGUgPSBfY2FjaGU7XG4gICAgICAgIHRoaXMuX2VtaXQgPSBfZW1pdDtcbiAgICB9XG4gICAgc3RhdGljIGVtcHR5KGlkID0gXCJyb290XCIsIGVtaXQgPSBub29wKSB7XG4gICAgICAgIGNvbnN0IHJvb3QgPSB7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICQkdHlwZTogUkVDT1JELFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gbmV3IERvYyhyb290LCB7IGxpbmtzOiBuZXcgTWFwKCksIGxpc3RDYWNoZTogbmV3IE1hcCgpIH0sIGVtaXQpO1xuICAgIH1cbiAgICBzdGF0aWMgY3JlYXRlRnJvbVJvb3QoZGF0YSwgaWQgPSBcInJvb3RcIiwgZW1pdCA9IG5vb3ApIHtcbiAgICAgICAgbGV0IGRvYyA9IERvYy5lbXB0eShpZCwgZW1pdCk7XG4gICAgICAgIGRvYyA9IGRvYy51cGRhdGVSZWNvcmQoZG9jLnJvb3QuaWQsIGRhdGEpO1xuICAgICAgICByZXR1cm4gZG9jO1xuICAgIH1cbiAgICBzdGF0aWMgbG9hZChyb290LCBlbWl0ID0gbm9vcCkge1xuICAgICAgICBsZXQgZG9jID0gRG9jLmVtcHR5KHJvb3QuaWQsIGVtaXQpO1xuICAgICAgICByZXR1cm4gZG9jLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IE9wVHlwZS5SZWNvcmRVcGRhdGUsXG4gICAgICAgICAgICBpZDogcm9vdC5pZCxcbiAgICAgICAgICAgIGRhdGE6IHJvb3QuZGF0YSxcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGdldCBkYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgIH1cbiAgICBkaXNwYXRjaChvcCwgc2hvdWxkRW1pdCA9IGZhbHNlKSB7XG4gICAgICAgIGlmIChzaG91bGRFbWl0KSB7XG4gICAgICAgICAgICB0aGlzLl9lbWl0KG9wKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3AuaWQgPT09IHRoaXMucm9vdC5pZCkge1xuICAgICAgICAgICAgY29uc3Qgbm9kZSA9IGRpc3BhdGNoKHRoaXMucm9vdCwgb3AsIHRoaXMuX2NhY2hlLCBbXSk7XG4gICAgICAgICAgICByZXR1cm4gbmV3IERvYyhub2RlLCB0aGlzLl9jYWNoZSwgdGhpcy5fZW1pdCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBsaW5rcyA9IGdldEFsbExpbmtzKG9wLmlkLCB0aGlzLnJvb3QuaWQsIHRoaXMuX2NhY2hlLmxpbmtzKTtcbiAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBkaXNwYXRjaCh0aGlzLnJvb3QsIG9wLCB0aGlzLl9jYWNoZSwgbGlua3MpO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBEb2Mobm9kZSwgdGhpcy5fY2FjaGUsIHRoaXMuX2VtaXQpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldENoaWxkKGlkKSB7XG4gICAgICAgIGlmIChpZCA9PT0gdGhpcy5yb290LmlkKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5yb290O1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGFsbExpbmtzID0gZ2V0QWxsTGlua3MoaWQsIHRoaXMucm9vdC5pZCwgdGhpcy5fY2FjaGUubGlua3MpO1xuICAgICAgICByZXR1cm4gZ2V0Q2hpbGREZWVwKHRoaXMucm9vdCwgaWQsIGFsbExpbmtzLCB0aGlzLl9jYWNoZSk7XG4gICAgfVxuICAgIHVwZGF0ZVJlY29yZChpZCwgb3ZlcnJpZGVzKSB7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRSZWNvcmQgPSB0aGlzLmdldENoaWxkKGlkKTtcbiAgICAgICAgaWYgKGN1cnJlbnRSZWNvcmQgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSZWNvcmQgd2l0aCBpZCBcIiR7aWR9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZGF0YSA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gb3ZlcnJpZGVzW2tleV07XG4gICAgICAgICAgICBkYXRhW2tleV0gPSBzZXJpYWxpemUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG9wID0ge1xuICAgICAgICAgICAgaWQ6IGN1cnJlbnRSZWNvcmQuaWQsXG4gICAgICAgICAgICB0eXBlOiBPcFR5cGUuUmVjb3JkVXBkYXRlLFxuICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2gob3AsIHRydWUpO1xuICAgIH1cbiAgICBwdXNoSXRlbShpZCwgaXRlbSkge1xuICAgICAgICBjb25zdCBsaXN0ID0gdGhpcy5nZXRDaGlsZChpZCk7XG4gICAgICAgIGlmIChsaXN0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlzdCB3aXRoIGlkIFwiJHtpZH1cIiBkb2VzIG5vdCBleGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0LiQkdHlwZSAhPT0gTElTVCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBOb2RlIHdpdGggaWQgXCIke2lkfVwiIGlzIG5vdCBhIGxpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWlzUmVjb3JkKGl0ZW0pKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMaXN0IGNhbid0IG9ubHkgaGF2ZSBSZWNvcmQgYXMgY2hpbGRyZW5cIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgZGF0YSA9IHNlcmlhbGl6ZShpdGVtKTtcbiAgICAgICAgaWYgKGxpc3QubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5kaXNwYXRjaCh7XG4gICAgICAgICAgICAgICAgdHlwZTogT3BUeXBlLkxpc3RJbnNlcnQsXG4gICAgICAgICAgICAgICAgaWQ6IGxpc3QuaWQsXG4gICAgICAgICAgICAgICAgcG9zaXRpb246IG1ha2VQb3NpdGlvbigpLFxuICAgICAgICAgICAgICAgIGRhdGEsXG4gICAgICAgICAgICB9LCB0cnVlKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBpdGVtcyA9IHNvcnRlZExpc3RJdGVtcyhnZXRMaXN0SXRlbXModGhpcy5fY2FjaGUsIGlkKSk7XG4gICAgICAgIGNvbnN0IFt0YWlsUG9zaXRpb25dID0gaXRlbXNbaXRlbXMubGVuZ3RoIC0gMV07XG4gICAgICAgIGNvbnN0IHBvc2l0aW9uID0gbWFrZVBvc2l0aW9uKHRhaWxQb3NpdGlvbik7XG4gICAgICAgIGNvbnN0IG9wZXJhdGlvbiA9IHtcbiAgICAgICAgICAgIHR5cGU6IE9wVHlwZS5MaXN0SW5zZXJ0LFxuICAgICAgICAgICAgaWQ6IGxpc3QuaWQsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgICAgIGRhdGEsXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKG9wZXJhdGlvbiwgdHJ1ZSk7XG4gICAgfVxuICAgIG1vdmVJdGVtKGlkLCBpbmRleCwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgICAgY29uc3QgbGlzdCA9IHRoaXMuZ2V0Q2hpbGQoaWQpO1xuICAgICAgICBpZiAobGlzdCA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYExpc3Qgd2l0aCBpZCBcIiR7aWR9XCIgZG9lcyBub3QgZXhpc3RgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGlzdC4kJHR5cGUgIT09IExJU1QpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTm9kZSB3aXRoIGlkIFwiJHtpZH1cIiBpcyBub3QgYSBsaXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgaXRlbXMgPSBzb3J0ZWRMaXN0SXRlbXMoZ2V0TGlzdEl0ZW1zKHRoaXMuX2NhY2hlLCBpZCkpO1xuICAgICAgICBpZiAodGFyZ2V0SW5kZXggPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0YXJnZXRJbmRleCBjYW5ub3QgYmUgbGVzcyB0aGFuIDBcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRhcmdldEluZGV4ID49IGl0ZW1zLmxlbmd0aCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidGFyZ2V0SW5kZXggY2Fubm90IGJlIGdyZWF0ZXIgb3IgZXF1YWwgdGhhbiB0aGUgbGlzdCBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiaW5kZXggY2Fubm90IGJlIGxlc3MgdGhhbiAwXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA+PSBpdGVtcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcImluZGV4IGNhbm5vdCBiZSBncmVhdGVyIG9yIGVxdWFsIHRoYW4gdGhlIGxpc3QgbGVuZ3RoXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbmRleCA9PT0gdGFyZ2V0SW5kZXgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xuICAgICAgICB9XG4gICAgICAgIGxldCBiZWZvcmVQb3NpdGlvbiA9IG51bGw7XG4gICAgICAgIGxldCBhZnRlclBvc2l0aW9uID0gbnVsbDtcbiAgICAgICAgaWYgKGluZGV4IDwgdGFyZ2V0SW5kZXgpIHtcbiAgICAgICAgICAgIGFmdGVyUG9zaXRpb24gPVxuICAgICAgICAgICAgICAgIHRhcmdldEluZGV4ID09PSBpdGVtcy5sZW5ndGggLSAxXG4gICAgICAgICAgICAgICAgICAgID8gdW5kZWZpbmVkXG4gICAgICAgICAgICAgICAgICAgIDogaXRlbXNbdGFyZ2V0SW5kZXggKyAxXVswXTtcbiAgICAgICAgICAgIGJlZm9yZVBvc2l0aW9uID0gaXRlbXNbdGFyZ2V0SW5kZXhdWzBdO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgYWZ0ZXJQb3NpdGlvbiA9IGl0ZW1zW3RhcmdldEluZGV4XVswXTtcbiAgICAgICAgICAgIGJlZm9yZVBvc2l0aW9uID1cbiAgICAgICAgICAgICAgICB0YXJnZXRJbmRleCA9PT0gMCA/IHVuZGVmaW5lZCA6IGl0ZW1zW3RhcmdldEluZGV4IC0gMV1bMF07XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9zaXRpb24gPSBtYWtlUG9zaXRpb24oYmVmb3JlUG9zaXRpb24sIGFmdGVyUG9zaXRpb24pO1xuICAgICAgICBjb25zdCBbLCBpdGVtXSA9IGl0ZW1zW2luZGV4XTtcbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogT3BUeXBlLkxpc3RNb3ZlLFxuICAgICAgICAgICAgaWQ6IGxpc3QuaWQsXG4gICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uaWQsXG4gICAgICAgICAgICBwb3NpdGlvbixcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxuICAgIGRlbGV0ZUl0ZW0oaWQsIGluZGV4KSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldENoaWxkKGlkKTtcbiAgICAgICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaXN0IHdpdGggaWQgXCIke2lkfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3QuJCR0eXBlICE9PSBMSVNUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgaXMgbm90IGEgbGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zID0gc29ydGVkTGlzdEl0ZW1zKGdldExpc3RJdGVtcyh0aGlzLl9jYWNoZSwgaWQpKTtcbiAgICAgICAgY29uc3QgWywgaXRlbV0gPSBpdGVtc1tpbmRleF07XG4gICAgICAgIHJldHVybiB0aGlzLmRpc3BhdGNoKHtcbiAgICAgICAgICAgIHR5cGU6IE9wVHlwZS5MaXN0UmVtb3ZlLFxuICAgICAgICAgICAgaWQ6IGxpc3QuaWQsXG4gICAgICAgICAgICBpdGVtSWQ6IGl0ZW0uaWQsXG4gICAgICAgIH0sIHRydWUpO1xuICAgIH1cbiAgICBkZWxldGVJdGVtQnlJZChpZCwgaXRlbUlkKSB7XG4gICAgICAgIGNvbnN0IGxpc3QgPSB0aGlzLmdldENoaWxkKGlkKTtcbiAgICAgICAgaWYgKGxpc3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBMaXN0IHdpdGggaWQgXCIke2lkfVwiIGRvZXMgbm90IGV4aXN0YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3QuJCR0eXBlICE9PSBMSVNUKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYE5vZGUgd2l0aCBpZCBcIiR7aWR9XCIgaXMgbm90IGEgbGlzdGApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGl0ZW1zTWFwID0gZ2V0TGlzdEl0ZW1zKHRoaXMuX2NhY2hlLCBpZCk7XG4gICAgICAgIGxldCBpdGVtID0gbnVsbDtcbiAgICAgICAgZm9yIChjb25zdCBbLCBjcmR0XSBvZiBpdGVtc01hcCkge1xuICAgICAgICAgICAgaWYgKGNyZHQuaWQgPT09IGl0ZW1JZCkge1xuICAgICAgICAgICAgICAgIGl0ZW0gPSBjcmR0O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChpdGVtID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgTGlzdCB3aXRoIGlkIFwiJHtpZH1cIiBkb2VzIG5vdCBoYXZlIGFuIGl0ZW0gd2l0aCBpZCBcIiR7aXRlbUlkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZGlzcGF0Y2goe1xuICAgICAgICAgICAgdHlwZTogT3BUeXBlLkxpc3RSZW1vdmUsXG4gICAgICAgICAgICBpZDogbGlzdC5pZCxcbiAgICAgICAgICAgIGl0ZW1JZDogaXRlbS5pZCxcbiAgICAgICAgfSwgdHJ1ZSk7XG4gICAgfVxufVxuZnVuY3Rpb24gZ2V0QWxsTGlua3MoaWQsIHJvb3RJZCwgbGlua3MpIHtcbiAgICBsZXQgY3VycmVudElkID0gaWQ7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgZG8ge1xuICAgICAgICBjb25zdCBsaW5rID0gbGlua3MuZ2V0KGN1cnJlbnRJZCk7XG4gICAgICAgIGlmIChsaW5rID09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBsaW5rIGZvciBpZCBcIiR7Y3VycmVudElkfVwiYCk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudElkID0gbGluay5wYXJlbnRJZDtcbiAgICAgICAgcmVzdWx0LnB1c2gobGluayk7XG4gICAgfSB3aGlsZSAoY3VycmVudElkICE9PSByb290SWQpO1xuICAgIHJldHVybiByZXN1bHQ7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZUxpc3Qoc2VyaWFsaXplZCwgY2FjaGUpIHtcbiAgICBjb25zdCBsaXN0SXRlbXMgPSBuZXcgTWFwKCk7XG4gICAgZm9yIChjb25zdCBwb3NpdGlvbiBpbiBzZXJpYWxpemVkLmRhdGEpIHtcbiAgICAgICAgY29uc3QgaXRlbSA9IGRlc2VyaWFsaXplKHNlcmlhbGl6ZWQuZGF0YVtwb3NpdGlvbl0sIGNhY2hlKTtcbiAgICAgICAgaWYgKCFpc1JlY29yZChpdGVtKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICBsaXN0SXRlbXMuc2V0KHBvc2l0aW9uLCBpdGVtKTtcbiAgICAgICAgY2FjaGUubGlua3Muc2V0KGl0ZW0uaWQsIHsgcGFyZW50SWQ6IHNlcmlhbGl6ZWQuaWQsIHBhcmVudEtleTogcG9zaXRpb24gfSk7XG4gICAgfVxuICAgIGNhY2hlLmxpc3RDYWNoZS5zZXQoc2VyaWFsaXplZC5pZCwgbGlzdEl0ZW1zKTtcbiAgICByZXR1cm4gY3JlYXRlTGlzdChzZXJpYWxpemVkLmlkLCBsaXN0SXRlbXNUb0FycmF5KGxpc3RJdGVtcykpO1xufVxuZnVuY3Rpb24gZ2V0TGlzdEl0ZW1zKGNhY2hlLCBsaXN0SWQpIHtcbiAgICBjb25zdCBpdGVtcyA9IGNhY2hlLmxpc3RDYWNoZS5nZXQobGlzdElkKTtcbiAgICBpZiAoaXRlbXMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbid0IGZpbmQgbGlzdCBjYWNoZSBmb3IgaWQgXCIke2xpc3RJZH1cImApO1xuICAgIH1cbiAgICByZXR1cm4gaXRlbXM7XG59XG5mdW5jdGlvbiBkZXNlcmlhbGl6ZVJlY29yZChzZXJpYWxpemVkLCBjYWNoZSkge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgaWQ6IHNlcmlhbGl6ZWQuaWQsXG4gICAgICAgICQkdHlwZTogUkVDT1JELFxuICAgIH07XG4gICAgZm9yIChjb25zdCBrZXkgaW4gc2VyaWFsaXplZC5kYXRhKSB7XG4gICAgICAgIGNvbnN0IGl0ZW0gPSBkZXNlcmlhbGl6ZShzZXJpYWxpemVkLmRhdGFba2V5XSwgY2FjaGUpO1xuICAgICAgICBpZiAoaXNDcmR0KGl0ZW0pKSB7XG4gICAgICAgICAgICBjYWNoZS5saW5rcy5zZXQoaXRlbS5pZCwge1xuICAgICAgICAgICAgICAgIHBhcmVudElkOiBzZXJpYWxpemVkLmlkLFxuICAgICAgICAgICAgICAgIHBhcmVudEtleToga2V5LFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0W2tleV0gPSBpdGVtO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZnVuY3Rpb24gZGVzZXJpYWxpemUoc2VyaWFsaXplZCwgY2FjaGUpIHtcbiAgICBzd2l0Y2ggKHNlcmlhbGl6ZWQudHlwZSkge1xuICAgICAgICBjYXNlIENyZHRUeXBlLlJlZ2lzdGVyOiB7XG4gICAgICAgICAgICByZXR1cm4gc2VyaWFsaXplZC5kYXRhO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQ3JkdFR5cGUuUmVjb3JkOiB7XG4gICAgICAgICAgICByZXR1cm4gZGVzZXJpYWxpemVSZWNvcmQoc2VyaWFsaXplZCwgY2FjaGUpO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgQ3JkdFR5cGUuTGlzdDoge1xuICAgICAgICAgICAgcmV0dXJuIGRlc2VyaWFsaXplTGlzdChzZXJpYWxpemVkLCBjYWNoZSk7XG4gICAgICAgIH1cbiAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGRpc3BhdGNoT25SZWNvcmQocmVjb3JkLCBvcCwgY2FjaGUsIGxpbmtzKSB7XG4gICAgaWYgKGxpbmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAocmVjb3JkLmlkICE9PSBvcC5pZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVE9ET1wiKTtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9wLnR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgT3BUeXBlLlJlY29yZFVwZGF0ZToge1xuICAgICAgICAgICAgICAgIHJldHVybiB1cGRhdGVSZWNvcmQocmVjb3JkLCBvcCwgY2FjaGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybihcIlVuc3VwcG9ydGVkIG9wZXJhdGlvblwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gcmVjb3JkO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnRMaW5rID0gbGlua3MucG9wKCk7XG4gICAgY29uc3QgY2hpbGQgPSByZWNvcmRbY3VycmVudExpbmsucGFyZW50S2V5XTtcbiAgICBjb25zdCBuZXdOb2RlID0gZGlzcGF0Y2goY2hpbGQsIG9wLCBjYWNoZSwgbGlua3MpO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHJlY29yZCksIHsgW2N1cnJlbnRMaW5rLnBhcmVudEtleV06IG5ld05vZGUgfSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaE9uTGlzdChsaXN0LCBvcCwgY2FjaGUsIGxpbmtzKSB7XG4gICAgaWYgKGxpbmtzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpZiAobGlzdC5pZCAhPT0gb3AuaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChvcC50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIE9wVHlwZS5MaXN0SW5zZXJ0OiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RJbnNlcnQobGlzdCwgb3AsIGNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgT3BUeXBlLkxpc3RNb3ZlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RNb3ZlKGxpc3QsIG9wLCBjYWNoZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIE9wVHlwZS5MaXN0UmVtb3ZlOiB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3REZWxldGUobGlzdCwgb3AsIGNhY2hlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oXCJVbnN1cHBvcnRlZCBvcGVyYXRpb25cIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3Q7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgY3VycmVudExpbmsgPSBsaW5rcy5wb3AoKTtcbiAgICBjb25zdCBwb3NpdGlvbiA9IGN1cnJlbnRMaW5rLnBhcmVudEtleTtcbiAgICBjb25zdCBpdGVtcyA9IGdldExpc3RJdGVtcyhjYWNoZSwgbGlzdC5pZCk7XG4gICAgY29uc3QgaXRlbSA9IGl0ZW1zLmdldChwb3NpdGlvbik7XG4gICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUT0RPXCIpO1xuICAgIH1cbiAgICBjb25zdCBuZXdJdGVtID0gZGlzcGF0Y2goaXRlbSwgb3AsIGNhY2hlLCBsaW5rcyk7XG4gICAgaXRlbXMuc2V0KHBvc2l0aW9uLCBuZXdJdGVtKTtcbiAgICByZXR1cm4gY3JlYXRlTGlzdChsaXN0LmlkLCBsaXN0SXRlbXNUb0FycmF5KGl0ZW1zKSk7XG59XG5mdW5jdGlvbiBkaXNwYXRjaChub2RlLCBvcCwgY2FjaGUsIGxpbmtzKSB7XG4gICAgc3dpdGNoIChub2RlLiQkdHlwZSkge1xuICAgICAgICBjYXNlIFJFQ09SRDpcbiAgICAgICAgICAgIHJldHVybiBkaXNwYXRjaE9uUmVjb3JkKG5vZGUsIG9wLCBjYWNoZSwgbGlua3MpO1xuICAgICAgICBjYXNlIExJU1Q6XG4gICAgICAgICAgICByZXR1cm4gZGlzcGF0Y2hPbkxpc3Qobm9kZSwgb3AsIGNhY2hlLCBsaW5rcyk7XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gQ1JEVFwiKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIHVwZGF0ZVJlY29yZChub2RlLCBvcCwgY2FjaGUpIHtcbiAgICBjb25zdCByZXN1bHQgPSBPYmplY3QuYXNzaWduKHt9LCBub2RlKTtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvcC5kYXRhKSB7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gb3AuZGF0YVtrZXldO1xuICAgICAgICBjb25zdCBpdGVtID0gZGVzZXJpYWxpemUodmFsdWUsIGNhY2hlKTtcbiAgICAgICAgaWYgKGlzQ3JkdChpdGVtKSkge1xuICAgICAgICAgICAgY2FjaGUubGlua3Muc2V0KGl0ZW0uaWQsIHsgcGFyZW50SWQ6IG5vZGUuaWQsIHBhcmVudEtleToga2V5IH0pO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdFtrZXldID0gaXRlbTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIGxpc3RJbnNlcnQobGlzdCwgb3AsIGNhY2hlKSB7XG4gICAgY29uc3QgaXRlbXMgPSBnZXRMaXN0SXRlbXMoY2FjaGUsIGxpc3QuaWQpO1xuICAgIGNvbnN0IGl0ZW0gPSBkZXNlcmlhbGl6ZShvcC5kYXRhLCBjYWNoZSk7XG4gICAgaWYgKGlzQ3JkdChpdGVtKSkge1xuICAgICAgICBpdGVtcy5zZXQob3AucG9zaXRpb24sIGl0ZW0pO1xuICAgICAgICBjYWNoZS5saW5rcy5zZXQoaXRlbS5pZCwgeyBwYXJlbnRJZDogbGlzdC5pZCwgcGFyZW50S2V5OiBvcC5wb3NpdGlvbiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNyZWF0ZUxpc3QobGlzdC5pZCwgbGlzdEl0ZW1zVG9BcnJheShpdGVtcykpO1xufVxuZnVuY3Rpb24gbGlzdE1vdmUobGlzdCwgb3AsIGNhY2hlKSB7XG4gICAgY29uc3QgaXRlbXMgPSBnZXRMaXN0SXRlbXMoY2FjaGUsIGxpc3QuaWQpO1xuICAgIGNvbnN0IGxpbmsgPSBnZXRMaW5rT3JUaHJvdyhjYWNoZSwgb3AuaXRlbUlkKTtcbiAgICBjb25zdCBpdGVtID0gaXRlbXMuZ2V0KGxpbmsucGFyZW50S2V5KTtcbiAgICBpZiAoaXRlbSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgfVxuICAgIC8vIERlbGV0ZSBvbGQgcG9zaXRpb24gY2FjaGUgZW50cnlcbiAgICBpdGVtcy5kZWxldGUobGluay5wYXJlbnRLZXkpO1xuICAgIC8vIEluc2VydCBuZXcgcG9zaXRpb24gaW4gY2FjaGVcbiAgICBpdGVtcy5zZXQob3AucG9zaXRpb24sIGl0ZW0pO1xuICAgIC8vIFVwZGF0ZSBsaW5rXG4gICAgY2FjaGUubGlua3Muc2V0KG9wLml0ZW1JZCwgeyBwYXJlbnRJZDogbGlzdC5pZCwgcGFyZW50S2V5OiBvcC5wb3NpdGlvbiB9KTtcbiAgICByZXR1cm4gY3JlYXRlTGlzdChsaXN0LmlkLCBsaXN0SXRlbXNUb0FycmF5KGl0ZW1zKSk7XG59XG5mdW5jdGlvbiBnZXRMaW5rT3JUaHJvdyhjYWNoZSwgaWQpIHtcbiAgICBjb25zdCBsaW5rID0gY2FjaGUubGlua3MuZ2V0KGlkKTtcbiAgICBpZiAobGluayA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2FuJ3QgZmluZCBsaW5rIHdpdGggaWQgXCIke2lkfVwiYCk7XG4gICAgfVxuICAgIHJldHVybiBsaW5rO1xufVxuZnVuY3Rpb24gbGlzdERlbGV0ZShsaXN0LCBvcCwgY2FjaGUpIHtcbiAgICBjb25zdCBpdGVtcyA9IGdldExpc3RJdGVtcyhjYWNoZSwgbGlzdC5pZCk7XG4gICAgY29uc3QgbGluayA9IGdldExpbmtPclRocm93KGNhY2hlLCBvcC5pdGVtSWQpO1xuICAgIGl0ZW1zLmRlbGV0ZShsaW5rLnBhcmVudEtleSk7XG4gICAgY2FjaGUubGlua3MuZGVsZXRlKG9wLml0ZW1JZCk7XG4gICAgcmV0dXJuIGNyZWF0ZUxpc3QobGlzdC5pZCwgbGlzdEl0ZW1zVG9BcnJheShpdGVtcykpO1xufVxuZnVuY3Rpb24gbGlzdEl0ZW1zVG9BcnJheShpdGVtcykge1xuICAgIHJldHVybiBzb3J0ZWRMaXN0SXRlbXMoaXRlbXMpLm1hcCgoZW50cnkpID0+IGVudHJ5WzFdKTtcbn1cbmZ1bmN0aW9uIHNvcnRlZExpc3RJdGVtcyhpdGVtcykge1xuICAgIHJldHVybiBBcnJheS5mcm9tKGl0ZW1zLmVudHJpZXMoKSkuc29ydCgoZW50cnlBLCBlbnRyeUIpID0+IGNvbXBhcmUoeyBwb3NpdGlvbjogZW50cnlBWzBdIH0sIHsgcG9zaXRpb246IGVudHJ5QlswXSB9KSk7XG59XG5mdW5jdGlvbiBnZXRDaGlsZERlZXAobm9kZSwgaWQsIGxpbmtzLCBjYWNoZSkge1xuICAgIGxldCBjdXJyZW50Tm9kZSA9IG5vZGU7XG4gICAgd2hpbGUgKGN1cnJlbnROb2RlLmlkICE9PSBpZCkge1xuICAgICAgICBjb25zdCBsaW5rID0gbGlua3MucG9wKCk7XG4gICAgICAgIGlmIChsaW5rID09IG51bGwgfHwgbGluay5wYXJlbnRJZCAhPT0gY3VycmVudE5vZGUuaWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnROb2RlLiQkdHlwZSA9PT0gUkVDT1JEKSB7XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGN1cnJlbnROb2RlW2xpbmsucGFyZW50S2V5XTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IGxpc3RJdGVtcyA9IGdldExpc3RJdGVtcyhjYWNoZSwgY3VycmVudE5vZGUuaWQpO1xuICAgICAgICAgICAgY29uc3QgaXRlbSA9IGxpc3RJdGVtcy5nZXQobGluay5wYXJlbnRLZXkpO1xuICAgICAgICAgICAgaWYgKGl0ZW0gPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIlRPRE9cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjdXJyZW50Tm9kZSA9IGl0ZW07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGN1cnJlbnROb2RlO1xufVxuZnVuY3Rpb24gaXNSZWNvcmQodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuJCR0eXBlID09PSBSRUNPUkQ7XG59XG5mdW5jdGlvbiBpc0xpc3QodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUuJCR0eXBlID09PSBMSVNUO1xufVxuZnVuY3Rpb24gaXNDcmR0KHZhbHVlKSB7XG4gICAgcmV0dXJuIGlzUmVjb3JkKHZhbHVlKSB8fCBpc0xpc3QodmFsdWUpO1xufVxuZnVuY3Rpb24gc2VyaWFsaXplUmVjb3JkKHJlY29yZCkge1xuICAgIGNvbnN0IHNlcmlhbGl6ZWREYXRhID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgaW4gcmVjb3JkKSB7XG4gICAgICAgIGlmIChrZXkgIT09IFwiaWRcIiAmJiBrZXkgIT09IFwiJCR0eXBlXCIpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gcmVjb3JkW2tleV07IC8vIFRPRE86IEZpbmQgb3V0IHdoeSB0eXBlc2NyaXB0IGRvZXMgbm90IGxpa2UgdGhhdFxuICAgICAgICAgICAgc2VyaWFsaXplZERhdGFba2V5XSA9IHNlcmlhbGl6ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IHJlY29yZC5pZCxcbiAgICAgICAgdHlwZTogQ3JkdFR5cGUuUmVjb3JkLFxuICAgICAgICBkYXRhOiBzZXJpYWxpemVkRGF0YSxcbiAgICB9O1xufVxuZnVuY3Rpb24gc2VyaWFsaXplTGlzdChsaXN0KSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgaWQ6IGxpc3QuaWQsXG4gICAgICAgIHR5cGU6IENyZHRUeXBlLkxpc3QsXG4gICAgICAgIGRhdGE6IHt9LFxuICAgIH07XG59XG5mdW5jdGlvbiBzZXJpYWxpemUodmFsdWUpIHtcbiAgICBpZiAoaXNSZWNvcmQodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVSZWNvcmQodmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChpc0xpc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiBzZXJpYWxpemVMaXN0KHZhbHVlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiB7IHR5cGU6IENyZHRUeXBlLlJlZ2lzdGVyLCBkYXRhOiB2YWx1ZSB9O1xuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/doc.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/index.js":
/*!**********************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/index.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"createClient\": function() { return /* reexport safe */ _client__WEBPACK_IMPORTED_MODULE_0__.createClient; },\n/* harmony export */   \"LiveStorageState\": function() { return /* reexport safe */ _types__WEBPACK_IMPORTED_MODULE_1__.LiveStorageState; }\n/* harmony export */ });\n/* harmony import */ var _client__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./client */ \"./node_modules/@liveblocks/client/lib/esm/client.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./node_modules/@liveblocks/client/lib/esm/types.js\");\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF3QztBQUNHIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jbGllbnQvbGliL2VzbS9pbmRleC5qcz9iOGRiIl0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCIuL2NsaWVudFwiO1xuZXhwb3J0IHsgTGl2ZVN0b3JhZ2VTdGF0ZSB9IGZyb20gXCIuL3R5cGVzXCI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/index.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/live.js":
/*!*********************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/live.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"ServerMessageType\": function() { return /* binding */ ServerMessageType; },\n/* harmony export */   \"ClientMessageType\": function() { return /* binding */ ClientMessageType; },\n/* harmony export */   \"CrdtType\": function() { return /* binding */ CrdtType; },\n/* harmony export */   \"OpType\": function() { return /* binding */ OpType; },\n/* harmony export */   \"WebsocketCloseCodes\": function() { return /* binding */ WebsocketCloseCodes; }\n/* harmony export */ });\nvar ServerMessageType;\n(function (ServerMessageType) {\n    ServerMessageType[ServerMessageType[\"UpdatePresence\"] = 100] = \"UpdatePresence\";\n    ServerMessageType[ServerMessageType[\"UserJoined\"] = 101] = \"UserJoined\";\n    ServerMessageType[ServerMessageType[\"UserLeft\"] = 102] = \"UserLeft\";\n    ServerMessageType[ServerMessageType[\"Event\"] = 103] = \"Event\";\n    ServerMessageType[ServerMessageType[\"RoomState\"] = 104] = \"RoomState\";\n    ServerMessageType[ServerMessageType[\"InitialStorageState\"] = 200] = \"InitialStorageState\";\n    ServerMessageType[ServerMessageType[\"UpdateStorage\"] = 201] = \"UpdateStorage\";\n})(ServerMessageType || (ServerMessageType = {}));\nvar ClientMessageType;\n(function (ClientMessageType) {\n    ClientMessageType[ClientMessageType[\"UpdatePresence\"] = 100] = \"UpdatePresence\";\n    ClientMessageType[ClientMessageType[\"ClientEvent\"] = 103] = \"ClientEvent\";\n    ClientMessageType[ClientMessageType[\"FetchStorage\"] = 200] = \"FetchStorage\";\n    ClientMessageType[ClientMessageType[\"UpdateStorage\"] = 201] = \"UpdateStorage\";\n})(ClientMessageType || (ClientMessageType = {}));\nvar CrdtType;\n(function (CrdtType) {\n    CrdtType[CrdtType[\"Record\"] = 0] = \"Record\";\n    CrdtType[CrdtType[\"List\"] = 1] = \"List\";\n    CrdtType[CrdtType[\"Register\"] = 2] = \"Register\";\n})(CrdtType || (CrdtType = {}));\nvar OpType;\n(function (OpType) {\n    OpType[OpType[\"Init\"] = 100] = \"Init\";\n    OpType[OpType[\"ListInsert\"] = 200] = \"ListInsert\";\n    OpType[OpType[\"ListMove\"] = 201] = \"ListMove\";\n    OpType[OpType[\"ListRemove\"] = 202] = \"ListRemove\";\n    OpType[OpType[\"RecordUpdate\"] = 300] = \"RecordUpdate\";\n})(OpType || (OpType = {}));\nvar WebsocketCloseCodes;\n(function (WebsocketCloseCodes) {\n    WebsocketCloseCodes[WebsocketCloseCodes[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"INVALID_MESSAGE_FORMAT\"] = 4000] = \"INVALID_MESSAGE_FORMAT\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n})(WebsocketCloseCodes || (WebsocketCloseCodes = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vbGl2ZS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsOENBQThDO0FBQ3hDO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRCQUE0QjtBQUN0QjtBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsd0JBQXdCO0FBQ2xCO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsa0RBQWtEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AbGl2ZWJsb2Nrcy9jbGllbnQvbGliL2VzbS9saXZlLmpzPzRhZGUiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IHZhciBTZXJ2ZXJNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoU2VydmVyTWVzc2FnZVR5cGUpIHtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtTZXJ2ZXJNZXNzYWdlVHlwZVtcIlVwZGF0ZVByZXNlbmNlXCJdID0gMTAwXSA9IFwiVXBkYXRlUHJlc2VuY2VcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtTZXJ2ZXJNZXNzYWdlVHlwZVtcIlVzZXJKb2luZWRcIl0gPSAxMDFdID0gXCJVc2VySm9pbmVkXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJVc2VyTGVmdFwiXSA9IDEwMl0gPSBcIlVzZXJMZWZ0XCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJFdmVudFwiXSA9IDEwM10gPSBcIkV2ZW50XCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJSb29tU3RhdGVcIl0gPSAxMDRdID0gXCJSb29tU3RhdGVcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtTZXJ2ZXJNZXNzYWdlVHlwZVtcIkluaXRpYWxTdG9yYWdlU3RhdGVcIl0gPSAyMDBdID0gXCJJbml0aWFsU3RvcmFnZVN0YXRlXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJVcGRhdGVTdG9yYWdlXCJdID0gMjAxXSA9IFwiVXBkYXRlU3RvcmFnZVwiO1xufSkoU2VydmVyTWVzc2FnZVR5cGUgfHwgKFNlcnZlck1lc3NhZ2VUeXBlID0ge30pKTtcbmV4cG9ydCB2YXIgQ2xpZW50TWVzc2FnZVR5cGU7XG4oZnVuY3Rpb24gKENsaWVudE1lc3NhZ2VUeXBlKSB7XG4gICAgQ2xpZW50TWVzc2FnZVR5cGVbQ2xpZW50TWVzc2FnZVR5cGVbXCJVcGRhdGVQcmVzZW5jZVwiXSA9IDEwMF0gPSBcIlVwZGF0ZVByZXNlbmNlXCI7XG4gICAgQ2xpZW50TWVzc2FnZVR5cGVbQ2xpZW50TWVzc2FnZVR5cGVbXCJDbGllbnRFdmVudFwiXSA9IDEwM10gPSBcIkNsaWVudEV2ZW50XCI7XG4gICAgQ2xpZW50TWVzc2FnZVR5cGVbQ2xpZW50TWVzc2FnZVR5cGVbXCJGZXRjaFN0b3JhZ2VcIl0gPSAyMDBdID0gXCJGZXRjaFN0b3JhZ2VcIjtcbiAgICBDbGllbnRNZXNzYWdlVHlwZVtDbGllbnRNZXNzYWdlVHlwZVtcIlVwZGF0ZVN0b3JhZ2VcIl0gPSAyMDFdID0gXCJVcGRhdGVTdG9yYWdlXCI7XG59KShDbGllbnRNZXNzYWdlVHlwZSB8fCAoQ2xpZW50TWVzc2FnZVR5cGUgPSB7fSkpO1xuZXhwb3J0IHZhciBDcmR0VHlwZTtcbihmdW5jdGlvbiAoQ3JkdFR5cGUpIHtcbiAgICBDcmR0VHlwZVtDcmR0VHlwZVtcIlJlY29yZFwiXSA9IDBdID0gXCJSZWNvcmRcIjtcbiAgICBDcmR0VHlwZVtDcmR0VHlwZVtcIkxpc3RcIl0gPSAxXSA9IFwiTGlzdFwiO1xuICAgIENyZHRUeXBlW0NyZHRUeXBlW1wiUmVnaXN0ZXJcIl0gPSAyXSA9IFwiUmVnaXN0ZXJcIjtcbn0pKENyZHRUeXBlIHx8IChDcmR0VHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIE9wVHlwZTtcbihmdW5jdGlvbiAoT3BUeXBlKSB7XG4gICAgT3BUeXBlW09wVHlwZVtcIkluaXRcIl0gPSAxMDBdID0gXCJJbml0XCI7XG4gICAgT3BUeXBlW09wVHlwZVtcIkxpc3RJbnNlcnRcIl0gPSAyMDBdID0gXCJMaXN0SW5zZXJ0XCI7XG4gICAgT3BUeXBlW09wVHlwZVtcIkxpc3RNb3ZlXCJdID0gMjAxXSA9IFwiTGlzdE1vdmVcIjtcbiAgICBPcFR5cGVbT3BUeXBlW1wiTGlzdFJlbW92ZVwiXSA9IDIwMl0gPSBcIkxpc3RSZW1vdmVcIjtcbiAgICBPcFR5cGVbT3BUeXBlW1wiUmVjb3JkVXBkYXRlXCJdID0gMzAwXSA9IFwiUmVjb3JkVXBkYXRlXCI7XG59KShPcFR5cGUgfHwgKE9wVHlwZSA9IHt9KSk7XG5leHBvcnQgdmFyIFdlYnNvY2tldENsb3NlQ29kZXM7XG4oZnVuY3Rpb24gKFdlYnNvY2tldENsb3NlQ29kZXMpIHtcbiAgICBXZWJzb2NrZXRDbG9zZUNvZGVzW1dlYnNvY2tldENsb3NlQ29kZXNbXCJDTE9TRV9BQk5PUk1BTFwiXSA9IDEwMDZdID0gXCJDTE9TRV9BQk5PUk1BTFwiO1xuICAgIFdlYnNvY2tldENsb3NlQ29kZXNbV2Vic29ja2V0Q2xvc2VDb2Rlc1tcIklOVkFMSURfTUVTU0FHRV9GT1JNQVRcIl0gPSA0MDAwXSA9IFwiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiO1xuICAgIFdlYnNvY2tldENsb3NlQ29kZXNbV2Vic29ja2V0Q2xvc2VDb2Rlc1tcIk5PVF9BTExPV0VEXCJdID0gNDAwMV0gPSBcIk5PVF9BTExPV0VEXCI7XG4gICAgV2Vic29ja2V0Q2xvc2VDb2Rlc1tXZWJzb2NrZXRDbG9zZUNvZGVzW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfU0VDT05EU1wiXSA9IDQwMDJdID0gXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCI7XG4gICAgV2Vic29ja2V0Q2xvc2VDb2Rlc1tXZWJzb2NrZXRDbG9zZUNvZGVzW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCJdID0gNDAwM10gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU1wiO1xuICAgIFdlYnNvY2tldENsb3NlQ29kZXNbV2Vic29ja2V0Q2xvc2VDb2Rlc1tcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCJdID0gNDAwNF0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX0RBWV9QRVJfQVBQXCI7XG4gICAgV2Vic29ja2V0Q2xvc2VDb2Rlc1tXZWJzb2NrZXRDbG9zZUNvZGVzW1wiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCJdID0gNDAwNV0gPSBcIk1BWF9OVU1CRVJfT0ZfQ09OQ1VSUkVOVF9DT05ORUNUSU9OU19QRVJfUk9PTVwiO1xufSkoV2Vic29ja2V0Q2xvc2VDb2RlcyB8fCAoV2Vic29ja2V0Q2xvc2VDb2RlcyA9IHt9KSk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/live.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/position.js":
/*!*************************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/position.js ***!
  \*************************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"min\": function() { return /* binding */ min; },\n/* harmony export */   \"max\": function() { return /* binding */ max; },\n/* harmony export */   \"mid\": function() { return /* binding */ mid; },\n/* harmony export */   \"middle\": function() { return /* binding */ middle; },\n/* harmony export */   \"makePosition\": function() { return /* binding */ makePosition; },\n/* harmony export */   \"posCodes\": function() { return /* binding */ posCodes; },\n/* harmony export */   \"pos\": function() { return /* binding */ pos; },\n/* harmony export */   \"compare\": function() { return /* binding */ compare; }\n/* harmony export */ });\nconst min = 32;\nconst max = 127;\nconst mid = 79;\nfunction middle(a, b) {\n    return (a + b) / 2;\n}\nfunction makePosition(before, after) {\n    // No children\n    if (before == null && after == null) {\n        return pos([min + 1]);\n    }\n    // Insert at the end\n    if (before != null && after == null) {\n        return getNextPosition(before);\n    }\n    // Insert at the start\n    if (before == null && after != null) {\n        return getPreviousPosition(after);\n    }\n    return pos(makePositionFromCodes(posCodes(before), posCodes(after)));\n}\nfunction getPreviousPosition(after) {\n    const result = [];\n    const afterCodes = posCodes(after);\n    for (let i = 0; i < afterCodes.length; i++) {\n        const code = afterCodes[i];\n        if (code <= min + 1) {\n            result.push(min);\n            if (afterCodes.length - 1 === i) {\n                result.push(max - 1);\n                break;\n            }\n        }\n        else {\n            result.push(code - 1);\n            break;\n        }\n    }\n    return pos(result);\n}\nfunction getNextPosition(before) {\n    const result = [];\n    const beforeCodes = posCodes(before);\n    for (let i = 0; i < beforeCodes.length; i++) {\n        const code = beforeCodes[i];\n        if (code === max - 1) {\n            result.push(code);\n            if (beforeCodes.length - 1 === i) {\n                result.push(min + 1);\n                break;\n            }\n        }\n        else {\n            result.push(code + 1);\n            break;\n        }\n    }\n    return pos(result);\n}\nfunction makePositionFromCodes(before, after) {\n    let index = 0;\n    const result = [];\n    while (true) {\n        const beforeDigit = before[index] || min;\n        const afterDigit = after[index] || max;\n        if (beforeDigit > afterDigit) {\n            throw new Error(`Impossible to generate position between ${before} and ${after}`);\n        }\n        if (beforeDigit === afterDigit) {\n            result.push(beforeDigit);\n            index++;\n            continue;\n        }\n        if (afterDigit - beforeDigit === 1) {\n            result.push(beforeDigit);\n            result.push(...makePositionFromCodes(before.slice(index + 1), []));\n            break;\n        }\n        const mid = beforeDigit + Math.floor((afterDigit - beforeDigit) / 2);\n        result.push(mid);\n        break;\n    }\n    return result;\n}\nfunction posCodes(str) {\n    const codes = [];\n    for (let i = 0; i < str.length; i++) {\n        codes.push(str.charCodeAt(i));\n    }\n    return codes;\n}\nfunction pos(codes) {\n    return String.fromCharCode(...codes);\n}\nfunction compare(itemA, itemB) {\n    const aCodes = posCodes(itemA.position);\n    const bCodes = posCodes(itemB.position);\n    const maxLength = Math.max(aCodes.length, bCodes.length);\n    for (let i = 0; i < maxLength; i++) {\n        const a = aCodes[i] == null ? min : aCodes[i];\n        const b = bCodes[i] == null ? min : bCodes[i];\n        if (a === b) {\n            continue;\n        }\n        else {\n            return a - b;\n        }\n    }\n    throw new Error(`Impossible to compare similar position \"${itemA.position}\" and \"${itemB.position}\"`);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vcG9zaXRpb24uanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBTztBQUNBO0FBQ0E7QUFDQTtBQUNQO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsdUJBQXVCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQix3QkFBd0I7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1RUFBdUUsUUFBUSxNQUFNLE1BQU07QUFDM0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQSxvQkFBb0IsZ0JBQWdCO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ087QUFDUDtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsZUFBZTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0QsZUFBZSxTQUFTLGVBQWU7QUFDdEciLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NsaWVudC9saWIvZXNtL3Bvc2l0aW9uLmpzPzBhNjYiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNvbnN0IG1pbiA9IDMyO1xuZXhwb3J0IGNvbnN0IG1heCA9IDEyNztcbmV4cG9ydCBjb25zdCBtaWQgPSA3OTtcbmV4cG9ydCBmdW5jdGlvbiBtaWRkbGUoYSwgYikge1xuICAgIHJldHVybiAoYSArIGIpIC8gMjtcbn1cbmV4cG9ydCBmdW5jdGlvbiBtYWtlUG9zaXRpb24oYmVmb3JlLCBhZnRlcikge1xuICAgIC8vIE5vIGNoaWxkcmVuXG4gICAgaWYgKGJlZm9yZSA9PSBudWxsICYmIGFmdGVyID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHBvcyhbbWluICsgMV0pO1xuICAgIH1cbiAgICAvLyBJbnNlcnQgYXQgdGhlIGVuZFxuICAgIGlmIChiZWZvcmUgIT0gbnVsbCAmJiBhZnRlciA9PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXROZXh0UG9zaXRpb24oYmVmb3JlKTtcbiAgICB9XG4gICAgLy8gSW5zZXJ0IGF0IHRoZSBzdGFydFxuICAgIGlmIChiZWZvcmUgPT0gbnVsbCAmJiBhZnRlciAhPSBudWxsKSB7XG4gICAgICAgIHJldHVybiBnZXRQcmV2aW91c1Bvc2l0aW9uKGFmdGVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvcyhtYWtlUG9zaXRpb25Gcm9tQ29kZXMocG9zQ29kZXMoYmVmb3JlKSwgcG9zQ29kZXMoYWZ0ZXIpKSk7XG59XG5mdW5jdGlvbiBnZXRQcmV2aW91c1Bvc2l0aW9uKGFmdGVyKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYWZ0ZXJDb2RlcyA9IHBvc0NvZGVzKGFmdGVyKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IGFmdGVyQ29kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGFmdGVyQ29kZXNbaV07XG4gICAgICAgIGlmIChjb2RlIDw9IG1pbiArIDEpIHtcbiAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pbik7XG4gICAgICAgICAgICBpZiAoYWZ0ZXJDb2Rlcy5sZW5ndGggLSAxID09PSBpKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0LnB1c2gobWF4IC0gMSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChjb2RlIC0gMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcG9zKHJlc3VsdCk7XG59XG5mdW5jdGlvbiBnZXROZXh0UG9zaXRpb24oYmVmb3JlKSB7XG4gICAgY29uc3QgcmVzdWx0ID0gW107XG4gICAgY29uc3QgYmVmb3JlQ29kZXMgPSBwb3NDb2RlcyhiZWZvcmUpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYmVmb3JlQ29kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgY29kZSA9IGJlZm9yZUNvZGVzW2ldO1xuICAgICAgICBpZiAoY29kZSA9PT0gbWF4IC0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZSk7XG4gICAgICAgICAgICBpZiAoYmVmb3JlQ29kZXMubGVuZ3RoIC0gMSA9PT0gaSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKG1pbiArIDEpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goY29kZSArIDEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBvcyhyZXN1bHQpO1xufVxuZnVuY3Rpb24gbWFrZVBvc2l0aW9uRnJvbUNvZGVzKGJlZm9yZSwgYWZ0ZXIpIHtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIGNvbnN0IHJlc3VsdCA9IFtdO1xuICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IGJlZm9yZURpZ2l0ID0gYmVmb3JlW2luZGV4XSB8fCBtaW47XG4gICAgICAgIGNvbnN0IGFmdGVyRGlnaXQgPSBhZnRlcltpbmRleF0gfHwgbWF4O1xuICAgICAgICBpZiAoYmVmb3JlRGlnaXQgPiBhZnRlckRpZ2l0KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9zc2libGUgdG8gZ2VuZXJhdGUgcG9zaXRpb24gYmV0d2VlbiAke2JlZm9yZX0gYW5kICR7YWZ0ZXJ9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJlZm9yZURpZ2l0ID09PSBhZnRlckRpZ2l0KSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChiZWZvcmVEaWdpdCk7XG4gICAgICAgICAgICBpbmRleCsrO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFmdGVyRGlnaXQgLSBiZWZvcmVEaWdpdCA9PT0gMSkge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYmVmb3JlRGlnaXQpO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goLi4ubWFrZVBvc2l0aW9uRnJvbUNvZGVzKGJlZm9yZS5zbGljZShpbmRleCArIDEpLCBbXSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWlkID0gYmVmb3JlRGlnaXQgKyBNYXRoLmZsb29yKChhZnRlckRpZ2l0IC0gYmVmb3JlRGlnaXQpIC8gMik7XG4gICAgICAgIHJlc3VsdC5wdXNoKG1pZCk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0IGZ1bmN0aW9uIHBvc0NvZGVzKHN0cikge1xuICAgIGNvbnN0IGNvZGVzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzdHIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29kZXMucHVzaChzdHIuY2hhckNvZGVBdChpKSk7XG4gICAgfVxuICAgIHJldHVybiBjb2Rlcztcbn1cbmV4cG9ydCBmdW5jdGlvbiBwb3MoY29kZXMpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZSguLi5jb2Rlcyk7XG59XG5leHBvcnQgZnVuY3Rpb24gY29tcGFyZShpdGVtQSwgaXRlbUIpIHtcbiAgICBjb25zdCBhQ29kZXMgPSBwb3NDb2RlcyhpdGVtQS5wb3NpdGlvbik7XG4gICAgY29uc3QgYkNvZGVzID0gcG9zQ29kZXMoaXRlbUIucG9zaXRpb24pO1xuICAgIGNvbnN0IG1heExlbmd0aCA9IE1hdGgubWF4KGFDb2Rlcy5sZW5ndGgsIGJDb2Rlcy5sZW5ndGgpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbWF4TGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY29uc3QgYSA9IGFDb2Rlc1tpXSA9PSBudWxsID8gbWluIDogYUNvZGVzW2ldO1xuICAgICAgICBjb25zdCBiID0gYkNvZGVzW2ldID09IG51bGwgPyBtaW4gOiBiQ29kZXNbaV07XG4gICAgICAgIGlmIChhID09PSBiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBhIC0gYjtcbiAgICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBuZXcgRXJyb3IoYEltcG9zc2libGUgdG8gY29tcGFyZSBzaW1pbGFyIHBvc2l0aW9uIFwiJHtpdGVtQS5wb3NpdGlvbn1cIiBhbmQgXCIke2l0ZW1CLnBvc2l0aW9ufVwiYCk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/position.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/room.js":
/*!*********************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/room.js ***!
  \*********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"makeStateMachine\": function() { return /* binding */ makeStateMachine; },\n/* harmony export */   \"defaultState\": function() { return /* binding */ defaultState; },\n/* harmony export */   \"createRoom\": function() { return /* binding */ createRoom; }\n/* harmony export */ });\n/* harmony import */ var _doc__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./doc */ \"./node_modules/@liveblocks/client/lib/esm/doc.js\");\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./types */ \"./node_modules/@liveblocks/client/lib/esm/types.js\");\n/* harmony import */ var _utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils */ \"./node_modules/@liveblocks/client/lib/esm/utils.js\");\n/* harmony import */ var _authentication__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./authentication */ \"./node_modules/@liveblocks/client/lib/esm/authentication.js\");\n/* harmony import */ var _live__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./live */ \"./node_modules/@liveblocks/client/lib/esm/live.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\n\n\n\n\nconst BACKOFF_RETRY_DELAYS = [250, 500, 1000, 2000, 4000, 8000, 10000];\nconst HEARTBEAT_INTERVAL = 30000;\n// const WAKE_UP_CHECK_INTERVAL = 2000;\nconst PONG_TIMEOUT = 2000;\nfunction isValidRoomEventType(value) {\n    return (value === \"storage\" ||\n        value === \"my-presence\" ||\n        value === \"others\" ||\n        value === \"event\" ||\n        value === \"error\" ||\n        value === \"connection\");\n}\nfunction makeIdFactory(connectionId) {\n    let count = 0;\n    return () => `${connectionId}:${count++}`;\n}\nfunction makeOthers(presenceMap) {\n    const array = Object.values(presenceMap);\n    return {\n        get count() {\n            return array.length;\n        },\n        map(callback) {\n            return array.map(callback);\n        },\n        toArray() {\n            return array;\n        },\n    };\n}\nfunction log(...params) {\n    return;\n    console.log(...params, new Date().toString());\n}\nfunction makeStateMachine(state, context, mockedEffects) {\n    const effects = mockedEffects || {\n        authenticate() {\n            return __awaiter(this, void 0, void 0, function* () {\n                try {\n                    const token = yield (0,_authentication__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(context.authEndpoint, context.room);\n                    const parsedToken = (0,_authentication__WEBPACK_IMPORTED_MODULE_3__.parseToken)(token);\n                    const socket = new WebSocket(`${context.liveblocksServer}/?token=${token}`);\n                    socket.addEventListener(\"message\", onMessage);\n                    socket.addEventListener(\"open\", onOpen);\n                    socket.addEventListener(\"close\", onClose);\n                    socket.addEventListener(\"error\", onError);\n                    authenticationSuccess(parsedToken, socket);\n                }\n                catch (er) {\n                    authenticationFailure(er);\n                }\n            });\n        },\n        send(messageOrMessages) {\n            if (state.socket == null) {\n                throw new Error(\"Can't send message if socket is null\");\n            }\n            state.socket.send(JSON.stringify(messageOrMessages));\n        },\n        delayFlush(delay) {\n            return setTimeout(tryFlushing, delay);\n        },\n        startHeartbeatInterval() {\n            return setInterval(heartbeat, HEARTBEAT_INTERVAL);\n        },\n        schedulePongTimeout() {\n            return setTimeout(pongTimeout, PONG_TIMEOUT);\n        },\n        scheduleReconnect(delay) {\n            return setTimeout(connect, delay);\n        },\n    };\n    function subscribe(type, listener) {\n        if (!isValidRoomEventType(type)) {\n            throw new Error(`\"${type}\" is not a valid event name`);\n        }\n        state.listeners[type].push(listener);\n    }\n    function unsubscribe(event, callback) {\n        if (!isValidRoomEventType(event)) {\n            throw new Error(`\"${event}\" is not a valid event name`);\n        }\n        const callbacks = state.listeners[event];\n        (0,_utils__WEBPACK_IMPORTED_MODULE_2__.remove)(callbacks, callback);\n    }\n    function getConnectionState() {\n        return state.connection.state;\n    }\n    function getSelf() {\n        return state.connection.state === \"open\" ||\n            state.connection.state === \"connecting\"\n            ? {\n                connectionId: state.connection.id,\n                id: state.connection.userId,\n                info: state.connection.userInfo,\n                presence: getPresence(),\n            }\n            : null;\n    }\n    function connect() {\n        if (typeof window === \"undefined\") {\n            return;\n        }\n        if (state.connection.state !== \"closed\" &&\n            state.connection.state !== \"unavailable\") {\n            return null;\n        }\n        updateConnection({ state: \"authenticating\" });\n        effects.authenticate();\n    }\n    function updatePresence(overrides) {\n        const newPresence = Object.assign(Object.assign({}, state.me), overrides);\n        if (state.flushData.presence == null) {\n            state.flushData.presence = overrides;\n        }\n        else {\n            for (const key in overrides) {\n                state.flushData.presence[key] = overrides[key];\n            }\n        }\n        state.me = newPresence;\n        tryFlushing();\n        for (const listener of state.listeners[\"my-presence\"]) {\n            listener(state.me);\n        }\n    }\n    function authenticationSuccess(token, socket) {\n        updateConnection({\n            state: \"connecting\",\n            id: token.actor,\n            userInfo: token.info,\n            userId: token.id,\n        });\n        state.idFactory = makeIdFactory(token.actor);\n        state.socket = socket;\n    }\n    function authenticationFailure(error) {\n        console.error(error);\n        updateConnection({ state: \"unavailable\" });\n        state.numberOfRetry++;\n        state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());\n    }\n    function onVisibilityChange(visibilityState) {\n        if (visibilityState === \"visible\" && state.connection.state === \"open\") {\n            log(\"Heartbeat after visibility change\");\n            heartbeat();\n        }\n    }\n    function onUpdatePresenceMessage(message) {\n        const user = state.users[message.actor];\n        if (user == null) {\n            state.users[message.actor] = {\n                connectionId: message.actor,\n                presence: message.data,\n            };\n        }\n        else {\n            state.users[message.actor] = {\n                id: user.id,\n                info: user.info,\n                connectionId: message.actor,\n                presence: Object.assign(Object.assign({}, user.presence), message.data),\n            };\n        }\n        updateUsers({\n            type: \"update\",\n            updates: message.data,\n            user: state.users[message.actor],\n        });\n    }\n    function updateUsers(event) {\n        state.others = makeOthers(state.users);\n        for (const listener of state.listeners[\"others\"]) {\n            listener(state.others, event);\n        }\n    }\n    function onUserLeftMessage(message) {\n        const userLeftMessage = message;\n        const user = state.users[userLeftMessage.actor];\n        if (user) {\n            delete state.users[userLeftMessage.actor];\n            updateUsers({ type: \"leave\", user });\n        }\n    }\n    function onRoomStateMessage(message) {\n        const newUsers = {};\n        for (const key in message.users) {\n            const connectionId = Number.parseInt(key);\n            const user = message.users[key];\n            newUsers[connectionId] = {\n                connectionId,\n                info: user.info,\n                id: user.id,\n            };\n        }\n        state.users = newUsers;\n        updateUsers({ type: \"reset\" });\n    }\n    function onNavigatorOnline() {\n        if (state.connection.state === \"unavailable\") {\n            log(\"Try to reconnect after connectivity change\");\n            reconnect();\n        }\n    }\n    function onEvent(message) {\n        for (const listener of state.listeners.event) {\n            listener({ connectionId: message.actor, event: message.event });\n        }\n    }\n    function onUserJoinedMessage(message) {\n        state.users[message.actor] = {\n            connectionId: message.actor,\n            info: message.info,\n            id: message.id,\n        };\n        updateUsers({ type: \"enter\", user: state.users[message.actor] });\n        if (state.me) {\n            // Send current presence to new user\n            // TODO: Consider storing it on the backend\n            state.flushData.messages.push({\n                type: _live__WEBPACK_IMPORTED_MODULE_4__.ClientMessageType.UpdatePresence,\n                data: state.me,\n                targetActor: message.actor,\n            });\n            tryFlushing();\n        }\n    }\n    function onMessage(event) {\n        if (event.data === \"pong\") {\n            clearTimeout(state.timeoutHandles.pongTimeout);\n            return;\n        }\n        const message = JSON.parse(event.data);\n        switch (message.type) {\n            case _live__WEBPACK_IMPORTED_MODULE_4__.ServerMessageType.InitialStorageState: {\n                onInitialStorageState(message);\n                break;\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_4__.ServerMessageType.UpdateStorage: {\n                onStorageUpdates(message);\n                break;\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_4__.ServerMessageType.UserJoined: {\n                onUserJoinedMessage(message);\n                break;\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_4__.ServerMessageType.UpdatePresence: {\n                onUpdatePresenceMessage(message);\n                break;\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_4__.ServerMessageType.Event: {\n                onEvent(message);\n                break;\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_4__.ServerMessageType.UserLeft: {\n                onUserLeftMessage(message);\n                break;\n            }\n            case _live__WEBPACK_IMPORTED_MODULE_4__.ServerMessageType.RoomState: {\n                onRoomStateMessage(message);\n                break;\n            }\n        }\n    }\n    // function onWakeUp() {\n    //   // Sometimes, the browser can put the webpage on pause (computer is on sleep mode for example)\n    //   // The client will not know that the server has probably close the connection even if the readyState is Open\n    //   // One way to detect this kind of pause is to ensure that a setInterval is not taking more than the delay it was configured with\n    //   if (state.connection.state === \"open\") {\n    //     log(\"Try to reconnect after laptop wake up\");\n    //     reconnect();\n    //   }\n    // }\n    function onClose(event) {\n        state.socket = null;\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        clearInterval(state.intervalHandles.heartbeat);\n        if (state.timeoutHandles.flush) {\n            clearTimeout(state.timeoutHandles.flush);\n        }\n        clearTimeout(state.timeoutHandles.reconnect);\n        state.users = {};\n        updateUsers({ type: \"reset\" });\n        if (event.code >= 4000 && event.code <= 4100) {\n            updateConnection({ state: \"failed\" });\n            const error = new LiveblocksError(event.reason, event.code);\n            for (const listener of state.listeners.error) {\n                listener(error);\n            }\n        }\n        else if (event.wasClean === false) {\n            updateConnection({ state: \"unavailable\" });\n            state.numberOfRetry++;\n            state.timeoutHandles.reconnect = effects.scheduleReconnect(getRetryDelay());\n        }\n        else {\n            updateConnection({ state: \"closed\" });\n        }\n    }\n    function updateConnection(connection) {\n        state.connection = connection;\n        for (const listener of state.listeners.connection) {\n            listener(connection.state);\n        }\n    }\n    function getRetryDelay() {\n        return BACKOFF_RETRY_DELAYS[state.numberOfRetry < BACKOFF_RETRY_DELAYS.length\n            ? state.numberOfRetry\n            : BACKOFF_RETRY_DELAYS.length - 1];\n    }\n    function onError() { }\n    function onOpen() {\n        clearInterval(state.intervalHandles.heartbeat);\n        state.intervalHandles.heartbeat = effects.startHeartbeatInterval();\n        if (state.connection.state === \"connecting\") {\n            updateConnection(Object.assign(Object.assign({}, state.connection), { state: \"open\" }));\n            state.numberOfRetry = 0;\n            tryFlushing();\n        }\n        else {\n            // TODO\n        }\n    }\n    function heartbeat() {\n        if (state.socket == null) {\n            // Should never happen, because we clear the pong timeout when the connection is dropped explictly\n            return;\n        }\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        state.timeoutHandles.pongTimeout = effects.schedulePongTimeout();\n        if (state.socket.readyState === WebSocket.OPEN) {\n            state.socket.send(\"ping\");\n        }\n    }\n    function pongTimeout() {\n        log(\"Pong timeout. Trying to reconnect.\");\n        reconnect();\n    }\n    function reconnect() {\n        if (state.socket) {\n            state.socket.removeEventListener(\"open\", onOpen);\n            state.socket.removeEventListener(\"message\", onMessage);\n            state.socket.removeEventListener(\"close\", onClose);\n            state.socket.removeEventListener(\"error\", onError);\n            state.socket.close();\n            state.socket = null;\n        }\n        updateConnection({ state: \"unavailable\" });\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        if (state.timeoutHandles.flush) {\n            clearTimeout(state.timeoutHandles.flush);\n        }\n        clearTimeout(state.timeoutHandles.reconnect);\n        clearInterval(state.intervalHandles.heartbeat);\n        connect();\n    }\n    function tryFlushing() {\n        if (state.socket == null) {\n            return;\n        }\n        if (state.socket.readyState !== WebSocket.OPEN) {\n            return;\n        }\n        const now = Date.now();\n        const elapsedTime = now - state.lastFlushTime;\n        if (elapsedTime > context.throttleDelay) {\n            const messages = flushDataToMessages(state);\n            if (messages.length === 0) {\n                return;\n            }\n            effects.send(messages);\n            state.flushData = {\n                messages: [],\n                storageOperations: [],\n                presence: null,\n            };\n            state.lastFlushTime = now;\n        }\n        else {\n            if (state.timeoutHandles.flush != null) {\n                clearTimeout(state.timeoutHandles.flush);\n            }\n            state.timeoutHandles.flush = effects.delayFlush(context.throttleDelay - (now - state.lastFlushTime));\n        }\n    }\n    function flushDataToMessages(state) {\n        const messages = [];\n        if (state.flushData.presence) {\n            messages.push({\n                type: _live__WEBPACK_IMPORTED_MODULE_4__.ClientMessageType.UpdatePresence,\n                data: state.flushData.presence,\n            });\n        }\n        for (const event of state.flushData.messages) {\n            messages.push(event);\n        }\n        if (state.flushData.storageOperations.length > 0) {\n            messages.push({\n                type: _live__WEBPACK_IMPORTED_MODULE_4__.ClientMessageType.UpdateStorage,\n                ops: state.flushData.storageOperations,\n            });\n        }\n        return messages;\n    }\n    function disconnect() {\n        if (state.socket) {\n            state.socket.removeEventListener(\"open\", onOpen);\n            state.socket.removeEventListener(\"message\", onMessage);\n            state.socket.removeEventListener(\"close\", onClose);\n            state.socket.removeEventListener(\"error\", onError);\n            state.socket.close();\n            state.socket = null;\n        }\n        updateConnection({ state: \"closed\" });\n        if (state.timeoutHandles.flush) {\n            clearTimeout(state.timeoutHandles.flush);\n        }\n        clearTimeout(state.timeoutHandles.reconnect);\n        clearTimeout(state.timeoutHandles.pongTimeout);\n        clearInterval(state.intervalHandles.heartbeat);\n        state.users = {};\n        updateUsers({ type: \"reset\" });\n        clearListeners();\n    }\n    function clearListeners() {\n        for (const key in state.listeners) {\n            state.listeners[key] = [];\n        }\n    }\n    function getPresence() {\n        return state.me;\n    }\n    function getOthers() {\n        return state.others;\n    }\n    function broadcastEvent(event) {\n        if (state.socket == null) {\n            return;\n        }\n        state.flushData.messages.push({\n            type: _live__WEBPACK_IMPORTED_MODULE_4__.ClientMessageType.ClientEvent,\n            event,\n        });\n        tryFlushing();\n    }\n    /**\n     * STORAGE\n     */\n    function onStorageUpdates(message) {\n        if (state.doc == null) {\n            // TODO: Cache updates in case they are coming while root is queried\n            return;\n        }\n        updateDoc(message.ops.reduce((doc, op) => doc.dispatch(op), state.doc));\n    }\n    function updateDoc(doc) {\n        state.doc = doc;\n        if (doc) {\n            for (const listener of state.listeners.storage) {\n                listener(getStorage());\n            }\n        }\n    }\n    function getStorage() {\n        if (state.storageState === _types__WEBPACK_IMPORTED_MODULE_1__.LiveStorageState.Loaded) {\n            return {\n                state: state.storageState,\n                root: state.doc.root,\n            };\n        }\n        return {\n            state: state.storageState,\n        };\n    }\n    function onInitialStorageState(message) {\n        state.storageState = _types__WEBPACK_IMPORTED_MODULE_1__.LiveStorageState.Loaded;\n        if (message.root == null) {\n            const rootId = makeId();\n            state.doc = _doc__WEBPACK_IMPORTED_MODULE_0__.Doc.empty(rootId, (op) => dispatch(op));\n            updateDoc(state.doc.updateRecord(rootId, state.initialStorageFactory({\n                createRecord: (data) => createRecord(data),\n                createList: () => createList(),\n            })));\n        }\n        else {\n            updateDoc(_doc__WEBPACK_IMPORTED_MODULE_0__.Doc.load(message.root, (op) => dispatch(op)));\n        }\n    }\n    function makeId() {\n        if (state.idFactory == null) {\n            throw new Error(\"Can't generate id. Id factory is missing.\");\n        }\n        return state.idFactory();\n    }\n    function dispatch(op) {\n        state.flushData.storageOperations.push(op);\n        tryFlushing();\n    }\n    function createRecord(data) {\n        return (0,_doc__WEBPACK_IMPORTED_MODULE_0__.createRecord)(makeId(), data);\n    }\n    function createList() {\n        return (0,_doc__WEBPACK_IMPORTED_MODULE_0__.createList)(makeId());\n    }\n    function fetchStorage(initialStorageFactory) {\n        state.initialStorageFactory = initialStorageFactory;\n        state.storageState = _types__WEBPACK_IMPORTED_MODULE_1__.LiveStorageState.Loading;\n        state.flushData.messages.push({ type: _live__WEBPACK_IMPORTED_MODULE_4__.ClientMessageType.FetchStorage });\n        tryFlushing();\n    }\n    function updateRecord(record, overrides) {\n        updateDoc(state.doc.updateRecord(record.id, overrides));\n    }\n    function pushItem(list, item) {\n        updateDoc(state.doc.pushItem(list.id, item));\n    }\n    function deleteItem(list, index) {\n        updateDoc(state.doc.deleteItem(list.id, index));\n    }\n    function deleteItemById(list, itemId) {\n        updateDoc(state.doc.deleteItemById(list.id, itemId));\n    }\n    function moveItem(list, index, targetIndex) {\n        updateDoc(state.doc.moveItem(list.id, index, targetIndex));\n    }\n    return {\n        // Internal\n        onOpen,\n        onClose,\n        onMessage,\n        authenticationSuccess,\n        heartbeat,\n        onNavigatorOnline,\n        // onWakeUp,\n        onVisibilityChange,\n        // Core\n        connect,\n        disconnect,\n        subscribe,\n        unsubscribe,\n        // Presence\n        updatePresence,\n        broadcastEvent,\n        // Storage\n        fetchStorage,\n        createRecord,\n        updateRecord,\n        createList,\n        pushItem,\n        deleteItem,\n        deleteItemById,\n        moveItem,\n        selectors: {\n            // Core\n            getConnectionState,\n            getSelf,\n            // Presence\n            getPresence,\n            getOthers,\n            // Storage\n            getStorage,\n        },\n    };\n}\nfunction defaultState(me) {\n    return {\n        connection: { state: \"closed\" },\n        socket: null,\n        listeners: {\n            storage: [],\n            event: [],\n            others: [],\n            \"my-presence\": [],\n            error: [],\n            connection: [],\n        },\n        numberOfRetry: 0,\n        lastFlushTime: 0,\n        timeoutHandles: {\n            flush: null,\n            reconnect: 0,\n            pongTimeout: 0,\n        },\n        flushData: {\n            presence: me == null ? {} : me,\n            messages: [],\n            storageOperations: [],\n        },\n        intervalHandles: {\n            heartbeat: 0,\n        },\n        me: me == null ? {} : me,\n        users: {},\n        others: makeOthers({}),\n        storageState: _types__WEBPACK_IMPORTED_MODULE_1__.LiveStorageState.NotInitialized,\n        initialStorageFactory: null,\n        doc: null,\n        idFactory: null,\n    };\n}\nfunction createRoom(name, options) {\n    const throttleDelay = options.throttle || 100;\n    const liveblocksServer = options.liveblocksServer || \"wss://liveblocks.net\";\n    const authEndpoint = options.authEndpoint;\n    const state = defaultState(options.initialPresence);\n    const machine = makeStateMachine(state, {\n        throttleDelay,\n        liveblocksServer,\n        authEndpoint,\n        room: name,\n    });\n    const room = {\n        /////////////\n        // Core    //\n        /////////////\n        getConnectionState: machine.selectors.getConnectionState,\n        getSelf: machine.selectors.getSelf,\n        subscribe: machine.subscribe,\n        unsubscribe: machine.unsubscribe,\n        /////////////\n        // Storage //\n        /////////////\n        getStorage: machine.selectors.getStorage,\n        fetchStorage: machine.fetchStorage,\n        createRecord: machine.createRecord,\n        createList: machine.createList,\n        updateRecord: machine.updateRecord,\n        pushItem: machine.pushItem,\n        deleteItem: machine.deleteItem,\n        deleteItemById: machine.deleteItemById,\n        moveItem: machine.moveItem,\n        //////////////\n        // Presence //\n        //////////////\n        getPresence: machine.selectors.getPresence,\n        updatePresence: machine.updatePresence,\n        getOthers: machine.selectors.getOthers,\n        broadcastEvent: machine.broadcastEvent,\n    };\n    return {\n        connect: machine.connect,\n        disconnect: machine.disconnect,\n        onNavigatorOnline: machine.onNavigatorOnline,\n        onVisibilityChange: machine.onVisibilityChange,\n        room,\n    };\n}\nclass LiveblocksError extends Error {\n    constructor(message, code) {\n        super(message);\n        this.code = code;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vcm9vbS5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFBLGlCQUFpQixTQUFJLElBQUksU0FBSTtBQUM3Qiw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUM0QjtBQUNnQjtBQUM4QztBQUN6RDtBQUNtQjtBQUNXO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsYUFBYSxHQUFHLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLDJEQUFJO0FBQzVDLHdDQUF3QywyREFBVTtBQUNsRCxvREFBb0QseUJBQXlCLFVBQVUsTUFBTTtBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsS0FBSztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLE1BQU07QUFDdEM7QUFDQTtBQUNBLFFBQVEsOENBQU07QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ087QUFDUDtBQUNBLHNCQUFzQixpQkFBaUI7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNULDRCQUE0QjtBQUM1QixpQkFBaUI7QUFDakIsNkJBQTZCO0FBQzdCLHNCQUFzQixtRUFBK0I7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vcm9vbS5qcz8zZmUyIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgRG9jIH0gZnJvbSBcIi4vZG9jXCI7XG5pbXBvcnQgeyBMaXZlU3RvcmFnZVN0YXRlLCB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQgeyBjcmVhdGVSZWNvcmQgYXMgaW5uZXJDcmVhdGVSZWNvcmQsIGNyZWF0ZUxpc3QgYXMgaW5uZXJDcmVhdGVMaXN0LCB9IGZyb20gXCIuL2RvY1wiO1xuaW1wb3J0IHsgcmVtb3ZlIH0gZnJvbSBcIi4vdXRpbHNcIjtcbmltcG9ydCBhdXRoLCB7IHBhcnNlVG9rZW4gfSBmcm9tIFwiLi9hdXRoZW50aWNhdGlvblwiO1xuaW1wb3J0IHsgQ2xpZW50TWVzc2FnZVR5cGUsIFNlcnZlck1lc3NhZ2VUeXBlLCB9IGZyb20gXCIuL2xpdmVcIjtcbmNvbnN0IEJBQ0tPRkZfUkVUUllfREVMQVlTID0gWzI1MCwgNTAwLCAxMDAwLCAyMDAwLCA0MDAwLCA4MDAwLCAxMDAwMF07XG5jb25zdCBIRUFSVEJFQVRfSU5URVJWQUwgPSAzMDAwMDtcbi8vIGNvbnN0IFdBS0VfVVBfQ0hFQ0tfSU5URVJWQUwgPSAyMDAwO1xuY29uc3QgUE9OR19USU1FT1VUID0gMjAwMDtcbmZ1bmN0aW9uIGlzVmFsaWRSb29tRXZlbnRUeXBlKHZhbHVlKSB7XG4gICAgcmV0dXJuICh2YWx1ZSA9PT0gXCJzdG9yYWdlXCIgfHxcbiAgICAgICAgdmFsdWUgPT09IFwibXktcHJlc2VuY2VcIiB8fFxuICAgICAgICB2YWx1ZSA9PT0gXCJvdGhlcnNcIiB8fFxuICAgICAgICB2YWx1ZSA9PT0gXCJldmVudFwiIHx8XG4gICAgICAgIHZhbHVlID09PSBcImVycm9yXCIgfHxcbiAgICAgICAgdmFsdWUgPT09IFwiY29ubmVjdGlvblwiKTtcbn1cbmZ1bmN0aW9uIG1ha2VJZEZhY3RvcnkoY29ubmVjdGlvbklkKSB7XG4gICAgbGV0IGNvdW50ID0gMDtcbiAgICByZXR1cm4gKCkgPT4gYCR7Y29ubmVjdGlvbklkfToke2NvdW50Kyt9YDtcbn1cbmZ1bmN0aW9uIG1ha2VPdGhlcnMocHJlc2VuY2VNYXApIHtcbiAgICBjb25zdCBhcnJheSA9IE9iamVjdC52YWx1ZXMocHJlc2VuY2VNYXApO1xuICAgIHJldHVybiB7XG4gICAgICAgIGdldCBjb3VudCgpIHtcbiAgICAgICAgICAgIHJldHVybiBhcnJheS5sZW5ndGg7XG4gICAgICAgIH0sXG4gICAgICAgIG1hcChjYWxsYmFjaykge1xuICAgICAgICAgICAgcmV0dXJuIGFycmF5Lm1hcChjYWxsYmFjayk7XG4gICAgICAgIH0sXG4gICAgICAgIHRvQXJyYXkoKSB7XG4gICAgICAgICAgICByZXR1cm4gYXJyYXk7XG4gICAgICAgIH0sXG4gICAgfTtcbn1cbmZ1bmN0aW9uIGxvZyguLi5wYXJhbXMpIHtcbiAgICByZXR1cm47XG4gICAgY29uc29sZS5sb2coLi4ucGFyYW1zLCBuZXcgRGF0ZSgpLnRvU3RyaW5nKCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VTdGF0ZU1hY2hpbmUoc3RhdGUsIGNvbnRleHQsIG1vY2tlZEVmZmVjdHMpIHtcbiAgICBjb25zdCBlZmZlY3RzID0gbW9ja2VkRWZmZWN0cyB8fCB7XG4gICAgICAgIGF1dGhlbnRpY2F0ZSgpIHtcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdG9rZW4gPSB5aWVsZCBhdXRoKGNvbnRleHQuYXV0aEVuZHBvaW50LCBjb250ZXh0LnJvb20pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBwYXJzZWRUb2tlbiA9IHBhcnNlVG9rZW4odG9rZW4pO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzb2NrZXQgPSBuZXcgV2ViU29ja2V0KGAke2NvbnRleHQubGl2ZWJsb2Nrc1NlcnZlcn0vP3Rva2VuPSR7dG9rZW59YCk7XG4gICAgICAgICAgICAgICAgICAgIHNvY2tldC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICBzb2NrZXQuYWRkRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgb25PcGVuKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgICAgICAgICAgICAgc29ja2V0LmFkZEV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb25TdWNjZXNzKHBhcnNlZFRva2VuLCBzb2NrZXQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgYXV0aGVudGljYXRpb25GYWlsdXJlKGVyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSxcbiAgICAgICAgc2VuZChtZXNzYWdlT3JNZXNzYWdlcykge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnNvY2tldCA9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3Qgc2VuZCBtZXNzYWdlIGlmIHNvY2tldCBpcyBudWxsXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUuc29ja2V0LnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZU9yTWVzc2FnZXMpKTtcbiAgICAgICAgfSxcbiAgICAgICAgZGVsYXlGbHVzaChkZWxheSkge1xuICAgICAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQodHJ5Rmx1c2hpbmcsIGRlbGF5KTtcbiAgICAgICAgfSxcbiAgICAgICAgc3RhcnRIZWFydGJlYXRJbnRlcnZhbCgpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRJbnRlcnZhbChoZWFydGJlYXQsIEhFQVJUQkVBVF9JTlRFUlZBTCk7XG4gICAgICAgIH0sXG4gICAgICAgIHNjaGVkdWxlUG9uZ1RpbWVvdXQoKSB7XG4gICAgICAgICAgICByZXR1cm4gc2V0VGltZW91dChwb25nVGltZW91dCwgUE9OR19USU1FT1VUKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2NoZWR1bGVSZWNvbm5lY3QoZGVsYXkpIHtcbiAgICAgICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGNvbm5lY3QsIGRlbGF5KTtcbiAgICAgICAgfSxcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHN1YnNjcmliZSh0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoIWlzVmFsaWRSb29tRXZlbnRUeXBlKHR5cGUpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFwiJHt0eXBlfVwiIGlzIG5vdCBhIHZhbGlkIGV2ZW50IG5hbWVgKTtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5saXN0ZW5lcnNbdHlwZV0ucHVzaChsaXN0ZW5lcik7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWlzVmFsaWRSb29tRXZlbnRUeXBlKGV2ZW50KSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBcIiR7ZXZlbnR9XCIgaXMgbm90IGEgdmFsaWQgZXZlbnQgbmFtZWApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbGxiYWNrcyA9IHN0YXRlLmxpc3RlbmVyc1tldmVudF07XG4gICAgICAgIHJlbW92ZShjYWxsYmFja3MsIGNhbGxiYWNrKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0Q29ubmVjdGlvblN0YXRlKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUuY29ubmVjdGlvbi5zdGF0ZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0U2VsZigpIHtcbiAgICAgICAgcmV0dXJuIHN0YXRlLmNvbm5lY3Rpb24uc3RhdGUgPT09IFwib3BlblwiIHx8XG4gICAgICAgICAgICBzdGF0ZS5jb25uZWN0aW9uLnN0YXRlID09PSBcImNvbm5lY3RpbmdcIlxuICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBzdGF0ZS5jb25uZWN0aW9uLmlkLFxuICAgICAgICAgICAgICAgIGlkOiBzdGF0ZS5jb25uZWN0aW9uLnVzZXJJZCxcbiAgICAgICAgICAgICAgICBpbmZvOiBzdGF0ZS5jb25uZWN0aW9uLnVzZXJJbmZvLFxuICAgICAgICAgICAgICAgIHByZXNlbmNlOiBnZXRQcmVzZW5jZSgpLFxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBudWxsO1xuICAgIH1cbiAgICBmdW5jdGlvbiBjb25uZWN0KCkge1xuICAgICAgICBpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZS5jb25uZWN0aW9uLnN0YXRlICE9PSBcImNsb3NlZFwiICYmXG4gICAgICAgICAgICBzdGF0ZS5jb25uZWN0aW9uLnN0YXRlICE9PSBcInVuYXZhaWxhYmxlXCIpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHVwZGF0ZUNvbm5lY3Rpb24oeyBzdGF0ZTogXCJhdXRoZW50aWNhdGluZ1wiIH0pO1xuICAgICAgICBlZmZlY3RzLmF1dGhlbnRpY2F0ZSgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVQcmVzZW5jZShvdmVycmlkZXMpIHtcbiAgICAgICAgY29uc3QgbmV3UHJlc2VuY2UgPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLm1lKSwgb3ZlcnJpZGVzKTtcbiAgICAgICAgaWYgKHN0YXRlLmZsdXNoRGF0YS5wcmVzZW5jZSA9PSBudWxsKSB7XG4gICAgICAgICAgICBzdGF0ZS5mbHVzaERhdGEucHJlc2VuY2UgPSBvdmVycmlkZXM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBvdmVycmlkZXMpIHtcbiAgICAgICAgICAgICAgICBzdGF0ZS5mbHVzaERhdGEucHJlc2VuY2Vba2V5XSA9IG92ZXJyaWRlc1trZXldO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHN0YXRlLm1lID0gbmV3UHJlc2VuY2U7XG4gICAgICAgIHRyeUZsdXNoaW5nKCk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2Ygc3RhdGUubGlzdGVuZXJzW1wibXktcHJlc2VuY2VcIl0pIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKHN0YXRlLm1lKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBhdXRoZW50aWNhdGlvblN1Y2Nlc3ModG9rZW4sIHNvY2tldCkge1xuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIHN0YXRlOiBcImNvbm5lY3RpbmdcIixcbiAgICAgICAgICAgIGlkOiB0b2tlbi5hY3RvcixcbiAgICAgICAgICAgIHVzZXJJbmZvOiB0b2tlbi5pbmZvLFxuICAgICAgICAgICAgdXNlcklkOiB0b2tlbi5pZCxcbiAgICAgICAgfSk7XG4gICAgICAgIHN0YXRlLmlkRmFjdG9yeSA9IG1ha2VJZEZhY3RvcnkodG9rZW4uYWN0b3IpO1xuICAgICAgICBzdGF0ZS5zb2NrZXQgPSBzb2NrZXQ7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGF1dGhlbnRpY2F0aW9uRmFpbHVyZShlcnJvcikge1xuICAgICAgICBjb25zb2xlLmVycm9yKGVycm9yKTtcbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbih7IHN0YXRlOiBcInVuYXZhaWxhYmxlXCIgfSk7XG4gICAgICAgIHN0YXRlLm51bWJlck9mUmV0cnkrKztcbiAgICAgICAgc3RhdGUudGltZW91dEhhbmRsZXMucmVjb25uZWN0ID0gZWZmZWN0cy5zY2hlZHVsZVJlY29ubmVjdChnZXRSZXRyeURlbGF5KCkpO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvblZpc2liaWxpdHlDaGFuZ2UodmlzaWJpbGl0eVN0YXRlKSB7XG4gICAgICAgIGlmICh2aXNpYmlsaXR5U3RhdGUgPT09IFwidmlzaWJsZVwiICYmIHN0YXRlLmNvbm5lY3Rpb24uc3RhdGUgPT09IFwib3BlblwiKSB7XG4gICAgICAgICAgICBsb2coXCJIZWFydGJlYXQgYWZ0ZXIgdmlzaWJpbGl0eSBjaGFuZ2VcIik7XG4gICAgICAgICAgICBoZWFydGJlYXQoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblVwZGF0ZVByZXNlbmNlTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBzdGF0ZS51c2Vyc1ttZXNzYWdlLmFjdG9yXTtcbiAgICAgICAgaWYgKHVzZXIgPT0gbnVsbCkge1xuICAgICAgICAgICAgc3RhdGUudXNlcnNbbWVzc2FnZS5hY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgICAgIHByZXNlbmNlOiBtZXNzYWdlLmRhdGEsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc3RhdGUudXNlcnNbbWVzc2FnZS5hY3Rvcl0gPSB7XG4gICAgICAgICAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICAgICAgaW5mbzogdXNlci5pbmZvLFxuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgICAgICBwcmVzZW5jZTogT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCB1c2VyLnByZXNlbmNlKSwgbWVzc2FnZS5kYXRhKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlVXNlcnMoe1xuICAgICAgICAgICAgdHlwZTogXCJ1cGRhdGVcIixcbiAgICAgICAgICAgIHVwZGF0ZXM6IG1lc3NhZ2UuZGF0YSxcbiAgICAgICAgICAgIHVzZXI6IHN0YXRlLnVzZXJzW21lc3NhZ2UuYWN0b3JdLFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlVXNlcnMoZXZlbnQpIHtcbiAgICAgICAgc3RhdGUub3RoZXJzID0gbWFrZU90aGVycyhzdGF0ZS51c2Vycyk7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2Ygc3RhdGUubGlzdGVuZXJzW1wib3RoZXJzXCJdKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihzdGF0ZS5vdGhlcnMsIGV2ZW50KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIGNvbnN0IHVzZXJMZWZ0TWVzc2FnZSA9IG1lc3NhZ2U7XG4gICAgICAgIGNvbnN0IHVzZXIgPSBzdGF0ZS51c2Vyc1t1c2VyTGVmdE1lc3NhZ2UuYWN0b3JdO1xuICAgICAgICBpZiAodXNlcikge1xuICAgICAgICAgICAgZGVsZXRlIHN0YXRlLnVzZXJzW3VzZXJMZWZ0TWVzc2FnZS5hY3Rvcl07XG4gICAgICAgICAgICB1cGRhdGVVc2Vycyh7IHR5cGU6IFwibGVhdmVcIiwgdXNlciB9KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvblJvb21TdGF0ZU1lc3NhZ2UobWVzc2FnZSkge1xuICAgICAgICBjb25zdCBuZXdVc2VycyA9IHt9O1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBtZXNzYWdlLnVzZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBjb25uZWN0aW9uSWQgPSBOdW1iZXIucGFyc2VJbnQoa2V5KTtcbiAgICAgICAgICAgIGNvbnN0IHVzZXIgPSBtZXNzYWdlLnVzZXJzW2tleV07XG4gICAgICAgICAgICBuZXdVc2Vyc1tjb25uZWN0aW9uSWRdID0ge1xuICAgICAgICAgICAgICAgIGNvbm5lY3Rpb25JZCxcbiAgICAgICAgICAgICAgICBpbmZvOiB1c2VyLmluZm8sXG4gICAgICAgICAgICAgICAgaWQ6IHVzZXIuaWQsXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnVzZXJzID0gbmV3VXNlcnM7XG4gICAgICAgIHVwZGF0ZVVzZXJzKHsgdHlwZTogXCJyZXNldFwiIH0pO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbk5hdmlnYXRvck9ubGluZSgpIHtcbiAgICAgICAgaWYgKHN0YXRlLmNvbm5lY3Rpb24uc3RhdGUgPT09IFwidW5hdmFpbGFibGVcIikge1xuICAgICAgICAgICAgbG9nKFwiVHJ5IHRvIHJlY29ubmVjdCBhZnRlciBjb25uZWN0aXZpdHkgY2hhbmdlXCIpO1xuICAgICAgICAgICAgcmVjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25FdmVudChtZXNzYWdlKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2Ygc3RhdGUubGlzdGVuZXJzLmV2ZW50KSB7XG4gICAgICAgICAgICBsaXN0ZW5lcih7IGNvbm5lY3Rpb25JZDogbWVzc2FnZS5hY3RvciwgZXZlbnQ6IG1lc3NhZ2UuZXZlbnQgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gb25Vc2VySm9pbmVkTWVzc2FnZShtZXNzYWdlKSB7XG4gICAgICAgIHN0YXRlLnVzZXJzW21lc3NhZ2UuYWN0b3JdID0ge1xuICAgICAgICAgICAgY29ubmVjdGlvbklkOiBtZXNzYWdlLmFjdG9yLFxuICAgICAgICAgICAgaW5mbzogbWVzc2FnZS5pbmZvLFxuICAgICAgICAgICAgaWQ6IG1lc3NhZ2UuaWQsXG4gICAgICAgIH07XG4gICAgICAgIHVwZGF0ZVVzZXJzKHsgdHlwZTogXCJlbnRlclwiLCB1c2VyOiBzdGF0ZS51c2Vyc1ttZXNzYWdlLmFjdG9yXSB9KTtcbiAgICAgICAgaWYgKHN0YXRlLm1lKSB7XG4gICAgICAgICAgICAvLyBTZW5kIGN1cnJlbnQgcHJlc2VuY2UgdG8gbmV3IHVzZXJcbiAgICAgICAgICAgIC8vIFRPRE86IENvbnNpZGVyIHN0b3JpbmcgaXQgb24gdGhlIGJhY2tlbmRcbiAgICAgICAgICAgIHN0YXRlLmZsdXNoRGF0YS5tZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBDbGllbnRNZXNzYWdlVHlwZS5VcGRhdGVQcmVzZW5jZSxcbiAgICAgICAgICAgICAgICBkYXRhOiBzdGF0ZS5tZSxcbiAgICAgICAgICAgICAgICB0YXJnZXRBY3RvcjogbWVzc2FnZS5hY3RvcixcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5Rmx1c2hpbmcoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBvbk1lc3NhZ2UoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50LmRhdGEgPT09IFwicG9uZ1wiKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dEhhbmRsZXMucG9uZ1RpbWVvdXQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBKU09OLnBhcnNlKGV2ZW50LmRhdGEpO1xuICAgICAgICBzd2l0Y2ggKG1lc3NhZ2UudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBTZXJ2ZXJNZXNzYWdlVHlwZS5Jbml0aWFsU3RvcmFnZVN0YXRlOiB7XG4gICAgICAgICAgICAgICAgb25Jbml0aWFsU3RvcmFnZVN0YXRlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBTZXJ2ZXJNZXNzYWdlVHlwZS5VcGRhdGVTdG9yYWdlOiB7XG4gICAgICAgICAgICAgICAgb25TdG9yYWdlVXBkYXRlcyhtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2VydmVyTWVzc2FnZVR5cGUuVXNlckpvaW5lZDoge1xuICAgICAgICAgICAgICAgIG9uVXNlckpvaW5lZE1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNlcnZlck1lc3NhZ2VUeXBlLlVwZGF0ZVByZXNlbmNlOiB7XG4gICAgICAgICAgICAgICAgb25VcGRhdGVQcmVzZW5jZU1lc3NhZ2UobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFNlcnZlck1lc3NhZ2VUeXBlLkV2ZW50OiB7XG4gICAgICAgICAgICAgICAgb25FdmVudChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2VydmVyTWVzc2FnZVR5cGUuVXNlckxlZnQ6IHtcbiAgICAgICAgICAgICAgICBvblVzZXJMZWZ0TWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgU2VydmVyTWVzc2FnZVR5cGUuUm9vbVN0YXRlOiB7XG4gICAgICAgICAgICAgICAgb25Sb29tU3RhdGVNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIC8vIGZ1bmN0aW9uIG9uV2FrZVVwKCkge1xuICAgIC8vICAgLy8gU29tZXRpbWVzLCB0aGUgYnJvd3NlciBjYW4gcHV0IHRoZSB3ZWJwYWdlIG9uIHBhdXNlIChjb21wdXRlciBpcyBvbiBzbGVlcCBtb2RlIGZvciBleGFtcGxlKVxuICAgIC8vICAgLy8gVGhlIGNsaWVudCB3aWxsIG5vdCBrbm93IHRoYXQgdGhlIHNlcnZlciBoYXMgcHJvYmFibHkgY2xvc2UgdGhlIGNvbm5lY3Rpb24gZXZlbiBpZiB0aGUgcmVhZHlTdGF0ZSBpcyBPcGVuXG4gICAgLy8gICAvLyBPbmUgd2F5IHRvIGRldGVjdCB0aGlzIGtpbmQgb2YgcGF1c2UgaXMgdG8gZW5zdXJlIHRoYXQgYSBzZXRJbnRlcnZhbCBpcyBub3QgdGFraW5nIG1vcmUgdGhhbiB0aGUgZGVsYXkgaXQgd2FzIGNvbmZpZ3VyZWQgd2l0aFxuICAgIC8vICAgaWYgKHN0YXRlLmNvbm5lY3Rpb24uc3RhdGUgPT09IFwib3BlblwiKSB7XG4gICAgLy8gICAgIGxvZyhcIlRyeSB0byByZWNvbm5lY3QgYWZ0ZXIgbGFwdG9wIHdha2UgdXBcIik7XG4gICAgLy8gICAgIHJlY29ubmVjdCgpO1xuICAgIC8vICAgfVxuICAgIC8vIH1cbiAgICBmdW5jdGlvbiBvbkNsb3NlKGV2ZW50KSB7XG4gICAgICAgIHN0YXRlLnNvY2tldCA9IG51bGw7XG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS50aW1lb3V0SGFuZGxlcy5wb25nVGltZW91dCk7XG4gICAgICAgIGNsZWFySW50ZXJ2YWwoc3RhdGUuaW50ZXJ2YWxIYW5kbGVzLmhlYXJ0YmVhdCk7XG4gICAgICAgIGlmIChzdGF0ZS50aW1lb3V0SGFuZGxlcy5mbHVzaCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRIYW5kbGVzLmZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dEhhbmRsZXMucmVjb25uZWN0KTtcbiAgICAgICAgc3RhdGUudXNlcnMgPSB7fTtcbiAgICAgICAgdXBkYXRlVXNlcnMoeyB0eXBlOiBcInJlc2V0XCIgfSk7XG4gICAgICAgIGlmIChldmVudC5jb2RlID49IDQwMDAgJiYgZXZlbnQuY29kZSA8PSA0MTAwKSB7XG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uKHsgc3RhdGU6IFwiZmFpbGVkXCIgfSk7XG4gICAgICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBMaXZlYmxvY2tzRXJyb3IoZXZlbnQucmVhc29uLCBldmVudC5jb2RlKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2Ygc3RhdGUubGlzdGVuZXJzLmVycm9yKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGV2ZW50Lndhc0NsZWFuID09PSBmYWxzZSkge1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbih7IHN0YXRlOiBcInVuYXZhaWxhYmxlXCIgfSk7XG4gICAgICAgICAgICBzdGF0ZS5udW1iZXJPZlJldHJ5Kys7XG4gICAgICAgICAgICBzdGF0ZS50aW1lb3V0SGFuZGxlcy5yZWNvbm5lY3QgPSBlZmZlY3RzLnNjaGVkdWxlUmVjb25uZWN0KGdldFJldHJ5RGVsYXkoKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVDb25uZWN0aW9uKHsgc3RhdGU6IFwiY2xvc2VkXCIgfSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gdXBkYXRlQ29ubmVjdGlvbihjb25uZWN0aW9uKSB7XG4gICAgICAgIHN0YXRlLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHN0YXRlLmxpc3RlbmVycy5jb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBsaXN0ZW5lcihjb25uZWN0aW9uLnN0YXRlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRSZXRyeURlbGF5KCkge1xuICAgICAgICByZXR1cm4gQkFDS09GRl9SRVRSWV9ERUxBWVNbc3RhdGUubnVtYmVyT2ZSZXRyeSA8IEJBQ0tPRkZfUkVUUllfREVMQVlTLmxlbmd0aFxuICAgICAgICAgICAgPyBzdGF0ZS5udW1iZXJPZlJldHJ5XG4gICAgICAgICAgICA6IEJBQ0tPRkZfUkVUUllfREVMQVlTLmxlbmd0aCAtIDFdO1xuICAgIH1cbiAgICBmdW5jdGlvbiBvbkVycm9yKCkgeyB9XG4gICAgZnVuY3Rpb24gb25PcGVuKCkge1xuICAgICAgICBjbGVhckludGVydmFsKHN0YXRlLmludGVydmFsSGFuZGxlcy5oZWFydGJlYXQpO1xuICAgICAgICBzdGF0ZS5pbnRlcnZhbEhhbmRsZXMuaGVhcnRiZWF0ID0gZWZmZWN0cy5zdGFydEhlYXJ0YmVhdEludGVydmFsKCk7XG4gICAgICAgIGlmIChzdGF0ZS5jb25uZWN0aW9uLnN0YXRlID09PSBcImNvbm5lY3RpbmdcIikge1xuICAgICAgICAgICAgdXBkYXRlQ29ubmVjdGlvbihPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLmNvbm5lY3Rpb24pLCB7IHN0YXRlOiBcIm9wZW5cIiB9KSk7XG4gICAgICAgICAgICBzdGF0ZS5udW1iZXJPZlJldHJ5ID0gMDtcbiAgICAgICAgICAgIHRyeUZsdXNoaW5nKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBUT0RPXG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gaGVhcnRiZWF0KCkge1xuICAgICAgICBpZiAoc3RhdGUuc29ja2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFNob3VsZCBuZXZlciBoYXBwZW4sIGJlY2F1c2Ugd2UgY2xlYXIgdGhlIHBvbmcgdGltZW91dCB3aGVuIHRoZSBjb25uZWN0aW9uIGlzIGRyb3BwZWQgZXhwbGljdGx5XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRIYW5kbGVzLnBvbmdUaW1lb3V0KTtcbiAgICAgICAgc3RhdGUudGltZW91dEhhbmRsZXMucG9uZ1RpbWVvdXQgPSBlZmZlY3RzLnNjaGVkdWxlUG9uZ1RpbWVvdXQoKTtcbiAgICAgICAgaWYgKHN0YXRlLnNvY2tldC5yZWFkeVN0YXRlID09PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgc3RhdGUuc29ja2V0LnNlbmQoXCJwaW5nXCIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIHBvbmdUaW1lb3V0KCkge1xuICAgICAgICBsb2coXCJQb25nIHRpbWVvdXQuIFRyeWluZyB0byByZWNvbm5lY3QuXCIpO1xuICAgICAgICByZWNvbm5lY3QoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcmVjb25uZWN0KCkge1xuICAgICAgICBpZiAoc3RhdGUuc29ja2V0KSB7XG4gICAgICAgICAgICBzdGF0ZS5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcIm9wZW5cIiwgb25PcGVuKTtcbiAgICAgICAgICAgIHN0YXRlLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbk1lc3NhZ2UpO1xuICAgICAgICAgICAgc3RhdGUuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjbG9zZVwiLCBvbkNsb3NlKTtcbiAgICAgICAgICAgIHN0YXRlLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25FcnJvcik7XG4gICAgICAgICAgICBzdGF0ZS5zb2NrZXQuY2xvc2UoKTtcbiAgICAgICAgICAgIHN0YXRlLnNvY2tldCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlQ29ubmVjdGlvbih7IHN0YXRlOiBcInVuYXZhaWxhYmxlXCIgfSk7XG4gICAgICAgIGNsZWFyVGltZW91dChzdGF0ZS50aW1lb3V0SGFuZGxlcy5wb25nVGltZW91dCk7XG4gICAgICAgIGlmIChzdGF0ZS50aW1lb3V0SGFuZGxlcy5mbHVzaCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRIYW5kbGVzLmZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dEhhbmRsZXMucmVjb25uZWN0KTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChzdGF0ZS5pbnRlcnZhbEhhbmRsZXMuaGVhcnRiZWF0KTtcbiAgICAgICAgY29ubmVjdCgpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB0cnlGbHVzaGluZygpIHtcbiAgICAgICAgaWYgKHN0YXRlLnNvY2tldCA9PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlLnNvY2tldC5yZWFkeVN0YXRlICE9PSBXZWJTb2NrZXQuT1BFTikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG5vdyA9IERhdGUubm93KCk7XG4gICAgICAgIGNvbnN0IGVsYXBzZWRUaW1lID0gbm93IC0gc3RhdGUubGFzdEZsdXNoVGltZTtcbiAgICAgICAgaWYgKGVsYXBzZWRUaW1lID4gY29udGV4dC50aHJvdHRsZURlbGF5KSB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlcyA9IGZsdXNoRGF0YVRvTWVzc2FnZXMoc3RhdGUpO1xuICAgICAgICAgICAgaWYgKG1lc3NhZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVmZmVjdHMuc2VuZChtZXNzYWdlcyk7XG4gICAgICAgICAgICBzdGF0ZS5mbHVzaERhdGEgPSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZXM6IFtdLFxuICAgICAgICAgICAgICAgIHN0b3JhZ2VPcGVyYXRpb25zOiBbXSxcbiAgICAgICAgICAgICAgICBwcmVzZW5jZTogbnVsbCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBzdGF0ZS5sYXN0Rmx1c2hUaW1lID0gbm93O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHN0YXRlLnRpbWVvdXRIYW5kbGVzLmZsdXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dEhhbmRsZXMuZmx1c2gpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RhdGUudGltZW91dEhhbmRsZXMuZmx1c2ggPSBlZmZlY3RzLmRlbGF5Rmx1c2goY29udGV4dC50aHJvdHRsZURlbGF5IC0gKG5vdyAtIHN0YXRlLmxhc3RGbHVzaFRpbWUpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBmbHVzaERhdGFUb01lc3NhZ2VzKHN0YXRlKSB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChzdGF0ZS5mbHVzaERhdGEucHJlc2VuY2UpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IENsaWVudE1lc3NhZ2VUeXBlLlVwZGF0ZVByZXNlbmNlLFxuICAgICAgICAgICAgICAgIGRhdGE6IHN0YXRlLmZsdXNoRGF0YS5wcmVzZW5jZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGZvciAoY29uc3QgZXZlbnQgb2Ygc3RhdGUuZmx1c2hEYXRhLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgICBtZXNzYWdlcy5wdXNoKGV2ZW50KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUuZmx1c2hEYXRhLnN0b3JhZ2VPcGVyYXRpb25zLmxlbmd0aCA+IDApIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzLnB1c2goe1xuICAgICAgICAgICAgICAgIHR5cGU6IENsaWVudE1lc3NhZ2VUeXBlLlVwZGF0ZVN0b3JhZ2UsXG4gICAgICAgICAgICAgICAgb3BzOiBzdGF0ZS5mbHVzaERhdGEuc3RvcmFnZU9wZXJhdGlvbnMsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbWVzc2FnZXM7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc2Nvbm5lY3QoKSB7XG4gICAgICAgIGlmIChzdGF0ZS5zb2NrZXQpIHtcbiAgICAgICAgICAgIHN0YXRlLnNvY2tldC5yZW1vdmVFdmVudExpc3RlbmVyKFwib3BlblwiLCBvbk9wZW4pO1xuICAgICAgICAgICAgc3RhdGUuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJtZXNzYWdlXCIsIG9uTWVzc2FnZSk7XG4gICAgICAgICAgICBzdGF0ZS5zb2NrZXQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImNsb3NlXCIsIG9uQ2xvc2UpO1xuICAgICAgICAgICAgc3RhdGUuc29ja2V0LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbkVycm9yKTtcbiAgICAgICAgICAgIHN0YXRlLnNvY2tldC5jbG9zZSgpO1xuICAgICAgICAgICAgc3RhdGUuc29ja2V0ID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICB1cGRhdGVDb25uZWN0aW9uKHsgc3RhdGU6IFwiY2xvc2VkXCIgfSk7XG4gICAgICAgIGlmIChzdGF0ZS50aW1lb3V0SGFuZGxlcy5mbHVzaCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRIYW5kbGVzLmZsdXNoKTtcbiAgICAgICAgfVxuICAgICAgICBjbGVhclRpbWVvdXQoc3RhdGUudGltZW91dEhhbmRsZXMucmVjb25uZWN0KTtcbiAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlLnRpbWVvdXRIYW5kbGVzLnBvbmdUaW1lb3V0KTtcbiAgICAgICAgY2xlYXJJbnRlcnZhbChzdGF0ZS5pbnRlcnZhbEhhbmRsZXMuaGVhcnRiZWF0KTtcbiAgICAgICAgc3RhdGUudXNlcnMgPSB7fTtcbiAgICAgICAgdXBkYXRlVXNlcnMoeyB0eXBlOiBcInJlc2V0XCIgfSk7XG4gICAgICAgIGNsZWFyTGlzdGVuZXJzKCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFyTGlzdGVuZXJzKCkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBzdGF0ZS5saXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIHN0YXRlLmxpc3RlbmVyc1trZXldID0gW107XG4gICAgICAgIH1cbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0UHJlc2VuY2UoKSB7XG4gICAgICAgIHJldHVybiBzdGF0ZS5tZTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZ2V0T3RoZXJzKCkge1xuICAgICAgICByZXR1cm4gc3RhdGUub3RoZXJzO1xuICAgIH1cbiAgICBmdW5jdGlvbiBicm9hZGNhc3RFdmVudChldmVudCkge1xuICAgICAgICBpZiAoc3RhdGUuc29ja2V0ID09IG51bGwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBzdGF0ZS5mbHVzaERhdGEubWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBDbGllbnRNZXNzYWdlVHlwZS5DbGllbnRFdmVudCxcbiAgICAgICAgICAgIGV2ZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgdHJ5Rmx1c2hpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU1RPUkFHRVxuICAgICAqL1xuICAgIGZ1bmN0aW9uIG9uU3RvcmFnZVVwZGF0ZXMobWVzc2FnZSkge1xuICAgICAgICBpZiAoc3RhdGUuZG9jID09IG51bGwpIHtcbiAgICAgICAgICAgIC8vIFRPRE86IENhY2hlIHVwZGF0ZXMgaW4gY2FzZSB0aGV5IGFyZSBjb21pbmcgd2hpbGUgcm9vdCBpcyBxdWVyaWVkXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdXBkYXRlRG9jKG1lc3NhZ2Uub3BzLnJlZHVjZSgoZG9jLCBvcCkgPT4gZG9jLmRpc3BhdGNoKG9wKSwgc3RhdGUuZG9jKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHVwZGF0ZURvYyhkb2MpIHtcbiAgICAgICAgc3RhdGUuZG9jID0gZG9jO1xuICAgICAgICBpZiAoZG9jKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHN0YXRlLmxpc3RlbmVycy5zdG9yYWdlKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXIoZ2V0U3RvcmFnZSgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBmdW5jdGlvbiBnZXRTdG9yYWdlKCkge1xuICAgICAgICBpZiAoc3RhdGUuc3RvcmFnZVN0YXRlID09PSBMaXZlU3RvcmFnZVN0YXRlLkxvYWRlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogc3RhdGUuc3RvcmFnZVN0YXRlLFxuICAgICAgICAgICAgICAgIHJvb3Q6IHN0YXRlLmRvYy5yb290LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgc3RhdGU6IHN0YXRlLnN0b3JhZ2VTdGF0ZSxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgZnVuY3Rpb24gb25Jbml0aWFsU3RvcmFnZVN0YXRlKG1lc3NhZ2UpIHtcbiAgICAgICAgc3RhdGUuc3RvcmFnZVN0YXRlID0gTGl2ZVN0b3JhZ2VTdGF0ZS5Mb2FkZWQ7XG4gICAgICAgIGlmIChtZXNzYWdlLnJvb3QgPT0gbnVsbCkge1xuICAgICAgICAgICAgY29uc3Qgcm9vdElkID0gbWFrZUlkKCk7XG4gICAgICAgICAgICBzdGF0ZS5kb2MgPSBEb2MuZW1wdHkocm9vdElkLCAob3ApID0+IGRpc3BhdGNoKG9wKSk7XG4gICAgICAgICAgICB1cGRhdGVEb2Moc3RhdGUuZG9jLnVwZGF0ZVJlY29yZChyb290SWQsIHN0YXRlLmluaXRpYWxTdG9yYWdlRmFjdG9yeSh7XG4gICAgICAgICAgICAgICAgY3JlYXRlUmVjb3JkOiAoZGF0YSkgPT4gY3JlYXRlUmVjb3JkKGRhdGEpLFxuICAgICAgICAgICAgICAgIGNyZWF0ZUxpc3Q6ICgpID0+IGNyZWF0ZUxpc3QoKSxcbiAgICAgICAgICAgIH0pKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB1cGRhdGVEb2MoRG9jLmxvYWQobWVzc2FnZS5yb290LCAob3ApID0+IGRpc3BhdGNoKG9wKSkpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1ha2VJZCgpIHtcbiAgICAgICAgaWYgKHN0YXRlLmlkRmFjdG9yeSA9PSBudWxsKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW4ndCBnZW5lcmF0ZSBpZC4gSWQgZmFjdG9yeSBpcyBtaXNzaW5nLlwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RhdGUuaWRGYWN0b3J5KCk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGRpc3BhdGNoKG9wKSB7XG4gICAgICAgIHN0YXRlLmZsdXNoRGF0YS5zdG9yYWdlT3BlcmF0aW9ucy5wdXNoKG9wKTtcbiAgICAgICAgdHJ5Rmx1c2hpbmcoKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlUmVjb3JkKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyQ3JlYXRlUmVjb3JkKG1ha2VJZCgpLCBkYXRhKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gY3JlYXRlTGlzdCgpIHtcbiAgICAgICAgcmV0dXJuIGlubmVyQ3JlYXRlTGlzdChtYWtlSWQoKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGZldGNoU3RvcmFnZShpbml0aWFsU3RvcmFnZUZhY3RvcnkpIHtcbiAgICAgICAgc3RhdGUuaW5pdGlhbFN0b3JhZ2VGYWN0b3J5ID0gaW5pdGlhbFN0b3JhZ2VGYWN0b3J5O1xuICAgICAgICBzdGF0ZS5zdG9yYWdlU3RhdGUgPSBMaXZlU3RvcmFnZVN0YXRlLkxvYWRpbmc7XG4gICAgICAgIHN0YXRlLmZsdXNoRGF0YS5tZXNzYWdlcy5wdXNoKHsgdHlwZTogQ2xpZW50TWVzc2FnZVR5cGUuRmV0Y2hTdG9yYWdlIH0pO1xuICAgICAgICB0cnlGbHVzaGluZygpO1xuICAgIH1cbiAgICBmdW5jdGlvbiB1cGRhdGVSZWNvcmQocmVjb3JkLCBvdmVycmlkZXMpIHtcbiAgICAgICAgdXBkYXRlRG9jKHN0YXRlLmRvYy51cGRhdGVSZWNvcmQocmVjb3JkLmlkLCBvdmVycmlkZXMpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gcHVzaEl0ZW0obGlzdCwgaXRlbSkge1xuICAgICAgICB1cGRhdGVEb2Moc3RhdGUuZG9jLnB1c2hJdGVtKGxpc3QuaWQsIGl0ZW0pKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVsZXRlSXRlbShsaXN0LCBpbmRleCkge1xuICAgICAgICB1cGRhdGVEb2Moc3RhdGUuZG9jLmRlbGV0ZUl0ZW0obGlzdC5pZCwgaW5kZXgpKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gZGVsZXRlSXRlbUJ5SWQobGlzdCwgaXRlbUlkKSB7XG4gICAgICAgIHVwZGF0ZURvYyhzdGF0ZS5kb2MuZGVsZXRlSXRlbUJ5SWQobGlzdC5pZCwgaXRlbUlkKSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIG1vdmVJdGVtKGxpc3QsIGluZGV4LCB0YXJnZXRJbmRleCkge1xuICAgICAgICB1cGRhdGVEb2Moc3RhdGUuZG9jLm1vdmVJdGVtKGxpc3QuaWQsIGluZGV4LCB0YXJnZXRJbmRleCkpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICAvLyBJbnRlcm5hbFxuICAgICAgICBvbk9wZW4sXG4gICAgICAgIG9uQ2xvc2UsXG4gICAgICAgIG9uTWVzc2FnZSxcbiAgICAgICAgYXV0aGVudGljYXRpb25TdWNjZXNzLFxuICAgICAgICBoZWFydGJlYXQsXG4gICAgICAgIG9uTmF2aWdhdG9yT25saW5lLFxuICAgICAgICAvLyBvbldha2VVcCxcbiAgICAgICAgb25WaXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgICAvLyBDb3JlXG4gICAgICAgIGNvbm5lY3QsXG4gICAgICAgIGRpc2Nvbm5lY3QsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgICAgIC8vIFByZXNlbmNlXG4gICAgICAgIHVwZGF0ZVByZXNlbmNlLFxuICAgICAgICBicm9hZGNhc3RFdmVudCxcbiAgICAgICAgLy8gU3RvcmFnZVxuICAgICAgICBmZXRjaFN0b3JhZ2UsXG4gICAgICAgIGNyZWF0ZVJlY29yZCxcbiAgICAgICAgdXBkYXRlUmVjb3JkLFxuICAgICAgICBjcmVhdGVMaXN0LFxuICAgICAgICBwdXNoSXRlbSxcbiAgICAgICAgZGVsZXRlSXRlbSxcbiAgICAgICAgZGVsZXRlSXRlbUJ5SWQsXG4gICAgICAgIG1vdmVJdGVtLFxuICAgICAgICBzZWxlY3RvcnM6IHtcbiAgICAgICAgICAgIC8vIENvcmVcbiAgICAgICAgICAgIGdldENvbm5lY3Rpb25TdGF0ZSxcbiAgICAgICAgICAgIGdldFNlbGYsXG4gICAgICAgICAgICAvLyBQcmVzZW5jZVxuICAgICAgICAgICAgZ2V0UHJlc2VuY2UsXG4gICAgICAgICAgICBnZXRPdGhlcnMsXG4gICAgICAgICAgICAvLyBTdG9yYWdlXG4gICAgICAgICAgICBnZXRTdG9yYWdlLFxuICAgICAgICB9LFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gZGVmYXVsdFN0YXRlKG1lKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdGlvbjogeyBzdGF0ZTogXCJjbG9zZWRcIiB9LFxuICAgICAgICBzb2NrZXQ6IG51bGwsXG4gICAgICAgIGxpc3RlbmVyczoge1xuICAgICAgICAgICAgc3RvcmFnZTogW10sXG4gICAgICAgICAgICBldmVudDogW10sXG4gICAgICAgICAgICBvdGhlcnM6IFtdLFxuICAgICAgICAgICAgXCJteS1wcmVzZW5jZVwiOiBbXSxcbiAgICAgICAgICAgIGVycm9yOiBbXSxcbiAgICAgICAgICAgIGNvbm5lY3Rpb246IFtdLFxuICAgICAgICB9LFxuICAgICAgICBudW1iZXJPZlJldHJ5OiAwLFxuICAgICAgICBsYXN0Rmx1c2hUaW1lOiAwLFxuICAgICAgICB0aW1lb3V0SGFuZGxlczoge1xuICAgICAgICAgICAgZmx1c2g6IG51bGwsXG4gICAgICAgICAgICByZWNvbm5lY3Q6IDAsXG4gICAgICAgICAgICBwb25nVGltZW91dDogMCxcbiAgICAgICAgfSxcbiAgICAgICAgZmx1c2hEYXRhOiB7XG4gICAgICAgICAgICBwcmVzZW5jZTogbWUgPT0gbnVsbCA/IHt9IDogbWUsXG4gICAgICAgICAgICBtZXNzYWdlczogW10sXG4gICAgICAgICAgICBzdG9yYWdlT3BlcmF0aW9uczogW10sXG4gICAgICAgIH0sXG4gICAgICAgIGludGVydmFsSGFuZGxlczoge1xuICAgICAgICAgICAgaGVhcnRiZWF0OiAwLFxuICAgICAgICB9LFxuICAgICAgICBtZTogbWUgPT0gbnVsbCA/IHt9IDogbWUsXG4gICAgICAgIHVzZXJzOiB7fSxcbiAgICAgICAgb3RoZXJzOiBtYWtlT3RoZXJzKHt9KSxcbiAgICAgICAgc3RvcmFnZVN0YXRlOiBMaXZlU3RvcmFnZVN0YXRlLk5vdEluaXRpYWxpemVkLFxuICAgICAgICBpbml0aWFsU3RvcmFnZUZhY3Rvcnk6IG51bGwsXG4gICAgICAgIGRvYzogbnVsbCxcbiAgICAgICAgaWRGYWN0b3J5OiBudWxsLFxuICAgIH07XG59XG5leHBvcnQgZnVuY3Rpb24gY3JlYXRlUm9vbShuYW1lLCBvcHRpb25zKSB7XG4gICAgY29uc3QgdGhyb3R0bGVEZWxheSA9IG9wdGlvbnMudGhyb3R0bGUgfHwgMTAwO1xuICAgIGNvbnN0IGxpdmVibG9ja3NTZXJ2ZXIgPSBvcHRpb25zLmxpdmVibG9ja3NTZXJ2ZXIgfHwgXCJ3c3M6Ly9saXZlYmxvY2tzLm5ldFwiO1xuICAgIGNvbnN0IGF1dGhFbmRwb2ludCA9IG9wdGlvbnMuYXV0aEVuZHBvaW50O1xuICAgIGNvbnN0IHN0YXRlID0gZGVmYXVsdFN0YXRlKG9wdGlvbnMuaW5pdGlhbFByZXNlbmNlKTtcbiAgICBjb25zdCBtYWNoaW5lID0gbWFrZVN0YXRlTWFjaGluZShzdGF0ZSwge1xuICAgICAgICB0aHJvdHRsZURlbGF5LFxuICAgICAgICBsaXZlYmxvY2tzU2VydmVyLFxuICAgICAgICBhdXRoRW5kcG9pbnQsXG4gICAgICAgIHJvb206IG5hbWUsXG4gICAgfSk7XG4gICAgY29uc3Qgcm9vbSA9IHtcbiAgICAgICAgLy8vLy8vLy8vLy8vL1xuICAgICAgICAvLyBDb3JlICAgIC8vXG4gICAgICAgIC8vLy8vLy8vLy8vLy9cbiAgICAgICAgZ2V0Q29ubmVjdGlvblN0YXRlOiBtYWNoaW5lLnNlbGVjdG9ycy5nZXRDb25uZWN0aW9uU3RhdGUsXG4gICAgICAgIGdldFNlbGY6IG1hY2hpbmUuc2VsZWN0b3JzLmdldFNlbGYsXG4gICAgICAgIHN1YnNjcmliZTogbWFjaGluZS5zdWJzY3JpYmUsXG4gICAgICAgIHVuc3Vic2NyaWJlOiBtYWNoaW5lLnVuc3Vic2NyaWJlLFxuICAgICAgICAvLy8vLy8vLy8vLy8vXG4gICAgICAgIC8vIFN0b3JhZ2UgLy9cbiAgICAgICAgLy8vLy8vLy8vLy8vL1xuICAgICAgICBnZXRTdG9yYWdlOiBtYWNoaW5lLnNlbGVjdG9ycy5nZXRTdG9yYWdlLFxuICAgICAgICBmZXRjaFN0b3JhZ2U6IG1hY2hpbmUuZmV0Y2hTdG9yYWdlLFxuICAgICAgICBjcmVhdGVSZWNvcmQ6IG1hY2hpbmUuY3JlYXRlUmVjb3JkLFxuICAgICAgICBjcmVhdGVMaXN0OiBtYWNoaW5lLmNyZWF0ZUxpc3QsXG4gICAgICAgIHVwZGF0ZVJlY29yZDogbWFjaGluZS51cGRhdGVSZWNvcmQsXG4gICAgICAgIHB1c2hJdGVtOiBtYWNoaW5lLnB1c2hJdGVtLFxuICAgICAgICBkZWxldGVJdGVtOiBtYWNoaW5lLmRlbGV0ZUl0ZW0sXG4gICAgICAgIGRlbGV0ZUl0ZW1CeUlkOiBtYWNoaW5lLmRlbGV0ZUl0ZW1CeUlkLFxuICAgICAgICBtb3ZlSXRlbTogbWFjaGluZS5tb3ZlSXRlbSxcbiAgICAgICAgLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgLy8gUHJlc2VuY2UgLy9cbiAgICAgICAgLy8vLy8vLy8vLy8vLy9cbiAgICAgICAgZ2V0UHJlc2VuY2U6IG1hY2hpbmUuc2VsZWN0b3JzLmdldFByZXNlbmNlLFxuICAgICAgICB1cGRhdGVQcmVzZW5jZTogbWFjaGluZS51cGRhdGVQcmVzZW5jZSxcbiAgICAgICAgZ2V0T3RoZXJzOiBtYWNoaW5lLnNlbGVjdG9ycy5nZXRPdGhlcnMsXG4gICAgICAgIGJyb2FkY2FzdEV2ZW50OiBtYWNoaW5lLmJyb2FkY2FzdEV2ZW50LFxuICAgIH07XG4gICAgcmV0dXJuIHtcbiAgICAgICAgY29ubmVjdDogbWFjaGluZS5jb25uZWN0LFxuICAgICAgICBkaXNjb25uZWN0OiBtYWNoaW5lLmRpc2Nvbm5lY3QsXG4gICAgICAgIG9uTmF2aWdhdG9yT25saW5lOiBtYWNoaW5lLm9uTmF2aWdhdG9yT25saW5lLFxuICAgICAgICBvblZpc2liaWxpdHlDaGFuZ2U6IG1hY2hpbmUub25WaXNpYmlsaXR5Q2hhbmdlLFxuICAgICAgICByb29tLFxuICAgIH07XG59XG5jbGFzcyBMaXZlYmxvY2tzRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSwgY29kZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5jb2RlID0gY29kZTtcbiAgICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/room.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/types.js":
/*!**********************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/types.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LiveStorageState\": function() { return /* binding */ LiveStorageState; }\n/* harmony export */ });\nvar LiveStorageState;\n(function (LiveStorageState) {\n    LiveStorageState[LiveStorageState[\"NotInitialized\"] = 0] = \"NotInitialized\";\n    LiveStorageState[LiveStorageState[\"Loading\"] = 1] = \"Loading\";\n    LiveStorageState[LiveStorageState[\"Loaded\"] = 2] = \"Loaded\";\n})(LiveStorageState || (LiveStorageState = {}));\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vdHlwZXMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDRDQUE0QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vdHlwZXMuanM/MDZmOSJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgdmFyIExpdmVTdG9yYWdlU3RhdGU7XG4oZnVuY3Rpb24gKExpdmVTdG9yYWdlU3RhdGUpIHtcbiAgICBMaXZlU3RvcmFnZVN0YXRlW0xpdmVTdG9yYWdlU3RhdGVbXCJOb3RJbml0aWFsaXplZFwiXSA9IDBdID0gXCJOb3RJbml0aWFsaXplZFwiO1xuICAgIExpdmVTdG9yYWdlU3RhdGVbTGl2ZVN0b3JhZ2VTdGF0ZVtcIkxvYWRpbmdcIl0gPSAxXSA9IFwiTG9hZGluZ1wiO1xuICAgIExpdmVTdG9yYWdlU3RhdGVbTGl2ZVN0b3JhZ2VTdGF0ZVtcIkxvYWRlZFwiXSA9IDJdID0gXCJMb2FkZWRcIjtcbn0pKExpdmVTdG9yYWdlU3RhdGUgfHwgKExpdmVTdG9yYWdlU3RhdGUgPSB7fSkpO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/types.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/client/lib/esm/utils.js":
/*!**********************************************************!*\
  !*** ./node_modules/@liveblocks/client/lib/esm/utils.js ***!
  \**********************************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"remove\": function() { return /* binding */ remove; }\n/* harmony export */ });\nfunction remove(array, item) {\n    for (let i = 0; i < array.length; i++) {\n        if (array[i] === item) {\n            array.splice(i, 1);\n            break;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvY2xpZW50L2xpYi9lc20vdXRpbHMuanMuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFPO0FBQ1Asb0JBQW9CLGtCQUFrQjtBQUN0QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL2NsaWVudC9saWIvZXNtL3V0aWxzLmpzP2Q0ODAiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIHJlbW92ZShhcnJheSwgaXRlbSkge1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgaWYgKGFycmF5W2ldID09PSBpdGVtKSB7XG4gICAgICAgICAgICBhcnJheS5zcGxpY2UoaSwgMSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/client/lib/esm/utils.js\n");

/***/ }),

/***/ "./node_modules/@liveblocks/react/lib/index.js":
/*!*****************************************************!*\
  !*** ./node_modules/@liveblocks/react/lib/index.js ***!
  \*****************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

eval("Object.defineProperty(exports, \"__esModule\", ({ value: true }));\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n\nvar ServerMessageType;\n(function (ServerMessageType) {\n    ServerMessageType[ServerMessageType[\"UpdatePresence\"] = 100] = \"UpdatePresence\";\n    ServerMessageType[ServerMessageType[\"UserJoined\"] = 101] = \"UserJoined\";\n    ServerMessageType[ServerMessageType[\"UserLeft\"] = 102] = \"UserLeft\";\n    ServerMessageType[ServerMessageType[\"Event\"] = 103] = \"Event\";\n    ServerMessageType[ServerMessageType[\"RoomState\"] = 104] = \"RoomState\";\n    ServerMessageType[ServerMessageType[\"InitialStorageState\"] = 200] = \"InitialStorageState\";\n    ServerMessageType[ServerMessageType[\"UpdateStorage\"] = 201] = \"UpdateStorage\";\n})(ServerMessageType || (ServerMessageType = {}));\nvar ClientMessageType;\n(function (ClientMessageType) {\n    ClientMessageType[ClientMessageType[\"UpdatePresence\"] = 100] = \"UpdatePresence\";\n    ClientMessageType[ClientMessageType[\"ClientEvent\"] = 103] = \"ClientEvent\";\n    ClientMessageType[ClientMessageType[\"FetchStorage\"] = 200] = \"FetchStorage\";\n    ClientMessageType[ClientMessageType[\"UpdateStorage\"] = 201] = \"UpdateStorage\";\n})(ClientMessageType || (ClientMessageType = {}));\nvar CrdtType;\n(function (CrdtType) {\n    CrdtType[CrdtType[\"Record\"] = 0] = \"Record\";\n    CrdtType[CrdtType[\"List\"] = 1] = \"List\";\n    CrdtType[CrdtType[\"Register\"] = 2] = \"Register\";\n})(CrdtType || (CrdtType = {}));\nvar OpType;\n(function (OpType) {\n    OpType[OpType[\"Init\"] = 100] = \"Init\";\n    OpType[OpType[\"ListInsert\"] = 200] = \"ListInsert\";\n    OpType[OpType[\"ListMove\"] = 201] = \"ListMove\";\n    OpType[OpType[\"ListRemove\"] = 202] = \"ListRemove\";\n    OpType[OpType[\"RecordUpdate\"] = 300] = \"RecordUpdate\";\n})(OpType || (OpType = {}));\nvar WebsocketCloseCodes;\n(function (WebsocketCloseCodes) {\n    WebsocketCloseCodes[WebsocketCloseCodes[\"CLOSE_ABNORMAL\"] = 1006] = \"CLOSE_ABNORMAL\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"INVALID_MESSAGE_FORMAT\"] = 4000] = \"INVALID_MESSAGE_FORMAT\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"NOT_ALLOWED\"] = 4001] = \"NOT_ALLOWED\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\"] = 4002] = \"MAX_NUMBER_OF_MESSAGES_PER_SECONDS\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\"] = 4003] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\"] = 4004] = \"MAX_NUMBER_OF_MESSAGES_PER_DAY_PER_APP\";\n    WebsocketCloseCodes[WebsocketCloseCodes[\"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\"] = 4005] = \"MAX_NUMBER_OF_CONCURRENT_CONNECTIONS_PER_ROOM\";\n})(WebsocketCloseCodes || (WebsocketCloseCodes = {}));\n\nvar LiveStorageState;\n(function (LiveStorageState) {\n    LiveStorageState[LiveStorageState[\"NotInitialized\"] = 0] = \"NotInitialized\";\n    LiveStorageState[LiveStorageState[\"Loading\"] = 1] = \"Loading\";\n    LiveStorageState[LiveStorageState[\"Loaded\"] = 2] = \"Loaded\";\n})(LiveStorageState || (LiveStorageState = {}));\n\n( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n( false) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\nvar ClientContext = React.createContext(null);\r\nvar RoomContext = React.createContext(null);\r\n/**\r\n * Makes the Liveblocks client available in the component hierarchy below.\r\n */\r\nfunction LiveblocksProvider(props) {\r\n    return (React.createElement(ClientContext.Provider, { value: props.client }, props.children));\r\n}\r\n/**\r\n * Returns the client of the nearest LiveblocksProvider above in the react component tree\r\n */\r\nfunction useClient() {\r\n    var client = React.useContext(ClientContext);\r\n    if (client == null) {\r\n        throw new Error(\"LiveblocksProvider is missing from the react tree\");\r\n    }\r\n    return client;\r\n}\r\n/**\r\n * Makes a Room available in the component hierarchy below.\r\n * When this component is unmounted, the current user leave the room.\r\n * That means that you can't have 2 RoomProvider with the same room id in your react tree.\r\n */\r\nfunction RoomProvider(_a) {\r\n    var id = _a.id, children = _a.children, defaultPresence = _a.defaultPresence;\r\n    var client = useClient();\r\n    React.useEffect(function () {\r\n        return function () {\r\n            client.leave(id);\r\n        };\r\n    }, [client, id]);\r\n    var room = client.getRoom(id) ||\r\n        client.enter(id, defaultPresence ? defaultPresence() : undefined);\r\n    return React.createElement(RoomContext.Provider, { value: room }, children);\r\n}\r\n/**\r\n * Returns the room of the nearest RoomProvider above in the react component tree\r\n */\r\nfunction useRoom() {\r\n    var room = React.useContext(RoomContext);\r\n    if (room == null) {\r\n        throw new Error(\"RoomProvider is missing from the react tree\");\r\n    }\r\n    return room;\r\n}\r\n/**\r\n * Returns the presence of the current user of the current room, and a function to update it.\r\n * It is different from the setState function returned by the useState hook from React.\r\n * You don't need to pass the full presence object to update it.\r\n *\r\n * ### Example\r\n * ``` typescript\r\n * import { useMyPresence } from \"@liveblocks/react\";\r\n *\r\n * const [myPresence, updateMyPresence] = useMyPresence();\r\n * updateMyPresence({ x: 0 });\r\n * updateMyPresence({ y: 0 });\r\n *\r\n * // At the next render, \"myPresence\" will be equal to \"{ x: 0, y: 0 }\"\r\n * ```\r\n */\r\nfunction useMyPresence() {\r\n    var room = useRoom();\r\n    var presence = room.getPresence();\r\n    var _a = React.useState(0), update = _a[1];\r\n    React.useEffect(function () {\r\n        function onMyPresenceChange() {\r\n            update(function (x) { return x + 1; });\r\n        }\r\n        room.subscribe(\"my-presence\", onMyPresenceChange);\r\n        return function () {\r\n            room.unsubscribe(\"my-presence\", onMyPresenceChange);\r\n        };\r\n    }, [room]);\r\n    var setPresence = React.useCallback(function (overrides) { return room.updatePresence(overrides); }, [room]);\r\n    return [presence, setPresence];\r\n}\r\n/**\r\n * useUpdateMyPresence is similar to useMyPresence but it only returns the function to update the current user presence.\r\n * If you don't use the current user presence in your component, but you need to update it (e.g. live cursor), it's better to use useUpdateMyPresence to avoid unnecessary renders.\r\n *\r\n * ### Example\r\n * ``` typescript\r\n * import { useUpdateMyPresence } from \"@liveblocks/react\";\r\n *\r\n * const updateMyPresence = useUpdateMyPresence();\r\n * updateMyPresence({ x: 0 });\r\n * updateMyPresence({ y: 0 });\r\n *\r\n * // At the next render, the presence of the current user will be equal to \"{ x: 0, y: 0 }\"\r\n * ```\r\n */\r\nfunction useUpdateMyPresence() {\r\n    var room = useRoom();\r\n    return React.useCallback(function (overrides) {\r\n        room.updatePresence(overrides);\r\n    }, [room]);\r\n}\r\n/**\r\n * Returns an object that lets you get information about all the the users currently connected in the room.\r\n *\r\n * ### Example\r\n * ``` typescript\r\n * import { useOthers } from \"@liveblocks/react\";\r\n *\r\n * const others = useOthers();\r\n *\r\n * // Example to map all cursors in jsx\r\n * {\r\n *   others.map(({ connectionId, presence }) => {\r\n *     if(presence == null || presence.cursor == null) {\r\n *       return null;\r\n *     }\r\n *     return <Cursor key={connectionId} cursor={presence.cursor} />\r\n *   })\r\n * }\r\n * ```\r\n */\r\nfunction useOthers() {\r\n    var room = useRoom();\r\n    var _a = React.useState(0), update = _a[1];\r\n    React.useEffect(function () {\r\n        function onOthersChange() {\r\n            update(function (x) { return x + 1; });\r\n        }\r\n        room.subscribe(\"others\", onOthersChange);\r\n        return function () {\r\n            room.subscribe(\"others\", onOthersChange);\r\n        };\r\n    }, [room]);\r\n    return room.getOthers();\r\n}\r\n/**\r\n * Returns a callback that lets you broadcast custom events to other users in the room\r\n *\r\n * ### Example\r\n * ``` typescript\r\n * import { useBroadcastEvent } from \"@liveblocks/react\";\r\n *\r\n * const broadcast = useBroadcastEvent();\r\n *\r\n * broadcast({ type: \"CUSTOM_EVENT\", data: { x: 0, y: 0 } });\r\n * ```\r\n */\r\nfunction useBroadcastEvent() {\r\n    var room = useRoom();\r\n    return React.useCallback(function (event) {\r\n        room.broadcastEvent(event);\r\n    }, [room]);\r\n}\r\n/**\r\n * useErrorListener is a react hook that lets you react to potential room connection errors.\r\n *\r\n * ### Example\r\n * ``` typescript\r\n * import { useErrorListener } from \"@liveblocks/react\";\r\n *\r\n * useErrorListener(er => {\r\n *   console.error(er);\r\n * })\r\n * ```\r\n */\r\nfunction useErrorListener(callback) {\r\n    var room = useRoom();\r\n    var savedCallback = React.useRef(callback);\r\n    React.useEffect(function () {\r\n        savedCallback.current = callback;\r\n    });\r\n    React.useEffect(function () {\r\n        var listener = function (e) { return savedCallback.current(e); };\r\n        room.subscribe(\"error\", listener);\r\n        return function () {\r\n            room.unsubscribe(\"error\", listener);\r\n        };\r\n    }, [room]);\r\n}\r\n/**\r\n * useEventListener is a react hook that lets you react to event broadcasted by other users in the room.\r\n *\r\n * ### Example\r\n * ``` typescript\r\n * import { useEventListener } from \"@liveblocks/react\";\r\n *\r\n * useEventListener(({ connectionId, event }) => {\r\n *   if (event.type === \"CUSTOM_EVENT\") {\r\n *     // Do something\r\n *   }\r\n * });\r\n * ```\r\n */\r\nfunction useEventListener(callback) {\r\n    var room = useRoom();\r\n    var savedCallback = React.useRef(callback);\r\n    React.useEffect(function () {\r\n        savedCallback.current = callback;\r\n    });\r\n    React.useEffect(function () {\r\n        var listener = function (e) {\r\n            return savedCallback.current(e);\r\n        };\r\n        room.subscribe(\"event\", listener);\r\n        return function () {\r\n            room.unsubscribe(\"event\", listener);\r\n        };\r\n    }, [room]);\r\n}\r\n/**\r\n * Gets the current user once it is connected to the room.\r\n *\r\n * ### Example\r\n * ``` typescript\r\n * import { useSelf } from \"@liveblocks/react\";\r\n *\r\n * const user = useSelf();\r\n * ```\r\n */\r\nfunction useSelf() {\r\n    var room = useRoom();\r\n    var _a = React.useState(0), update = _a[1];\r\n    React.useEffect(function () {\r\n        function onChange() {\r\n            update(function (x) { return x + 1; });\r\n        }\r\n        room.subscribe(\"my-presence\", onChange);\r\n        room.subscribe(\"connection\", onChange);\r\n        return function () {\r\n            room.unsubscribe(\"my-presence\", onChange);\r\n            room.unsubscribe(\"connection\", onChange);\r\n        };\r\n    }, [room]);\r\n    return room.getSelf();\r\n}\r\nfunction useStorage(initialStorage) {\r\n    var room = useRoom();\r\n    var storage = room.getStorage();\r\n    var _a = React.useState(0), update = _a[1];\r\n    React.useEffect(function () {\r\n        function onStorageChange() {\r\n            update(function (x) { return x + 1; });\r\n        }\r\n        room.fetchStorage(initialStorage);\r\n        room.subscribe(\"storage\", onStorageChange);\r\n        return function () {\r\n            room.unsubscribe(\"storage\", onStorageChange);\r\n        };\r\n    }, [room]);\r\n    var root = storage.state === LiveStorageState.Loaded\r\n        ? storage.root\r\n        : null;\r\n    var actions = useStorageActions();\r\n    return [root, actions];\r\n}\r\nfunction useStorageActions() {\r\n    var room = useRoom();\r\n    return React.useMemo(function () {\r\n        function createRecord(data) {\r\n            return room.createRecord(data);\r\n        }\r\n        function updateRecord(record, overrides) {\r\n            return room.updateRecord(record, overrides);\r\n        }\r\n        function createList() {\r\n            return room.createList();\r\n        }\r\n        function moveItem(list, index, targetIndex) {\r\n            return room.moveItem(list, index, targetIndex);\r\n        }\r\n        function deleteItem(list, index) {\r\n            return room.deleteItem(list, index);\r\n        }\r\n        function deleteItemById(list, itemId) {\r\n            return room.deleteItemById(list, itemId);\r\n        }\r\n        function pushItem(list, item) {\r\n            return room.pushItem(list, item);\r\n        }\r\n        return {\r\n            createRecord: createRecord,\r\n            updateRecord: updateRecord,\r\n            createList: createList,\r\n            moveItem: moveItem,\r\n            deleteItem: deleteItem,\r\n            deleteItemById: deleteItemById,\r\n            pushItem: pushItem,\r\n        };\r\n    }, [room]);\r\n}\n\nexports.LiveblocksProvider = LiveblocksProvider;\nexports.RoomProvider = RoomProvider;\nexports.useBroadcastEvent = useBroadcastEvent;\nexports.useErrorListener = useErrorListener;\nexports.useEventListener = useEventListener;\nexports.useMyPresence = useMyPresence;\nexports.useOthers = useOthers;\nexports.useSelf = useSelf;\nexports.useStorage = useStorage;\nexports.useStorageActions = useStorageActions;\nexports.useUpdateMyPresence = useUpdateMyPresence;\n//# sourceMappingURL=index.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvQGxpdmVibG9ja3MvcmVhY3QvbGliL2luZGV4LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBLDhDQUE2QyxFQUFFLGFBQWEsRUFBQzs7QUFFN0QsWUFBWSxtQkFBTyxDQUFDLDRDQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLDhDQUE4QztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyw0QkFBNEI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLHdCQUF3QjtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGtEQUFrRDs7QUFFbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsNENBQTRDOztBQUU3QyxDQUFDLE1BQWdDO0FBQ2pDLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMOztBQUVBLENBQUMsTUFBZ0M7QUFDakMsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELHFCQUFxQjtBQUMvRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFD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a0JBQWtCO0FBQ2xCLHlCQUF5QjtBQUN6QiwyQkFBMkI7QUFDM0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BsaXZlYmxvY2tzL3JlYWN0L2xpYi9pbmRleC5qcz8xYzFkIl0sInNvdXJjZXNDb250ZW50IjpbIk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCAnX19lc01vZHVsZScsIHsgdmFsdWU6IHRydWUgfSk7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG5cbnZhciBTZXJ2ZXJNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoU2VydmVyTWVzc2FnZVR5cGUpIHtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtTZXJ2ZXJNZXNzYWdlVHlwZVtcIlVwZGF0ZVByZXNlbmNlXCJdID0gMTAwXSA9IFwiVXBkYXRlUHJlc2VuY2VcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtTZXJ2ZXJNZXNzYWdlVHlwZVtcIlVzZXJKb2luZWRcIl0gPSAxMDFdID0gXCJVc2VySm9pbmVkXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJVc2VyTGVmdFwiXSA9IDEwMl0gPSBcIlVzZXJMZWZ0XCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJFdmVudFwiXSA9IDEwM10gPSBcIkV2ZW50XCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJSb29tU3RhdGVcIl0gPSAxMDRdID0gXCJSb29tU3RhdGVcIjtcbiAgICBTZXJ2ZXJNZXNzYWdlVHlwZVtTZXJ2ZXJNZXNzYWdlVHlwZVtcIkluaXRpYWxTdG9yYWdlU3RhdGVcIl0gPSAyMDBdID0gXCJJbml0aWFsU3RvcmFnZVN0YXRlXCI7XG4gICAgU2VydmVyTWVzc2FnZVR5cGVbU2VydmVyTWVzc2FnZVR5cGVbXCJVcGRhdGVTdG9yYWdlXCJdID0gMjAxXSA9IFwiVXBkYXRlU3RvcmFnZVwiO1xufSkoU2VydmVyTWVzc2FnZVR5cGUgfHwgKFNlcnZlck1lc3NhZ2VUeXBlID0ge30pKTtcbnZhciBDbGllbnRNZXNzYWdlVHlwZTtcbihmdW5jdGlvbiAoQ2xpZW50TWVzc2FnZVR5cGUpIHtcbiAgICBDbGllbnRNZXNzYWdlVHlwZVtDbGllbnRNZXNzYWdlVHlwZVtcIlVwZGF0ZVByZXNlbmNlXCJdID0gMTAwXSA9IFwiVXBkYXRlUHJlc2VuY2VcIjtcbiAgICBDbGllbnRNZXNzYWdlVHlwZVtDbGllbnRNZXNzYWdlVHlwZVtcIkNsaWVudEV2ZW50XCJdID0gMTAzXSA9IFwiQ2xpZW50RXZlbnRcIjtcbiAgICBDbGllbnRNZXNzYWdlVHlwZVtDbGllbnRNZXNzYWdlVHlwZVtcIkZldGNoU3RvcmFnZVwiXSA9IDIwMF0gPSBcIkZldGNoU3RvcmFnZVwiO1xuICAgIENsaWVudE1lc3NhZ2VUeXBlW0NsaWVudE1lc3NhZ2VUeXBlW1wiVXBkYXRlU3RvcmFnZVwiXSA9IDIwMV0gPSBcIlVwZGF0ZVN0b3JhZ2VcIjtcbn0pKENsaWVudE1lc3NhZ2VUeXBlIHx8IChDbGllbnRNZXNzYWdlVHlwZSA9IHt9KSk7XG52YXIgQ3JkdFR5cGU7XG4oZnVuY3Rpb24gKENyZHRUeXBlKSB7XG4gICAgQ3JkdFR5cGVbQ3JkdFR5cGVbXCJSZWNvcmRcIl0gPSAwXSA9IFwiUmVjb3JkXCI7XG4gICAgQ3JkdFR5cGVbQ3JkdFR5cGVbXCJMaXN0XCJdID0gMV0gPSBcIkxpc3RcIjtcbiAgICBDcmR0VHlwZVtDcmR0VHlwZVtcIlJlZ2lzdGVyXCJdID0gMl0gPSBcIlJlZ2lzdGVyXCI7XG59KShDcmR0VHlwZSB8fCAoQ3JkdFR5cGUgPSB7fSkpO1xudmFyIE9wVHlwZTtcbihmdW5jdGlvbiAoT3BUeXBlKSB7XG4gICAgT3BUeXBlW09wVHlwZVtcIkluaXRcIl0gPSAxMDBdID0gXCJJbml0XCI7XG4gICAgT3BUeXBlW09wVHlwZVtcIkxpc3RJbnNlcnRcIl0gPSAyMDBdID0gXCJMaXN0SW5zZXJ0XCI7XG4gICAgT3BUeXBlW09wVHlwZVtcIkxpc3RNb3ZlXCJdID0gMjAxXSA9IFwiTGlzdE1vdmVcIjtcbiAgICBPcFR5cGVbT3BUeXBlW1wiTGlzdFJlbW92ZVwiXSA9IDIwMl0gPSBcIkxpc3RSZW1vdmVcIjtcbiAgICBPcFR5cGVbT3BUeXBlW1wiUmVjb3JkVXBkYXRlXCJdID0gMzAwXSA9IFwiUmVjb3JkVXBkYXRlXCI7XG59KShPcFR5cGUgfHwgKE9wVHlwZSA9IHt9KSk7XG52YXIgV2Vic29ja2V0Q2xvc2VDb2RlcztcbihmdW5jdGlvbiAoV2Vic29ja2V0Q2xvc2VDb2Rlcykge1xuICAgIFdlYnNvY2tldENsb3NlQ29kZXNbV2Vic29ja2V0Q2xvc2VDb2Rlc1tcIkNMT1NFX0FCTk9STUFMXCJdID0gMTAwNl0gPSBcIkNMT1NFX0FCTk9STUFMXCI7XG4gICAgV2Vic29ja2V0Q2xvc2VDb2Rlc1tXZWJzb2NrZXRDbG9zZUNvZGVzW1wiSU5WQUxJRF9NRVNTQUdFX0ZPUk1BVFwiXSA9IDQwMDBdID0gXCJJTlZBTElEX01FU1NBR0VfRk9STUFUXCI7XG4gICAgV2Vic29ja2V0Q2xvc2VDb2Rlc1tXZWJzb2NrZXRDbG9zZUNvZGVzW1wiTk9UX0FMTE9XRURcIl0gPSA0MDAxXSA9IFwiTk9UX0FMTE9XRURcIjtcbiAgICBXZWJzb2NrZXRDbG9zZUNvZGVzW1dlYnNvY2tldENsb3NlQ29kZXNbXCJNQVhfTlVNQkVSX09GX01FU1NBR0VTX1BFUl9TRUNPTkRTXCJdID0gNDAwMl0gPSBcIk1BWF9OVU1CRVJfT0ZfTUVTU0FHRVNfUEVSX1NFQ09ORFNcIjtcbiAgICBXZWJzb2NrZXRDbG9zZUNvZGVzW1dlYnNvY2tldENsb3NlQ29kZXNbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNcIl0gPSA0MDAzXSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TXCI7XG4gICAgV2Vic29ja2V0Q2xvc2VDb2Rlc1tXZWJzb2NrZXRDbG9zZUNvZGVzW1wiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIl0gPSA0MDA0XSA9IFwiTUFYX05VTUJFUl9PRl9NRVNTQUdFU19QRVJfREFZX1BFUl9BUFBcIjtcbiAgICBXZWJzb2NrZXRDbG9zZUNvZGVzW1dlYnNvY2tldENsb3NlQ29kZXNbXCJNQVhfTlVNQkVSX09GX0NPTkNVUlJFTlRfQ09OTkVDVElPTlNfUEVSX1JPT01cIl0gPSA0MDA1XSA9IFwiTUFYX05VTUJFUl9PRl9DT05DVVJSRU5UX0NPTk5FQ1RJT05TX1BFUl9ST09NXCI7XG59KShXZWJzb2NrZXRDbG9zZUNvZGVzIHx8IChXZWJzb2NrZXRDbG9zZUNvZGVzID0ge30pKTtcblxudmFyIExpdmVTdG9yYWdlU3RhdGU7XG4oZnVuY3Rpb24gKExpdmVTdG9yYWdlU3RhdGUpIHtcbiAgICBMaXZlU3RvcmFnZVN0YXRlW0xpdmVTdG9yYWdlU3RhdGVbXCJOb3RJbml0aWFsaXplZFwiXSA9IDBdID0gXCJOb3RJbml0aWFsaXplZFwiO1xuICAgIExpdmVTdG9yYWdlU3RhdGVbTGl2ZVN0b3JhZ2VTdGF0ZVtcIkxvYWRpbmdcIl0gPSAxXSA9IFwiTG9hZGluZ1wiO1xuICAgIExpdmVTdG9yYWdlU3RhdGVbTGl2ZVN0b3JhZ2VTdGF0ZVtcIkxvYWRlZFwiXSA9IDJdID0gXCJMb2FkZWRcIjtcbn0pKExpdmVTdG9yYWdlU3RhdGUgfHwgKExpdmVTdG9yYWdlU3RhdGUgPSB7fSkpO1xuXG4odW5kZWZpbmVkICYmIHVuZGVmaW5lZC5fX2F3YWl0ZXIpIHx8IGZ1bmN0aW9uICh0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xuICAgIH0pO1xufTtcblxuKHVuZGVmaW5lZCAmJiB1bmRlZmluZWQuX19hd2FpdGVyKSB8fCBmdW5jdGlvbiAodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcbiAgICB9KTtcbn07XG5cbnZhciBDbGllbnRDb250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcclxudmFyIFJvb21Db250ZXh0ID0gUmVhY3QuY3JlYXRlQ29udGV4dChudWxsKTtcclxuLyoqXHJcbiAqIE1ha2VzIHRoZSBMaXZlYmxvY2tzIGNsaWVudCBhdmFpbGFibGUgaW4gdGhlIGNvbXBvbmVudCBoaWVyYXJjaHkgYmVsb3cuXHJcbiAqL1xyXG5mdW5jdGlvbiBMaXZlYmxvY2tzUHJvdmlkZXIocHJvcHMpIHtcclxuICAgIHJldHVybiAoUmVhY3QuY3JlYXRlRWxlbWVudChDbGllbnRDb250ZXh0LlByb3ZpZGVyLCB7IHZhbHVlOiBwcm9wcy5jbGllbnQgfSwgcHJvcHMuY2hpbGRyZW4pKTtcclxufVxyXG4vKipcclxuICogUmV0dXJucyB0aGUgY2xpZW50IG9mIHRoZSBuZWFyZXN0IExpdmVibG9ja3NQcm92aWRlciBhYm92ZSBpbiB0aGUgcmVhY3QgY29tcG9uZW50IHRyZWVcclxuICovXHJcbmZ1bmN0aW9uIHVzZUNsaWVudCgpIHtcclxuICAgIHZhciBjbGllbnQgPSBSZWFjdC51c2VDb250ZXh0KENsaWVudENvbnRleHQpO1xyXG4gICAgaWYgKGNsaWVudCA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTGl2ZWJsb2Nrc1Byb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgcmVhY3QgdHJlZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiBjbGllbnQ7XHJcbn1cclxuLyoqXHJcbiAqIE1ha2VzIGEgUm9vbSBhdmFpbGFibGUgaW4gdGhlIGNvbXBvbmVudCBoaWVyYXJjaHkgYmVsb3cuXHJcbiAqIFdoZW4gdGhpcyBjb21wb25lbnQgaXMgdW5tb3VudGVkLCB0aGUgY3VycmVudCB1c2VyIGxlYXZlIHRoZSByb29tLlxyXG4gKiBUaGF0IG1lYW5zIHRoYXQgeW91IGNhbid0IGhhdmUgMiBSb29tUHJvdmlkZXIgd2l0aCB0aGUgc2FtZSByb29tIGlkIGluIHlvdXIgcmVhY3QgdHJlZS5cclxuICovXHJcbmZ1bmN0aW9uIFJvb21Qcm92aWRlcihfYSkge1xyXG4gICAgdmFyIGlkID0gX2EuaWQsIGNoaWxkcmVuID0gX2EuY2hpbGRyZW4sIGRlZmF1bHRQcmVzZW5jZSA9IF9hLmRlZmF1bHRQcmVzZW5jZTtcclxuICAgIHZhciBjbGllbnQgPSB1c2VDbGllbnQoKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgY2xpZW50LmxlYXZlKGlkKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW2NsaWVudCwgaWRdKTtcclxuICAgIHZhciByb29tID0gY2xpZW50LmdldFJvb20oaWQpIHx8XHJcbiAgICAgICAgY2xpZW50LmVudGVyKGlkLCBkZWZhdWx0UHJlc2VuY2UgPyBkZWZhdWx0UHJlc2VuY2UoKSA6IHVuZGVmaW5lZCk7XHJcbiAgICByZXR1cm4gUmVhY3QuY3JlYXRlRWxlbWVudChSb29tQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogcm9vbSB9LCBjaGlsZHJlbik7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgdGhlIHJvb20gb2YgdGhlIG5lYXJlc3QgUm9vbVByb3ZpZGVyIGFib3ZlIGluIHRoZSByZWFjdCBjb21wb25lbnQgdHJlZVxyXG4gKi9cclxuZnVuY3Rpb24gdXNlUm9vbSgpIHtcclxuICAgIHZhciByb29tID0gUmVhY3QudXNlQ29udGV4dChSb29tQ29udGV4dCk7XHJcbiAgICBpZiAocm9vbSA9PSBudWxsKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiUm9vbVByb3ZpZGVyIGlzIG1pc3NpbmcgZnJvbSB0aGUgcmVhY3QgdHJlZVwiKTtcclxuICAgIH1cclxuICAgIHJldHVybiByb29tO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIHRoZSBwcmVzZW5jZSBvZiB0aGUgY3VycmVudCB1c2VyIG9mIHRoZSBjdXJyZW50IHJvb20sIGFuZCBhIGZ1bmN0aW9uIHRvIHVwZGF0ZSBpdC5cclxuICogSXQgaXMgZGlmZmVyZW50IGZyb20gdGhlIHNldFN0YXRlIGZ1bmN0aW9uIHJldHVybmVkIGJ5IHRoZSB1c2VTdGF0ZSBob29rIGZyb20gUmVhY3QuXHJcbiAqIFlvdSBkb24ndCBuZWVkIHRvIHBhc3MgdGhlIGZ1bGwgcHJlc2VuY2Ugb2JqZWN0IHRvIHVwZGF0ZSBpdC5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgIHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHsgdXNlTXlQcmVzZW5jZSB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xyXG4gKlxyXG4gKiBjb25zdCBbbXlQcmVzZW5jZSwgdXBkYXRlTXlQcmVzZW5jZV0gPSB1c2VNeVByZXNlbmNlKCk7XHJcbiAqIHVwZGF0ZU15UHJlc2VuY2UoeyB4OiAwIH0pO1xyXG4gKiB1cGRhdGVNeVByZXNlbmNlKHsgeTogMCB9KTtcclxuICpcclxuICogLy8gQXQgdGhlIG5leHQgcmVuZGVyLCBcIm15UHJlc2VuY2VcIiB3aWxsIGJlIGVxdWFsIHRvIFwieyB4OiAwLCB5OiAwIH1cIlxyXG4gKiBgYGBcclxuICovXHJcbmZ1bmN0aW9uIHVzZU15UHJlc2VuY2UoKSB7XHJcbiAgICB2YXIgcm9vbSA9IHVzZVJvb20oKTtcclxuICAgIHZhciBwcmVzZW5jZSA9IHJvb20uZ2V0UHJlc2VuY2UoKTtcclxuICAgIHZhciBfYSA9IFJlYWN0LnVzZVN0YXRlKDApLCB1cGRhdGUgPSBfYVsxXTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgZnVuY3Rpb24gb25NeVByZXNlbmNlQ2hhbmdlKCkge1xyXG4gICAgICAgICAgICB1cGRhdGUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vbS5zdWJzY3JpYmUoXCJteS1wcmVzZW5jZVwiLCBvbk15UHJlc2VuY2VDaGFuZ2UpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJvb20udW5zdWJzY3JpYmUoXCJteS1wcmVzZW5jZVwiLCBvbk15UHJlc2VuY2VDaGFuZ2UpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcm9vbV0pO1xyXG4gICAgdmFyIHNldFByZXNlbmNlID0gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG92ZXJyaWRlcykgeyByZXR1cm4gcm9vbS51cGRhdGVQcmVzZW5jZShvdmVycmlkZXMpOyB9LCBbcm9vbV0pO1xyXG4gICAgcmV0dXJuIFtwcmVzZW5jZSwgc2V0UHJlc2VuY2VdO1xyXG59XHJcbi8qKlxyXG4gKiB1c2VVcGRhdGVNeVByZXNlbmNlIGlzIHNpbWlsYXIgdG8gdXNlTXlQcmVzZW5jZSBidXQgaXQgb25seSByZXR1cm5zIHRoZSBmdW5jdGlvbiB0byB1cGRhdGUgdGhlIGN1cnJlbnQgdXNlciBwcmVzZW5jZS5cclxuICogSWYgeW91IGRvbid0IHVzZSB0aGUgY3VycmVudCB1c2VyIHByZXNlbmNlIGluIHlvdXIgY29tcG9uZW50LCBidXQgeW91IG5lZWQgdG8gdXBkYXRlIGl0IChlLmcuIGxpdmUgY3Vyc29yKSwgaXQncyBiZXR0ZXIgdG8gdXNlIHVzZVVwZGF0ZU15UHJlc2VuY2UgdG8gYXZvaWQgdW5uZWNlc3NhcnkgcmVuZGVycy5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgIHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHsgdXNlVXBkYXRlTXlQcmVzZW5jZSB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xyXG4gKlxyXG4gKiBjb25zdCB1cGRhdGVNeVByZXNlbmNlID0gdXNlVXBkYXRlTXlQcmVzZW5jZSgpO1xyXG4gKiB1cGRhdGVNeVByZXNlbmNlKHsgeDogMCB9KTtcclxuICogdXBkYXRlTXlQcmVzZW5jZSh7IHk6IDAgfSk7XHJcbiAqXHJcbiAqIC8vIEF0IHRoZSBuZXh0IHJlbmRlciwgdGhlIHByZXNlbmNlIG9mIHRoZSBjdXJyZW50IHVzZXIgd2lsbCBiZSBlcXVhbCB0byBcInsgeDogMCwgeTogMCB9XCJcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VVcGRhdGVNeVByZXNlbmNlKCkge1xyXG4gICAgdmFyIHJvb20gPSB1c2VSb29tKCk7XHJcbiAgICByZXR1cm4gUmVhY3QudXNlQ2FsbGJhY2soZnVuY3Rpb24gKG92ZXJyaWRlcykge1xyXG4gICAgICAgIHJvb20udXBkYXRlUHJlc2VuY2Uob3ZlcnJpZGVzKTtcclxuICAgIH0sIFtyb29tXSk7XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybnMgYW4gb2JqZWN0IHRoYXQgbGV0cyB5b3UgZ2V0IGluZm9ybWF0aW9uIGFib3V0IGFsbCB0aGUgdGhlIHVzZXJzIGN1cnJlbnRseSBjb25uZWN0ZWQgaW4gdGhlIHJvb20uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYCB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7IHVzZU90aGVycyB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xyXG4gKlxyXG4gKiBjb25zdCBvdGhlcnMgPSB1c2VPdGhlcnMoKTtcclxuICpcclxuICogLy8gRXhhbXBsZSB0byBtYXAgYWxsIGN1cnNvcnMgaW4ganN4XHJcbiAqIHtcclxuICogICBvdGhlcnMubWFwKCh7IGNvbm5lY3Rpb25JZCwgcHJlc2VuY2UgfSkgPT4ge1xyXG4gKiAgICAgaWYocHJlc2VuY2UgPT0gbnVsbCB8fCBwcmVzZW5jZS5jdXJzb3IgPT0gbnVsbCkge1xyXG4gKiAgICAgICByZXR1cm4gbnVsbDtcclxuICogICAgIH1cclxuICogICAgIHJldHVybiA8Q3Vyc29yIGtleT17Y29ubmVjdGlvbklkfSBjdXJzb3I9e3ByZXNlbmNlLmN1cnNvcn0gLz5cclxuICogICB9KVxyXG4gKiB9XHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlT3RoZXJzKCkge1xyXG4gICAgdmFyIHJvb20gPSB1c2VSb29tKCk7XHJcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZSgwKSwgdXBkYXRlID0gX2FbMV07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uT3RoZXJzQ2hhbmdlKCkge1xyXG4gICAgICAgICAgICB1cGRhdGUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vbS5zdWJzY3JpYmUoXCJvdGhlcnNcIiwgb25PdGhlcnNDaGFuZ2UpO1xyXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJvb20uc3Vic2NyaWJlKFwib3RoZXJzXCIsIG9uT3RoZXJzQ2hhbmdlKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3Jvb21dKTtcclxuICAgIHJldHVybiByb29tLmdldE90aGVycygpO1xyXG59XHJcbi8qKlxyXG4gKiBSZXR1cm5zIGEgY2FsbGJhY2sgdGhhdCBsZXRzIHlvdSBicm9hZGNhc3QgY3VzdG9tIGV2ZW50cyB0byBvdGhlciB1c2VycyBpbiB0aGUgcm9vbVxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGAgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQgeyB1c2VCcm9hZGNhc3RFdmVudCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xyXG4gKlxyXG4gKiBjb25zdCBicm9hZGNhc3QgPSB1c2VCcm9hZGNhc3RFdmVudCgpO1xyXG4gKlxyXG4gKiBicm9hZGNhc3QoeyB0eXBlOiBcIkNVU1RPTV9FVkVOVFwiLCBkYXRhOiB7IHg6IDAsIHk6IDAgfSB9KTtcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VCcm9hZGNhc3RFdmVudCgpIHtcclxuICAgIHZhciByb29tID0gdXNlUm9vbSgpO1xyXG4gICAgcmV0dXJuIFJlYWN0LnVzZUNhbGxiYWNrKGZ1bmN0aW9uIChldmVudCkge1xyXG4gICAgICAgIHJvb20uYnJvYWRjYXN0RXZlbnQoZXZlbnQpO1xyXG4gICAgfSwgW3Jvb21dKTtcclxufVxyXG4vKipcclxuICogdXNlRXJyb3JMaXN0ZW5lciBpcyBhIHJlYWN0IGhvb2sgdGhhdCBsZXRzIHlvdSByZWFjdCB0byBwb3RlbnRpYWwgcm9vbSBjb25uZWN0aW9uIGVycm9ycy5cclxuICpcclxuICogIyMjIEV4YW1wbGVcclxuICogYGBgIHR5cGVzY3JpcHRcclxuICogaW1wb3J0IHsgdXNlRXJyb3JMaXN0ZW5lciB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xyXG4gKlxyXG4gKiB1c2VFcnJvckxpc3RlbmVyKGVyID0+IHtcclxuICogICBjb25zb2xlLmVycm9yKGVyKTtcclxuICogfSlcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VFcnJvckxpc3RlbmVyKGNhbGxiYWNrKSB7XHJcbiAgICB2YXIgcm9vbSA9IHVzZVJvb20oKTtcclxuICAgIHZhciBzYXZlZENhbGxiYWNrID0gUmVhY3QudXNlUmVmKGNhbGxiYWNrKTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgc2F2ZWRDYWxsYmFjay5jdXJyZW50ID0gY2FsbGJhY2s7XHJcbiAgICB9KTtcclxuICAgIFJlYWN0LnVzZUVmZmVjdChmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gZnVuY3Rpb24gKGUpIHsgcmV0dXJuIHNhdmVkQ2FsbGJhY2suY3VycmVudChlKTsgfTtcclxuICAgICAgICByb29tLnN1YnNjcmliZShcImVycm9yXCIsIGxpc3RlbmVyKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByb29tLnVuc3Vic2NyaWJlKFwiZXJyb3JcIiwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcm9vbV0pO1xyXG59XHJcbi8qKlxyXG4gKiB1c2VFdmVudExpc3RlbmVyIGlzIGEgcmVhY3QgaG9vayB0aGF0IGxldHMgeW91IHJlYWN0IHRvIGV2ZW50IGJyb2FkY2FzdGVkIGJ5IG90aGVyIHVzZXJzIGluIHRoZSByb29tLlxyXG4gKlxyXG4gKiAjIyMgRXhhbXBsZVxyXG4gKiBgYGAgdHlwZXNjcmlwdFxyXG4gKiBpbXBvcnQgeyB1c2VFdmVudExpc3RlbmVyIH0gZnJvbSBcIkBsaXZlYmxvY2tzL3JlYWN0XCI7XHJcbiAqXHJcbiAqIHVzZUV2ZW50TGlzdGVuZXIoKHsgY29ubmVjdGlvbklkLCBldmVudCB9KSA9PiB7XHJcbiAqICAgaWYgKGV2ZW50LnR5cGUgPT09IFwiQ1VTVE9NX0VWRU5UXCIpIHtcclxuICogICAgIC8vIERvIHNvbWV0aGluZ1xyXG4gKiAgIH1cclxuICogfSk7XHJcbiAqIGBgYFxyXG4gKi9cclxuZnVuY3Rpb24gdXNlRXZlbnRMaXN0ZW5lcihjYWxsYmFjaykge1xyXG4gICAgdmFyIHJvb20gPSB1c2VSb29tKCk7XHJcbiAgICB2YXIgc2F2ZWRDYWxsYmFjayA9IFJlYWN0LnVzZVJlZihjYWxsYmFjayk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHNhdmVkQ2FsbGJhY2suY3VycmVudCA9IGNhbGxiYWNrO1xyXG4gICAgfSk7XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGZ1bmN0aW9uIChlKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBzYXZlZENhbGxiYWNrLmN1cnJlbnQoZSk7XHJcbiAgICAgICAgfTtcclxuICAgICAgICByb29tLnN1YnNjcmliZShcImV2ZW50XCIsIGxpc3RlbmVyKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByb29tLnVuc3Vic2NyaWJlKFwiZXZlbnRcIiwgbGlzdGVuZXIpO1xyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcm9vbV0pO1xyXG59XHJcbi8qKlxyXG4gKiBHZXRzIHRoZSBjdXJyZW50IHVzZXIgb25jZSBpdCBpcyBjb25uZWN0ZWQgdG8gdGhlIHJvb20uXHJcbiAqXHJcbiAqICMjIyBFeGFtcGxlXHJcbiAqIGBgYCB0eXBlc2NyaXB0XHJcbiAqIGltcG9ydCB7IHVzZVNlbGYgfSBmcm9tIFwiQGxpdmVibG9ja3MvcmVhY3RcIjtcclxuICpcclxuICogY29uc3QgdXNlciA9IHVzZVNlbGYoKTtcclxuICogYGBgXHJcbiAqL1xyXG5mdW5jdGlvbiB1c2VTZWxmKCkge1xyXG4gICAgdmFyIHJvb20gPSB1c2VSb29tKCk7XHJcbiAgICB2YXIgX2EgPSBSZWFjdC51c2VTdGF0ZSgwKSwgdXBkYXRlID0gX2FbMV07XHJcbiAgICBSZWFjdC51c2VFZmZlY3QoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIG9uQ2hhbmdlKCkge1xyXG4gICAgICAgICAgICB1cGRhdGUoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHggKyAxOyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcm9vbS5zdWJzY3JpYmUoXCJteS1wcmVzZW5jZVwiLCBvbkNoYW5nZSk7XHJcbiAgICAgICAgcm9vbS5zdWJzY3JpYmUoXCJjb25uZWN0aW9uXCIsIG9uQ2hhbmdlKTtcclxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByb29tLnVuc3Vic2NyaWJlKFwibXktcHJlc2VuY2VcIiwgb25DaGFuZ2UpO1xyXG4gICAgICAgICAgICByb29tLnVuc3Vic2NyaWJlKFwiY29ubmVjdGlvblwiLCBvbkNoYW5nZSk7XHJcbiAgICAgICAgfTtcclxuICAgIH0sIFtyb29tXSk7XHJcbiAgICByZXR1cm4gcm9vbS5nZXRTZWxmKCk7XHJcbn1cclxuZnVuY3Rpb24gdXNlU3RvcmFnZShpbml0aWFsU3RvcmFnZSkge1xyXG4gICAgdmFyIHJvb20gPSB1c2VSb29tKCk7XHJcbiAgICB2YXIgc3RvcmFnZSA9IHJvb20uZ2V0U3RvcmFnZSgpO1xyXG4gICAgdmFyIF9hID0gUmVhY3QudXNlU3RhdGUoMCksIHVwZGF0ZSA9IF9hWzFdO1xyXG4gICAgUmVhY3QudXNlRWZmZWN0KGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBvblN0b3JhZ2VDaGFuZ2UoKSB7XHJcbiAgICAgICAgICAgIHVwZGF0ZShmdW5jdGlvbiAoeCkgeyByZXR1cm4geCArIDE7IH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICByb29tLmZldGNoU3RvcmFnZShpbml0aWFsU3RvcmFnZSk7XHJcbiAgICAgICAgcm9vbS5zdWJzY3JpYmUoXCJzdG9yYWdlXCIsIG9uU3RvcmFnZUNoYW5nZSk7XHJcbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcm9vbS51bnN1YnNjcmliZShcInN0b3JhZ2VcIiwgb25TdG9yYWdlQ2hhbmdlKTtcclxuICAgICAgICB9O1xyXG4gICAgfSwgW3Jvb21dKTtcclxuICAgIHZhciByb290ID0gc3RvcmFnZS5zdGF0ZSA9PT0gTGl2ZVN0b3JhZ2VTdGF0ZS5Mb2FkZWRcclxuICAgICAgICA/IHN0b3JhZ2Uucm9vdFxyXG4gICAgICAgIDogbnVsbDtcclxuICAgIHZhciBhY3Rpb25zID0gdXNlU3RvcmFnZUFjdGlvbnMoKTtcclxuICAgIHJldHVybiBbcm9vdCwgYWN0aW9uc107XHJcbn1cclxuZnVuY3Rpb24gdXNlU3RvcmFnZUFjdGlvbnMoKSB7XHJcbiAgICB2YXIgcm9vbSA9IHVzZVJvb20oKTtcclxuICAgIHJldHVybiBSZWFjdC51c2VNZW1vKGZ1bmN0aW9uICgpIHtcclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVSZWNvcmQoZGF0YSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vbS5jcmVhdGVSZWNvcmQoZGF0YSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIHVwZGF0ZVJlY29yZChyZWNvcmQsIG92ZXJyaWRlcykge1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vbS51cGRhdGVSZWNvcmQocmVjb3JkLCBvdmVycmlkZXMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBjcmVhdGVMaXN0KCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vbS5jcmVhdGVMaXN0KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGZ1bmN0aW9uIG1vdmVJdGVtKGxpc3QsIGluZGV4LCB0YXJnZXRJbmRleCkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vbS5tb3ZlSXRlbShsaXN0LCBpbmRleCwgdGFyZ2V0SW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBkZWxldGVJdGVtKGxpc3QsIGluZGV4KSB7XHJcbiAgICAgICAgICAgIHJldHVybiByb29tLmRlbGV0ZUl0ZW0obGlzdCwgaW5kZXgpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmdW5jdGlvbiBkZWxldGVJdGVtQnlJZChsaXN0LCBpdGVtSWQpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHJvb20uZGVsZXRlSXRlbUJ5SWQobGlzdCwgaXRlbUlkKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZnVuY3Rpb24gcHVzaEl0ZW0obGlzdCwgaXRlbSkge1xyXG4gICAgICAgICAgICByZXR1cm4gcm9vbS5wdXNoSXRlbShsaXN0LCBpdGVtKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgY3JlYXRlUmVjb3JkOiBjcmVhdGVSZWNvcmQsXHJcbiAgICAgICAgICAgIHVwZGF0ZVJlY29yZDogdXBkYXRlUmVjb3JkLFxyXG4gICAgICAgICAgICBjcmVhdGVMaXN0OiBjcmVhdGVMaXN0LFxyXG4gICAgICAgICAgICBtb3ZlSXRlbTogbW92ZUl0ZW0sXHJcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW06IGRlbGV0ZUl0ZW0sXHJcbiAgICAgICAgICAgIGRlbGV0ZUl0ZW1CeUlkOiBkZWxldGVJdGVtQnlJZCxcclxuICAgICAgICAgICAgcHVzaEl0ZW06IHB1c2hJdGVtLFxyXG4gICAgICAgIH07XHJcbiAgICB9LCBbcm9vbV0pO1xyXG59XG5cbmV4cG9ydHMuTGl2ZWJsb2Nrc1Byb3ZpZGVyID0gTGl2ZWJsb2Nrc1Byb3ZpZGVyO1xuZXhwb3J0cy5Sb29tUHJvdmlkZXIgPSBSb29tUHJvdmlkZXI7XG5leHBvcnRzLnVzZUJyb2FkY2FzdEV2ZW50ID0gdXNlQnJvYWRjYXN0RXZlbnQ7XG5leHBvcnRzLnVzZUVycm9yTGlzdGVuZXIgPSB1c2VFcnJvckxpc3RlbmVyO1xuZXhwb3J0cy51c2VFdmVudExpc3RlbmVyID0gdXNlRXZlbnRMaXN0ZW5lcjtcbmV4cG9ydHMudXNlTXlQcmVzZW5jZSA9IHVzZU15UHJlc2VuY2U7XG5leHBvcnRzLnVzZU90aGVycyA9IHVzZU90aGVycztcbmV4cG9ydHMudXNlU2VsZiA9IHVzZVNlbGY7XG5leHBvcnRzLnVzZVN0b3JhZ2UgPSB1c2VTdG9yYWdlO1xuZXhwb3J0cy51c2VTdG9yYWdlQWN0aW9ucyA9IHVzZVN0b3JhZ2VBY3Rpb25zO1xuZXhwb3J0cy51c2VVcGRhdGVNeVByZXNlbmNlID0gdXNlVXBkYXRlTXlQcmVzZW5jZTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcFxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/@liveblocks/react/lib/index.js\n");

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!":
/*!*******************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app! ***!
  \*******************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/_app\",\n      function () {\n        return __webpack_require__(/*! private-next-pages/_app */ \"./pages/_app.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/_app\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/cGFnZT0lMkZfYXBwJmFic29sdXRlUGFnZVBhdGg9cHJpdmF0ZS1uZXh0LXBhZ2VzJTJGX2FwcCEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxnREFBeUI7QUFDaEQ7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzYzZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9fYXBwXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiByZXF1aXJlKFwicHJpdmF0ZS1uZXh0LXBhZ2VzL19hcHBcIik7XG4gICAgICB9XG4gICAgXSk7XG4gICAgaWYobW9kdWxlLmhvdCkge1xuICAgICAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgd2luZG93Ll9fTkVYVF9QLnB1c2goW1wiL19hcHBcIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!\n");

/***/ }),

/***/ "./pages/_app.js":
/*!***********************!*\
  !*** ./pages/_app.js ***!
  \***********************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _home_svn_ryanparag_com_node_modules_next_dist_compiled_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty */ \"./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty.js\");\n/* harmony import */ var _liveblocks_client__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @liveblocks/client */ \"./node_modules/@liveblocks/client/lib/esm/index.js\");\n/* harmony import */ var _liveblocks_react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @liveblocks/react */ \"./node_modules/@liveblocks/react/lib/index.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__);\n\nvar _jsxFileName = \"/home/svn/ryanparag.com/pages/_app.js\";\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) { symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); } keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0,_home_svn_ryanparag_com_node_modules_next_dist_compiled_babel_runtime_helpers_esm_defineProperty__WEBPACK_IMPORTED_MODULE_0__[\"default\"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\n\n\n\nvar client = (0,_liveblocks_client__WEBPACK_IMPORTED_MODULE_1__.createClient)({\n  authEndpoint: \"/api/liveblocks\"\n});\n\nfunction MyApp(_ref) {\n  var Component = _ref.Component,\n      pageProps = _ref.pageProps;\n  return /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(_liveblocks_react__WEBPACK_IMPORTED_MODULE_2__.LiveblocksProvider, {\n    client: client,\n    children: /*#__PURE__*/(0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_3__.jsxDEV)(Component, _objectSpread({}, pageProps), void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 11,\n      columnNumber: 7\n    }, this)\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 10,\n    columnNumber: 5\n  }, this);\n}\n\n_c = MyApp;\n/* harmony default export */ __webpack_exports__[\"default\"] = (MyApp);\n\nvar _c;\n\n$RefreshReg$(_c, \"MyApp\");\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9fYXBwLmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBOztBQUVBLElBQU1FLE1BQU0sR0FBR0YsZ0VBQVksQ0FBQztBQUMxQkcsRUFBQUEsWUFBWSxFQUFFO0FBRFksQ0FBRCxDQUEzQjs7QUFJQSxTQUFTQyxLQUFULE9BQXlDO0FBQUEsTUFBeEJDLFNBQXdCLFFBQXhCQSxTQUF3QjtBQUFBLE1BQWJDLFNBQWEsUUFBYkEsU0FBYTtBQUN2QyxzQkFDRSw4REFBQyxpRUFBRDtBQUFvQixVQUFNLEVBQUVKLE1BQTVCO0FBQUEsMkJBQ0UsOERBQUMsU0FBRCxvQkFBZUksU0FBZjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBREY7QUFBQTtBQUFBO0FBQUE7QUFBQSxVQURGO0FBS0Q7O0tBTlFGO0FBUVQsK0RBQWVBLEtBQWYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvX2FwcC5qcz9lMGFkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGNyZWF0ZUNsaWVudCB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9jbGllbnRcIjtcbmltcG9ydCB7IExpdmVibG9ja3NQcm92aWRlciB9IGZyb20gXCJAbGl2ZWJsb2Nrcy9yZWFjdFwiO1xuXG5jb25zdCBjbGllbnQgPSBjcmVhdGVDbGllbnQoe1xuICBhdXRoRW5kcG9pbnQ6IFwiL2FwaS9saXZlYmxvY2tzXCIsXG59KTtcblxuZnVuY3Rpb24gTXlBcHAoeyBDb21wb25lbnQsIHBhZ2VQcm9wcyB9KSB7XG4gIHJldHVybiAoXG4gICAgPExpdmVibG9ja3NQcm92aWRlciBjbGllbnQ9e2NsaWVudH0+XG4gICAgICA8Q29tcG9uZW50IHsuLi5wYWdlUHJvcHN9IC8+XG4gICAgPC9MaXZlYmxvY2tzUHJvdmlkZXI+XG4gICk7XG59XG5cbmV4cG9ydCBkZWZhdWx0IE15QXBwOyJdLCJuYW1lcyI6WyJjcmVhdGVDbGllbnQiLCJMaXZlYmxvY2tzUHJvdmlkZXIiLCJjbGllbnQiLCJhdXRoRW5kcG9pbnQiLCJNeUFwcCIsIkNvbXBvbmVudCIsInBhZ2VQcm9wcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./pages/_app.js\n");

/***/ }),

/***/ "./node_modules/react/cjs/react-jsx-dev-runtime.development.js":
/*!*********************************************************************!*\
  !*** ./node_modules/react/cjs/react-jsx-dev-runtime.development.js ***!
  \*********************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval("/** @license React v17.0.2\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\nvar _assign = __webpack_require__(/*! object-assign */ \"./node_modules/next/dist/build/polyfills/object-assign.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types. If there is no native Symbol\n// nor polyfill, then a plain number is used for performance.\nvar REACT_ELEMENT_TYPE = 0xeac7;\nvar REACT_PORTAL_TYPE = 0xeaca;\nexports.Fragment = 0xeacb;\nvar REACT_STRICT_MODE_TYPE = 0xeacc;\nvar REACT_PROFILER_TYPE = 0xead2;\nvar REACT_PROVIDER_TYPE = 0xeacd;\nvar REACT_CONTEXT_TYPE = 0xeace;\nvar REACT_FORWARD_REF_TYPE = 0xead0;\nvar REACT_SUSPENSE_TYPE = 0xead1;\nvar REACT_SUSPENSE_LIST_TYPE = 0xead8;\nvar REACT_MEMO_TYPE = 0xead3;\nvar REACT_LAZY_TYPE = 0xead4;\nvar REACT_BLOCK_TYPE = 0xead9;\nvar REACT_SERVER_BLOCK_TYPE = 0xeada;\nvar REACT_FUNDAMENTAL_TYPE = 0xead5;\nvar REACT_SCOPE_TYPE = 0xead7;\nvar REACT_OPAQUE_ID_TYPE = 0xeae0;\nvar REACT_DEBUG_TRACING_MODE_TYPE = 0xeae1;\nvar REACT_OFFSCREEN_TYPE = 0xeae2;\nvar REACT_LEGACY_HIDDEN_TYPE = 0xeae3;\n\nif (typeof Symbol === 'function' && Symbol.for) {\n  var symbolFor = Symbol.for;\n  REACT_ELEMENT_TYPE = symbolFor('react.element');\n  REACT_PORTAL_TYPE = symbolFor('react.portal');\n  exports.Fragment = symbolFor('react.fragment');\n  REACT_STRICT_MODE_TYPE = symbolFor('react.strict_mode');\n  REACT_PROFILER_TYPE = symbolFor('react.profiler');\n  REACT_PROVIDER_TYPE = symbolFor('react.provider');\n  REACT_CONTEXT_TYPE = symbolFor('react.context');\n  REACT_FORWARD_REF_TYPE = symbolFor('react.forward_ref');\n  REACT_SUSPENSE_TYPE = symbolFor('react.suspense');\n  REACT_SUSPENSE_LIST_TYPE = symbolFor('react.suspense_list');\n  REACT_MEMO_TYPE = symbolFor('react.memo');\n  REACT_LAZY_TYPE = symbolFor('react.lazy');\n  REACT_BLOCK_TYPE = symbolFor('react.block');\n  REACT_SERVER_BLOCK_TYPE = symbolFor('react.server.block');\n  REACT_FUNDAMENTAL_TYPE = symbolFor('react.fundamental');\n  REACT_SCOPE_TYPE = symbolFor('react.scope');\n  REACT_OPAQUE_ID_TYPE = symbolFor('react.opaque.id');\n  REACT_DEBUG_TRACING_MODE_TYPE = symbolFor('react.debug_trace_mode');\n  REACT_OFFSCREEN_TYPE = symbolFor('react.offscreen');\n  REACT_LEGACY_HIDDEN_TYPE = symbolFor('react.legacy_hidden');\n}\n\nvar MAYBE_ITERATOR_SYMBOL = typeof Symbol === 'function' && Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n      args[_key2 - 1] = arguments[_key2];\n    }\n\n    printWarning('error', format, args);\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    }\n\n    var argsWithFormat = args.map(function (item) {\n      return '' + item;\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// Filter certain DOM attributes (e.g. src, href) if their values are empty strings.\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\n\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === exports.Fragment || type === REACT_PROFILER_TYPE || type === REACT_DEBUG_TRACING_MODE_TYPE || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || type === REACT_LEGACY_HIDDEN_TYPE || enableScopeAPI ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || type.$$typeof === REACT_FUNDAMENTAL_TYPE || type.$$typeof === REACT_BLOCK_TYPE || type[0] === REACT_SERVER_BLOCK_TYPE) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var functionName = innerType.displayName || innerType.name || '';\n  return outerType.displayName || (functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName);\n}\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n}\n\nfunction getComponentName(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentName(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case exports.Fragment:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        return getComponentName(type.type);\n\n      case REACT_BLOCK_TYPE:\n        return getComponentName(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentName(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n    }\n  }\n\n  return null;\n}\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: _assign({}, props, {\n          value: prevLog\n        }),\n        info: _assign({}, props, {\n          value: prevInfo\n        }),\n        warn: _assign({}, props, {\n          value: prevWarn\n        }),\n        error: _assign({}, props, {\n          value: prevError\n        }),\n        group: _assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: _assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: _assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if (!fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        }\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      }\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at ');\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_BLOCK_TYPE:\n        return describeFunctionComponentFrame(type._render);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(Object.prototype.hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentName(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentName(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentName(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentName(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (Array.isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentName(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentName(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (Array.isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentName(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (Array.isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    if (type === exports.Fragment) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVhOztBQUViLElBQUksSUFBcUM7QUFDekM7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsNENBQU87QUFDM0IsY0FBYyxtQkFBTyxDQUFDLGdGQUFlOztBQUVyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxnQkFBZ0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0EsK0ZBQStGLGVBQWU7QUFDOUc7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxLQUFLLEdBQUc7O0FBRVIsa0RBQWtEO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBLDRCQUE0Qjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTs7O0FBR0o7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7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QUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxVQUFVO0FBQ1Y7QUFDQTs7QUFFQTtBQUNBOztBQUVBLG9FQUFvRTs7QUFFcEU7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNM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QTtBQUNBLE1BQU07QUFDTjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDRDQUE0Qzs7QUFFNUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsY0FBYztBQUN6Qjs7O0FBR0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQixpQkFBaUI7QUFDckM7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTs7QUFFQTtBQUNBO0FBQ0EsRUFBRTs7QUFFRjs7QUFFQSxjQUFjO0FBQ2QsR0FBRztBQUNIIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzPzE3ZTEiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBsaWNlbnNlIFJlYWN0IHYxNy4wLjJcbiAqIHJlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qc1xuICpcbiAqIENvcHlyaWdodCAoYykgRmFjZWJvb2ssIEluYy4gYW5kIGl0cyBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoJ3JlYWN0Jyk7XG52YXIgX2Fzc2lnbiA9IHJlcXVpcmUoJ29iamVjdC1hc3NpZ24nKTtcblxuLy8gQVRURU5USU9OXG4vLyBXaGVuIGFkZGluZyBuZXcgc3ltYm9scyB0byB0aGlzIGZpbGUsXG4vLyBQbGVhc2UgY29uc2lkZXIgYWxzbyBhZGRpbmcgdG8gJ3JlYWN0LWRldnRvb2xzLXNoYXJlZC9zcmMvYmFja2VuZC9SZWFjdFN5bWJvbHMnXG4vLyBUaGUgU3ltYm9sIHVzZWQgdG8gdGFnIHRoZSBSZWFjdEVsZW1lbnQtbGlrZSB0eXBlcy4gSWYgdGhlcmUgaXMgbm8gbmF0aXZlIFN5bWJvbFxuLy8gbm9yIHBvbHlmaWxsLCB0aGVuIGEgcGxhaW4gbnVtYmVyIGlzIHVzZWQgZm9yIHBlcmZvcm1hbmNlLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IDB4ZWFjNztcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IDB4ZWFjYTtcbmV4cG9ydHMuRnJhZ21lbnQgPSAweGVhY2I7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IDB4ZWFjYztcbnZhciBSRUFDVF9QUk9GSUxFUl9UWVBFID0gMHhlYWQyO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSAweGVhY2Q7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gMHhlYWNlO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSAweGVhZDA7XG52YXIgUkVBQ1RfU1VTUEVOU0VfVFlQRSA9IDB4ZWFkMTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSAweGVhZDg7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gMHhlYWQzO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IDB4ZWFkNDtcbnZhciBSRUFDVF9CTE9DS19UWVBFID0gMHhlYWQ5O1xudmFyIFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFID0gMHhlYWRhO1xudmFyIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSAweGVhZDU7XG52YXIgUkVBQ1RfU0NPUEVfVFlQRSA9IDB4ZWFkNztcbnZhciBSRUFDVF9PUEFRVUVfSURfVFlQRSA9IDB4ZWFlMDtcbnZhciBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSA9IDB4ZWFlMTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IDB4ZWFlMjtcbnZhciBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSAweGVhZTM7XG5cbmlmICh0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC5mb3IpIHtcbiAgdmFyIHN5bWJvbEZvciA9IFN5bWJvbC5mb3I7XG4gIFJFQUNUX0VMRU1FTlRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuZWxlbWVudCcpO1xuICBSRUFDVF9QT1JUQUxfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QucG9ydGFsJyk7XG4gIGV4cG9ydHMuRnJhZ21lbnQgPSBzeW1ib2xGb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG4gIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG4gIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG4gIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG4gIFJFQUNUX0NPTlRFWFRfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QuY29udGV4dCcpO1xuICBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xuICBSRUFDVF9TVVNQRU5TRV9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5zdXNwZW5zZScpO1xuICBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbiAgUkVBQ1RfTUVNT19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5tZW1vJyk7XG4gIFJFQUNUX0xBWllfVFlQRSA9IHN5bWJvbEZvcigncmVhY3QubGF6eScpO1xuICBSRUFDVF9CTE9DS19UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5ibG9jaycpO1xuICBSRUFDVF9TRVJWRVJfQkxPQ0tfVFlQRSA9IHN5bWJvbEZvcigncmVhY3Quc2VydmVyLmJsb2NrJyk7XG4gIFJFQUNUX0ZVTkRBTUVOVEFMX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmZ1bmRhbWVudGFsJyk7XG4gIFJFQUNUX1NDT1BFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LnNjb3BlJyk7XG4gIFJFQUNUX09QQVFVRV9JRF9UWVBFID0gc3ltYm9sRm9yKCdyZWFjdC5vcGFxdWUuaWQnKTtcbiAgUkVBQ1RfREVCVUdfVFJBQ0lOR19NT0RFX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmRlYnVnX3RyYWNlX21vZGUnKTtcbiAgUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xuICBSRUFDVF9MRUdBQ1lfSElEREVOX1RZUEUgPSBzeW1ib2xGb3IoJ3JlYWN0LmxlZ2FjeV9oaWRkZW4nKTtcbn1cblxudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgIH1cblxuICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByaW50V2FybmluZyhsZXZlbCwgZm9ybWF0LCBhcmdzKSB7XG4gIC8vIFdoZW4gY2hhbmdpbmcgdGhpcyBsb2dpYywgeW91IG1pZ2h0IHdhbnQgdG8gYWxzb1xuICAvLyB1cGRhdGUgY29uc29sZVdpdGhTdGFja0Rldi53d3cuanMgYXMgd2VsbC5cbiAge1xuICAgIHZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcbiAgICB2YXIgc3RhY2sgPSBSZWFjdERlYnVnQ3VycmVudEZyYW1lLmdldFN0YWNrQWRkZW5kdW0oKTtcblxuICAgIGlmIChzdGFjayAhPT0gJycpIHtcbiAgICAgIGZvcm1hdCArPSAnJXMnO1xuICAgICAgYXJncyA9IGFyZ3MuY29uY2F0KFtzdGFja10pO1xuICAgIH1cblxuICAgIHZhciBhcmdzV2l0aEZvcm1hdCA9IGFyZ3MubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICByZXR1cm4gJycgKyBpdGVtO1xuICAgIH0pOyAvLyBDYXJlZnVsOiBSTiBjdXJyZW50bHkgZGVwZW5kcyBvbiB0aGlzIHByZWZpeFxuXG4gICAgYXJnc1dpdGhGb3JtYXQudW5zaGlmdCgnV2FybmluZzogJyArIGZvcm1hdCk7IC8vIFdlIGludGVudGlvbmFsbHkgZG9uJ3QgdXNlIHNwcmVhZCAob3IgLmFwcGx5KSBkaXJlY3RseSBiZWNhdXNlIGl0XG4gICAgLy8gYnJlYWtzIElFOTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xMzYxMFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmdcblxuICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGVbbGV2ZWxdLCBjb25zb2xlLCBhcmdzV2l0aEZvcm1hdCk7XG4gIH1cbn1cblxuLy8gRmlsdGVyIGNlcnRhaW4gRE9NIGF0dHJpYnV0ZXMgKGUuZy4gc3JjLCBocmVmKSBpZiB0aGVpciB2YWx1ZXMgYXJlIGVtcHR5IHN0cmluZ3MuXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKSB7XG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSAvLyBOb3RlOiB0eXBlb2YgbWlnaHQgYmUgb3RoZXIgdGhhbiAnc3ltYm9sJyBvciAnbnVtYmVyJyAoZS5nLiBpZiBpdCdzIGEgcG9seWZpbGwpLlxuXG5cbiAgaWYgKHR5cGUgPT09IGV4cG9ydHMuRnJhZ21lbnQgfHwgdHlwZSA9PT0gUkVBQ1RfUFJPRklMRVJfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9ERUJVR19UUkFDSU5HX01PREVfVFlQRSB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX0xFR0FDWV9ISURERU5fVFlQRSB8fCBlbmFibGVTY29wZUFQSSApIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCkge1xuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9MQVpZX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTUVNT19UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX1BST1ZJREVSX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfQ09OVEVYVF9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRlVOREFNRU5UQUxfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9CTE9DS19UWVBFIHx8IHR5cGVbMF0gPT09IFJFQUNUX1NFUlZFUl9CTE9DS19UWVBFKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZnVuY3Rpb25OYW1lID0gaW5uZXJUeXBlLmRpc3BsYXlOYW1lIHx8IGlubmVyVHlwZS5uYW1lIHx8ICcnO1xuICByZXR1cm4gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lIHx8IChmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWUpO1xufVxuXG5mdW5jdGlvbiBnZXRDb250ZXh0TmFtZSh0eXBlKSB7XG4gIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8ICdDb250ZXh0Jztcbn1cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKSB7XG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICAvLyBIb3N0IHJvb3QsIHRleHQgbm9kZSBvciBqdXN0IGludmFsaWQgdHlwZS5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHtcbiAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgZXJyb3IoJ1JlY2VpdmVkIGFuIHVuZXhwZWN0ZWQgb2JqZWN0IGluIGdldENvbXBvbmVudE5hbWUoKS4gJyArICdUaGlzIGlzIGxpa2VseSBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8IG51bGw7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIGV4cG9ydHMuRnJhZ21lbnQ6XG4gICAgICByZXR1cm4gJ0ZyYWdtZW50JztcblxuICAgIGNhc2UgUkVBQ1RfUE9SVEFMX1RZUEU6XG4gICAgICByZXR1cm4gJ1BvcnRhbCc7XG5cbiAgICBjYXNlIFJFQUNUX1BST0ZJTEVSX1RZUEU6XG4gICAgICByZXR1cm4gJ1Byb2ZpbGVyJztcblxuICAgIGNhc2UgUkVBQ1RfU1RSSUNUX01PREVfVFlQRTpcbiAgICAgIHJldHVybiAnU3RyaWN0TW9kZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N1c3BlbnNlJztcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZUxpc3QnO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnb2JqZWN0Jykge1xuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfQkxPQ0tfVFlQRTpcbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWUodHlwZS5fcmVuZGVyKTtcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZShpbml0KHBheWxvYWQpKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxuLy8gSGVscGVycyB0byBwYXRjaCBjb25zb2xlLmxvZ3MgdG8gYXZvaWQgbG9nZ2luZyBkdXJpbmcgc2lkZS1lZmZlY3QgZnJlZVxuLy8gcmVwbGF5aW5nIG9uIHJlbmRlciBmdW5jdGlvbi4gVGhpcyBjdXJyZW50bHkgb25seSBwYXRjaGVzIHRoZSBvYmplY3Rcbi8vIGxhemlseSB3aGljaCB3b24ndCBjb3ZlciBpZiB0aGUgbG9nIGZ1bmN0aW9uIHdhcyBleHRyYWN0ZWQgZWFnZXJseS5cbi8vIFdlIGNvdWxkIGFsc28gZWFnZXJseSBwYXRjaCB0aGUgbWV0aG9kLlxudmFyIGRpc2FibGVkRGVwdGggPSAwO1xudmFyIHByZXZMb2c7XG52YXIgcHJldkluZm87XG52YXIgcHJldldhcm47XG52YXIgcHJldkVycm9yO1xudmFyIHByZXZHcm91cDtcbnZhciBwcmV2R3JvdXBDb2xsYXBzZWQ7XG52YXIgcHJldkdyb3VwRW5kO1xuXG5mdW5jdGlvbiBkaXNhYmxlZExvZygpIHt9XG5cbmRpc2FibGVkTG9nLl9fcmVhY3REaXNhYmxlZExvZyA9IHRydWU7XG5mdW5jdGlvbiBkaXNhYmxlTG9ncygpIHtcbiAge1xuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHByZXZMb2cgPSBjb25zb2xlLmxvZztcbiAgICAgIHByZXZJbmZvID0gY29uc29sZS5pbmZvO1xuICAgICAgcHJldldhcm4gPSBjb25zb2xlLndhcm47XG4gICAgICBwcmV2RXJyb3IgPSBjb25zb2xlLmVycm9yO1xuICAgICAgcHJldkdyb3VwID0gY29uc29sZS5ncm91cDtcbiAgICAgIHByZXZHcm91cENvbGxhcHNlZCA9IGNvbnNvbGUuZ3JvdXBDb2xsYXBzZWQ7XG4gICAgICBwcmV2R3JvdXBFbmQgPSBjb25zb2xlLmdyb3VwRW5kOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzE5MDk5XG5cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB2YWx1ZTogZGlzYWJsZWRMb2csXG4gICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICB9OyAvLyAkRmxvd0ZpeE1lIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgbG9nOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2TG9nXG4gICAgICAgIH0pLFxuICAgICAgICBpbmZvOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogX2Fzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldldhcm5cbiAgICAgICAgfSksXG4gICAgICAgIGVycm9yOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2RXJyb3JcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBDb2xsYXBzZWRcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwRW5kOiBfYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBFbmRcbiAgICAgICAgfSlcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA8IDApIHtcbiAgICAgIGVycm9yKCdkaXNhYmxlZERlcHRoIGZlbGwgYmVsb3cgemVyby4gJyArICdUaGlzIGlzIGEgYnVnIGluIFJlYWN0LiBQbGVhc2UgZmlsZSBhbiBpc3N1ZS4nKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudERpc3BhdGNoZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnREaXNwYXRjaGVyO1xudmFyIHByZWZpeDtcbmZ1bmN0aW9uIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKG5hbWUsIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgaWYgKHByZWZpeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAvLyBFeHRyYWN0IHRoZSBWTSBzcGVjaWZpYyBwcmVmaXggdXNlZCBieSBlYWNoIGxpbmUuXG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICB2YXIgbWF0Y2ggPSB4LnN0YWNrLnRyaW0oKS5tYXRjaCgvXFxuKCAqKGF0ICk/KS8pO1xuICAgICAgICBwcmVmaXggPSBtYXRjaCAmJiBtYXRjaFsxXSB8fCAnJztcbiAgICAgIH1cbiAgICB9IC8vIFdlIHVzZSB0aGUgcHJlZml4IHRvIGVuc3VyZSBvdXIgc3RhY2tzIGxpbmUgdXAgd2l0aCBuYXRpdmUgc3RhY2sgZnJhbWVzLlxuXG5cbiAgICByZXR1cm4gJ1xcbicgKyBwcmVmaXggKyBuYW1lO1xuICB9XG59XG52YXIgcmVlbnRyeSA9IGZhbHNlO1xudmFyIGNvbXBvbmVudEZyYW1lQ2FjaGU7XG5cbntcbiAgdmFyIFBvc3NpYmx5V2Vha01hcCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nID8gV2Vha01hcCA6IE1hcDtcbiAgY29tcG9uZW50RnJhbWVDYWNoZSA9IG5ldyBQb3NzaWJseVdlYWtNYXAoKTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgY29uc3RydWN0KSB7XG4gIC8vIElmIHNvbWV0aGluZyBhc2tlZCBmb3IgYSBzdGFjayBpbnNpZGUgYSBmYWtlIHJlbmRlciwgaXQgc2hvdWxkIGdldCBpZ25vcmVkLlxuICBpZiAoIWZuIHx8IHJlZW50cnkpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICB7XG4gICAgdmFyIGZyYW1lID0gY29tcG9uZW50RnJhbWVDYWNoZS5nZXQoZm4pO1xuXG4gICAgaWYgKGZyYW1lICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBmcmFtZTtcbiAgICB9XG4gIH1cblxuICB2YXIgY29udHJvbDtcbiAgcmVlbnRyeSA9IHRydWU7XG4gIHZhciBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlID0gRXJyb3IucHJlcGFyZVN0YWNrVHJhY2U7IC8vICRGbG93Rml4TWUgSXQgZG9lcyBhY2NlcHQgdW5kZWZpbmVkLlxuXG4gIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gdW5kZWZpbmVkO1xuICB2YXIgcHJldmlvdXNEaXNwYXRjaGVyO1xuXG4gIHtcbiAgICBwcmV2aW91c0Rpc3BhdGNoZXIgPSBSZWFjdEN1cnJlbnREaXNwYXRjaGVyLmN1cnJlbnQ7IC8vIFNldCB0aGUgZGlzcGF0Y2hlciBpbiBERVYgYmVjYXVzZSB0aGlzIG1pZ2h0IGJlIGNhbGwgaW4gdGhlIHJlbmRlciBmdW5jdGlvblxuICAgIC8vIGZvciB3YXJuaW5ncy5cblxuICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IG51bGw7XG4gICAgZGlzYWJsZUxvZ3MoKTtcbiAgfVxuXG4gIHRyeSB7XG4gICAgLy8gVGhpcyBzaG91bGQgdGhyb3cuXG4gICAgaWYgKGNvbnN0cnVjdCkge1xuICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICB2YXIgRmFrZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH07IC8vICRGbG93Rml4TWVcblxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgc2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgLy8gV2UgdXNlIGEgdGhyb3dpbmcgc2V0dGVyIGluc3RlYWQgb2YgZnJvemVuIG9yIG5vbi13cml0YWJsZSBwcm9wc1xuICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmNvbnN0cnVjdCkge1xuICAgICAgICAvLyBXZSBjb25zdHJ1Y3QgYSBkaWZmZXJlbnQgY29udHJvbCBmb3IgdGhpcyBjYXNlIHRvIGluY2x1ZGUgYW55IGV4dHJhXG4gICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgUmVmbGVjdC5jb25zdHJ1Y3QoRmFrZSwgW10pO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH1cblxuICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICB9XG5cbiAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgfVxuXG4gICAgICBmbigpO1xuICAgIH1cbiAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgLy8gVGhpcyBpcyBpbmxpbmVkIG1hbnVhbGx5IGJlY2F1c2UgY2xvc3VyZSBkb2Vzbid0IGRvIGl0IGZvciB1cy5cbiAgICBpZiAoc2FtcGxlICYmIGNvbnRyb2wgJiYgdHlwZW9mIHNhbXBsZS5zdGFjayA9PT0gJ3N0cmluZycpIHtcbiAgICAgIC8vIFRoaXMgZXh0cmFjdHMgdGhlIGZpcnN0IGZyYW1lIGZyb20gdGhlIHNhbXBsZSB0aGF0IGlzbid0IGFsc28gaW4gdGhlIGNvbnRyb2wuXG4gICAgICAvLyBTa2lwcGluZyBvbmUgZnJhbWUgdGhhdCB3ZSBhc3N1bWUgaXMgdGhlIGZyYW1lIHRoYXQgY2FsbHMgdGhlIHR3by5cbiAgICAgIHZhciBzYW1wbGVMaW5lcyA9IHNhbXBsZS5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbC5zdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgcyA9IHNhbXBsZUxpbmVzLmxlbmd0aCAtIDE7XG4gICAgICB2YXIgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCAmJiBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgIC8vIFdlIGV4cGVjdCBhdCBsZWFzdCBvbmUgc3RhY2sgZnJhbWUgdG8gYmUgc2hhcmVkLlxuICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgIC8vIGN1dCBvZmYgZHVlIHRvIG1heGltdW0gc3RhY2sgbGltaXRzLiBJbiB0aGlzIGNhc2UsIG9uZSBtYXliZSBjdXQgb2ZmXG4gICAgICAgIC8vIGVhcmxpZXIgdGhhbiB0aGUgb3RoZXIuIFdlIGFzc3VtZSB0aGF0IHRoZSBzYW1wbGUgaXMgbG9uZ2VyIG9yIHRoZSBzYW1lXG4gICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgIC8vIHRoZSBzYW1wbGUgc29tZXdoZXJlIGluIHRoZSBjb250cm9sLlxuICAgICAgICBjLS07XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpO1xuXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgX2ZyYW1lKTtcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9IC8vIFJldHVybiB0aGUgbGluZSB3ZSBmb3VuZC5cblxuXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mcmFtZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSB3aGlsZSAocyA+PSAxICYmIGMgPj0gMCk7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgcmVlbnRyeSA9IGZhbHNlO1xuXG4gICAge1xuICAgICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gcHJldmlvdXNEaXNwYXRjaGVyO1xuICAgICAgcmVlbmFibGVMb2dzKCk7XG4gICAgfVxuXG4gICAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSBwcmV2aW91c1ByZXBhcmVTdGFja1RyYWNlO1xuICB9IC8vIEZhbGxiYWNrIHRvIGp1c3QgdXNpbmcgdGhlIG5hbWUgaWYgd2UgY291bGRuJ3QgbWFrZSBpdCB0aHJvdy5cblxuXG4gIHZhciBuYW1lID0gZm4gPyBmbi5kaXNwbGF5TmFtZSB8fCBmbi5uYW1lIDogJyc7XG4gIHZhciBzeW50aGV0aWNGcmFtZSA9IG5hbWUgPyBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lKSA6ICcnO1xuXG4gIHtcbiAgICBpZiAodHlwZW9mIGZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBjb21wb25lbnRGcmFtZUNhY2hlLnNldChmbiwgc3ludGhldGljRnJhbWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBzeW50aGV0aWNGcmFtZTtcbn1cbmZ1bmN0aW9uIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZShmbiwgc291cmNlLCBvd25lckZuKSB7XG4gIHtcbiAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZShmbiwgZmFsc2UpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHNob3VsZENvbnN0cnVjdChDb21wb25lbnQpIHtcbiAgdmFyIHByb3RvdHlwZSA9IENvbXBvbmVudC5wcm90b3R5cGU7XG4gIHJldHVybiAhIShwcm90b3R5cGUgJiYgcHJvdG90eXBlLmlzUmVhY3RDb21wb25lbnQpO1xufVxuXG5mdW5jdGlvbiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYodHlwZSwgc291cmNlLCBvd25lckZuKSB7XG5cbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHtcbiAgICAgIHJldHVybiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKHR5cGUsIHNob3VsZENvbnN0cnVjdCh0eXBlKSk7XG4gICAgfVxuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSh0eXBlKTtcbiAgfVxuXG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2UnKTtcblxuICAgIGNhc2UgUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFOlxuICAgICAgcmV0dXJuIGRlc2NyaWJlQnVpbHRJbkNvbXBvbmVudEZyYW1lKCdTdXNwZW5zZUxpc3QnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfRk9SV0FSRF9SRUZfVFlQRTpcbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlRnVuY3Rpb25Db21wb25lbnRGcmFtZSh0eXBlLnJlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICAvLyBNZW1vIG1heSBjb250YWluIGFueSBjb21wb25lbnQgdHlwZSBzbyB3ZSByZWN1cnNpdmVseSByZXNvbHZlIGl0LlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUudHlwZSwgc291cmNlLCBvd25lckZuKTtcblxuICAgICAgY2FzZSBSRUFDVF9CTE9DS19UWVBFOlxuICAgICAgICByZXR1cm4gZGVzY3JpYmVGdW5jdGlvbkNvbXBvbmVudEZyYW1lKHR5cGUuX3JlbmRlcik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSBFcnJvcigoY29tcG9uZW50TmFtZSB8fCAnUmVhY3QgY2xhc3MnKSArICc6ICcgKyBsb2NhdGlvbiArICcgdHlwZSBgJyArIHR5cGVTcGVjTmFtZSArICdgIGlzIGludmFsaWQ7ICcgKyAnaXQgbXVzdCBiZSBhIGZ1bmN0aW9uLCB1c3VhbGx5IGZyb20gdGhlIGBwcm9wLXR5cGVzYCBwYWNrYWdlLCBidXQgcmVjZWl2ZWQgYCcgKyB0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gKyAnYC4nICsgJ1RoaXMgb2Z0ZW4gaGFwcGVucyBiZWNhdXNlIG9mIHR5cG9zIHN1Y2ggYXMgYFByb3BUeXBlcy5mdW5jdGlvbmAgaW5zdGVhZCBvZiBgUHJvcFR5cGVzLmZ1bmNgLicpO1xuICAgICAgICAgICAgZXJyLm5hbWUgPSAnSW52YXJpYW50IFZpb2xhdGlvbic7XG4gICAgICAgICAgICB0aHJvdyBlcnI7XG4gICAgICAgICAgfVxuXG4gICAgICAgICAgZXJyb3IkMSA9IHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdKHZhbHVlcywgdHlwZVNwZWNOYW1lLCBjb21wb25lbnROYW1lLCBsb2NhdGlvbiwgbnVsbCwgJ1NFQ1JFVF9ET19OT1RfUEFTU19USElTX09SX1lPVV9XSUxMX0JFX0ZJUkVEJyk7XG4gICAgICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAgICAgZXJyb3IkMSA9IGV4O1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgJiYgIShlcnJvciQxIGluc3RhbmNlb2YgRXJyb3IpKSB7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvciAmJiAhKGVycm9yJDEubWVzc2FnZSBpbiBsb2dnZWRUeXBlRmFpbHVyZXMpKSB7XG4gICAgICAgICAgLy8gT25seSBtb25pdG9yIHRoaXMgZmFpbHVyZSBvbmNlIGJlY2F1c2UgdGhlcmUgdGVuZHMgdG8gYmUgYSBsb3Qgb2YgdGhlXG4gICAgICAgICAgLy8gc2FtZSBlcnJvci5cbiAgICAgICAgICBsb2dnZWRUeXBlRmFpbHVyZXNbZXJyb3IkMS5tZXNzYWdlXSA9IHRydWU7XG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignRmFpbGVkICVzIHR5cGU6ICVzJywgbG9jYXRpb24sIGVycm9yJDEubWVzc2FnZSk7XG5cbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgUmVhY3RDdXJyZW50T3duZXIgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBoYXNPd25Qcm9wZXJ0eSA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSk7XG5cbiAgICAgIGlmICghZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSkge1xuICAgICAgICBlcnJvcignQ29tcG9uZW50IFwiJXNcIiBjb250YWlucyB0aGUgc3RyaW5nIHJlZiBcIiVzXCIuICcgKyAnU3VwcG9ydCBmb3Igc3RyaW5nIHJlZnMgd2lsbCBiZSByZW1vdmVkIGluIGEgZnV0dXJlIG1ham9yIHJlbGVhc2UuICcgKyAnVGhpcyBjYXNlIGNhbm5vdCBiZSBhdXRvbWF0aWNhbGx5IGNvbnZlcnRlZCB0byBhbiBhcnJvdyBmdW5jdGlvbi4gJyArICdXZSBhc2sgeW91IHRvIG1hbnVhbGx5IGZpeCB0aGlzIGNhc2UgYnkgdXNpbmcgdXNlUmVmKCkgb3IgY3JlYXRlUmVmKCkgaW5zdGVhZC4gJyArICdMZWFybiBtb3JlIGFib3V0IHVzaW5nIHJlZnMgc2FmZWx5IGhlcmU6ICcgKyAnaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3N0cmljdC1tb2RlLXN0cmluZy1yZWYnLCBnZXRDb21wb25lbnROYW1lKFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQudHlwZSksIGNvbmZpZy5yZWYpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGBrZXlgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ0tleS5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAna2V5Jywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdLZXksXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpIHtcbiAge1xuICAgIHZhciB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBpZiAoIXNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duKSB7XG4gICAgICAgIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duID0gdHJ1ZTtcblxuICAgICAgICBlcnJvcignJXM6IGByZWZgIGlzIG5vdCBhIHByb3AuIFRyeWluZyB0byBhY2Nlc3MgaXQgd2lsbCByZXN1bHQgJyArICdpbiBgdW5kZWZpbmVkYCBiZWluZyByZXR1cm5lZC4gSWYgeW91IG5lZWQgdG8gYWNjZXNzIHRoZSBzYW1lICcgKyAndmFsdWUgd2l0aGluIHRoZSBjaGlsZCBjb21wb25lbnQsIHlvdSBzaG91bGQgcGFzcyBpdCBhcyBhIGRpZmZlcmVudCAnICsgJ3Byb3AuIChodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3BlY2lhbC1wcm9wcyknLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHdhcm5BYm91dEFjY2Vzc2luZ1JlZi5pc1JlYWN0V2FybmluZyA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHByb3BzLCAncmVmJywge1xuICAgICAgZ2V0OiB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYsXG4gICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxufVxuLyoqXG4gKiBGYWN0b3J5IG1ldGhvZCB0byBjcmVhdGUgYSBuZXcgUmVhY3QgZWxlbWVudC4gVGhpcyBubyBsb25nZXIgYWRoZXJlcyB0b1xuICogdGhlIGNsYXNzIHBhdHRlcm4sIHNvIGRvIG5vdCB1c2UgbmV3IHRvIGNhbGwgaXQuIEFsc28sIGluc3RhbmNlb2YgY2hlY2tcbiAqIHdpbGwgbm90IHdvcmsuIEluc3RlYWQgdGVzdCAkJHR5cGVvZiBmaWVsZCBhZ2FpbnN0IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKSB0byBjaGVja1xuICogaWYgc29tZXRoaW5nIGlzIGEgUmVhY3QgRWxlbWVudC5cbiAqXG4gKiBAcGFyYW0geyp9IHR5cGVcbiAqIEBwYXJhbSB7Kn0gcHJvcHNcbiAqIEBwYXJhbSB7Kn0ga2V5XG4gKiBAcGFyYW0ge3N0cmluZ3xvYmplY3R9IHJlZlxuICogQHBhcmFtIHsqfSBvd25lclxuICogQHBhcmFtIHsqfSBzZWxmIEEgKnRlbXBvcmFyeSogaGVscGVyIHRvIGRldGVjdCBwbGFjZXMgd2hlcmUgYHRoaXNgIGlzXG4gKiBkaWZmZXJlbnQgZnJvbSB0aGUgYG93bmVyYCB3aGVuIFJlYWN0LmNyZWF0ZUVsZW1lbnQgaXMgY2FsbGVkLCBzbyB0aGF0IHdlXG4gKiBjYW4gd2Fybi4gV2Ugd2FudCB0byBnZXQgcmlkIG9mIG93bmVyIGFuZCByZXBsYWNlIHN0cmluZyBgcmVmYHMgd2l0aCBhcnJvd1xuICogZnVuY3Rpb25zLCBhbmQgYXMgbG9uZyBhcyBgdGhpc2AgYW5kIG93bmVyIGFyZSB0aGUgc2FtZSwgdGhlcmUgd2lsbCBiZSBub1xuICogY2hhbmdlIGluIGJlaGF2aW9yLlxuICogQHBhcmFtIHsqfSBzb3VyY2UgQW4gYW5ub3RhdGlvbiBvYmplY3QgKGFkZGVkIGJ5IGEgdHJhbnNwaWxlciBvciBvdGhlcndpc2UpXG4gKiBpbmRpY2F0aW5nIGZpbGVuYW1lLCBsaW5lIG51bWJlciwgYW5kL29yIG90aGVyIGluZm9ybWF0aW9uLlxuICogQGludGVybmFsXG4gKi9cblxuXG52YXIgUmVhY3RFbGVtZW50ID0gZnVuY3Rpb24gKHR5cGUsIGtleSwgcmVmLCBzZWxmLCBzb3VyY2UsIG93bmVyLCBwcm9wcykge1xuICB2YXIgZWxlbWVudCA9IHtcbiAgICAvLyBUaGlzIHRhZyBhbGxvd3MgdXMgdG8gdW5pcXVlbHkgaWRlbnRpZnkgdGhpcyBhcyBhIFJlYWN0IEVsZW1lbnRcbiAgICAkJHR5cGVvZjogUkVBQ1RfRUxFTUVOVF9UWVBFLFxuICAgIC8vIEJ1aWx0LWluIHByb3BlcnRpZXMgdGhhdCBiZWxvbmcgb24gdGhlIGVsZW1lbnRcbiAgICB0eXBlOiB0eXBlLFxuICAgIGtleToga2V5LFxuICAgIHJlZjogcmVmLFxuICAgIHByb3BzOiBwcm9wcyxcbiAgICAvLyBSZWNvcmQgdGhlIGNvbXBvbmVudCByZXNwb25zaWJsZSBmb3IgY3JlYXRpbmcgdGhpcyBlbGVtZW50LlxuICAgIF9vd25lcjogb3duZXJcbiAgfTtcblxuICB7XG4gICAgLy8gVGhlIHZhbGlkYXRpb24gZmxhZyBpcyBjdXJyZW50bHkgbXV0YXRpdmUuIFdlIHB1dCBpdCBvblxuICAgIC8vIGFuIGV4dGVybmFsIGJhY2tpbmcgc3RvcmUgc28gdGhhdCB3ZSBjYW4gZnJlZXplIHRoZSB3aG9sZSBvYmplY3QuXG4gICAgLy8gVGhpcyBjYW4gYmUgcmVwbGFjZWQgd2l0aCBhIFdlYWtNYXAgb25jZSB0aGV5IGFyZSBpbXBsZW1lbnRlZCBpblxuICAgIC8vIGNvbW1vbmx5IHVzZWQgZGV2ZWxvcG1lbnQgZW52aXJvbm1lbnRzLlxuICAgIGVsZW1lbnQuX3N0b3JlID0ge307IC8vIFRvIG1ha2UgY29tcGFyaW5nIFJlYWN0RWxlbWVudHMgZWFzaWVyIGZvciB0ZXN0aW5nIHB1cnBvc2VzLCB3ZSBtYWtlXG4gICAgLy8gdGhlIHZhbGlkYXRpb24gZmxhZyBub24tZW51bWVyYWJsZSAod2hlcmUgcG9zc2libGUsIHdoaWNoIHNob3VsZFxuICAgIC8vIGluY2x1ZGUgZXZlcnkgZW52aXJvbm1lbnQgd2UgcnVuIHRlc3RzIGluKSwgc28gdGhlIHRlc3QgZnJhbWV3b3JrXG4gICAgLy8gaWdub3JlcyBpdC5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50Ll9zdG9yZSwgJ3ZhbGlkYXRlZCcsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlLFxuICAgICAgdmFsdWU6IGZhbHNlXG4gICAgfSk7IC8vIHNlbGYgYW5kIHNvdXJjZSBhcmUgREVWIG9ubHkgcHJvcGVydGllcy5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NlbGYnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogZmFsc2UsXG4gICAgICB2YWx1ZTogc2VsZlxuICAgIH0pOyAvLyBUd28gZWxlbWVudHMgY3JlYXRlZCBpbiB0d28gZGlmZmVyZW50IHBsYWNlcyBzaG91bGQgYmUgY29uc2lkZXJlZFxuICAgIC8vIGVxdWFsIGZvciB0ZXN0aW5nIHB1cnBvc2VzIGFuZCB0aGVyZWZvcmUgd2UgaGlkZSBpdCBmcm9tIGVudW1lcmF0aW9uLlxuXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KGVsZW1lbnQsICdfc291cmNlJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNvdXJjZVxuICAgIH0pO1xuXG4gICAgaWYgKE9iamVjdC5mcmVlemUpIHtcbiAgICAgIE9iamVjdC5mcmVlemUoZWxlbWVudC5wcm9wcyk7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBlbGVtZW50O1xufTtcbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYodHlwZSwgY29uZmlnLCBtYXliZUtleSwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgcHJvcE5hbWU7IC8vIFJlc2VydmVkIG5hbWVzIGFyZSBleHRyYWN0ZWRcblxuICAgIHZhciBwcm9wcyA9IHt9O1xuICAgIHZhciBrZXkgPSBudWxsO1xuICAgIHZhciByZWYgPSBudWxsOyAvLyBDdXJyZW50bHksIGtleSBjYW4gYmUgc3ByZWFkIGluIGFzIGEgcHJvcC4gVGhpcyBjYXVzZXMgYSBwb3RlbnRpYWxcbiAgICAvLyBpc3N1ZSBpZiBrZXkgaXMgYWxzbyBleHBsaWNpdGx5IGRlY2xhcmVkIChpZS4gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz5cbiAgICAvLyBvciA8ZGl2IGtleT1cIkhpXCIgey4uLnByb3BzfSAvPiApLiBXZSB3YW50IHRvIGRlcHJlY2F0ZSBrZXkgc3ByZWFkLFxuICAgIC8vIGJ1dCBhcyBhbiBpbnRlcm1lZGlhcnkgc3RlcCwgd2Ugd2lsbCB1c2UganN4REVWIGZvciBldmVyeXRoaW5nIGV4Y2VwdFxuICAgIC8vIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+LCBiZWNhdXNlIHdlIGFyZW4ndCBjdXJyZW50bHkgYWJsZSB0byB0ZWxsIGlmXG4gICAgLy8ga2V5IGlzIGV4cGxpY2l0bHkgZGVjbGFyZWQgdG8gYmUgdW5kZWZpbmVkIG9yIG5vdC5cblxuICAgIGlmIChtYXliZUtleSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBrZXkgPSAnJyArIG1heWJlS2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZEtleShjb25maWcpKSB7XG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAobmFtZSkge1xuICAgICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHRoZSByZW5kZXIgbWV0aG9kIG9mIGAnICsgbmFtZSArICdgLic7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSkge1xuICB7XG4gICAgaWYgKHNvdXJjZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB2YXIgZmlsZU5hbWUgPSBzb3VyY2UuZmlsZU5hbWUucmVwbGFjZSgvXi4qW1xcXFxcXC9dLywgJycpO1xuICAgICAgdmFyIGxpbmVOdW1iZXIgPSBzb3VyY2UubGluZU51bWJlcjtcbiAgICAgIHJldHVybiAnXFxuXFxuQ2hlY2sgeW91ciBjb2RlIGF0ICcgKyBmaWxlTmFtZSArICc6JyArIGxpbmVOdW1iZXIgKyAnLic7XG4gICAgfVxuXG4gICAgcmV0dXJuICcnO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlcmUncyBubyBrZXkgZXhwbGljaXRseSBzZXQgb24gZHluYW1pYyBhcnJheXMgb2YgY2hpbGRyZW4gb3JcbiAqIG9iamVjdCBrZXlzIGFyZSBub3QgdmFsaWQuIFRoaXMgYWxsb3dzIHVzIHRvIGtlZXAgdHJhY2sgb2YgY2hpbGRyZW4gYmV0d2VlblxuICogdXBkYXRlcy5cbiAqL1xuXG5cbnZhciBvd25lckhhc0tleVVzZVdhcm5pbmcgPSB7fTtcblxuZnVuY3Rpb24gZ2V0Q3VycmVudENvbXBvbmVudEVycm9ySW5mbyhwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICB2YXIgaW5mbyA9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuXG4gICAgaWYgKCFpbmZvKSB7XG4gICAgICB2YXIgcGFyZW50TmFtZSA9IHR5cGVvZiBwYXJlbnRUeXBlID09PSAnc3RyaW5nJyA/IHBhcmVudFR5cGUgOiBwYXJlbnRUeXBlLmRpc3BsYXlOYW1lIHx8IHBhcmVudFR5cGUubmFtZTtcblxuICAgICAgaWYgKHBhcmVudE5hbWUpIHtcbiAgICAgICAgaW5mbyA9IFwiXFxuXFxuQ2hlY2sgdGhlIHRvcC1sZXZlbCByZW5kZXIgY2FsbCB1c2luZyA8XCIgKyBwYXJlbnROYW1lICsgXCI+LlwiO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBpbmZvO1xuICB9XG59XG4vKipcbiAqIFdhcm4gaWYgdGhlIGVsZW1lbnQgZG9lc24ndCBoYXZlIGFuIGV4cGxpY2l0IGtleSBhc3NpZ25lZCB0byBpdC5cbiAqIFRoaXMgZWxlbWVudCBpcyBpbiBhbiBhcnJheS4gVGhlIGFycmF5IGNvdWxkIGdyb3cgYW5kIHNocmluayBvciBiZVxuICogcmVvcmRlcmVkLiBBbGwgY2hpbGRyZW4gdGhhdCBoYXZlbid0IGFscmVhZHkgYmVlbiB2YWxpZGF0ZWQgYXJlIHJlcXVpcmVkIHRvXG4gKiBoYXZlIGEgXCJrZXlcIiBwcm9wZXJ0eSBhc3NpZ25lZCB0byBpdC4gRXJyb3Igc3RhdHVzZXMgYXJlIGNhY2hlZCBzbyBhIHdhcm5pbmdcbiAqIHdpbGwgb25seSBiZSBzaG93biBvbmNlLlxuICpcbiAqIEBpbnRlcm5hbFxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnQgRWxlbWVudCB0aGF0IHJlcXVpcmVzIGEga2V5LlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIGVsZW1lbnQncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVFeHBsaWNpdEtleShlbGVtZW50LCBwYXJlbnRUeXBlKSB7XG4gIHtcbiAgICBpZiAoIWVsZW1lbnQuX3N0b3JlIHx8IGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCB8fCBlbGVtZW50LmtleSAhPSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgZWxlbWVudC5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICB2YXIgY3VycmVudENvbXBvbmVudEVycm9ySW5mbyA9IGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSk7XG5cbiAgICBpZiAob3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgb3duZXJIYXNLZXlVc2VXYXJuaW5nW2N1cnJlbnRDb21wb25lbnRFcnJvckluZm9dID0gdHJ1ZTsgLy8gVXN1YWxseSB0aGUgY3VycmVudCBvd25lciBpcyB0aGUgb2ZmZW5kZXIsIGJ1dCBpZiBpdCBhY2NlcHRzIGNoaWxkcmVuIGFzIGFcbiAgICAvLyBwcm9wZXJ0eSwgaXQgbWF5IGJlIHRoZSBjcmVhdG9yIG9mIHRoZSBjaGlsZCB0aGF0J3MgcmVzcG9uc2libGUgZm9yXG4gICAgLy8gYXNzaWduaW5nIGl0IGEga2V5LlxuXG4gICAgdmFyIGNoaWxkT3duZXIgPSAnJztcblxuICAgIGlmIChlbGVtZW50ICYmIGVsZW1lbnQuX293bmVyICYmIGVsZW1lbnQuX293bmVyICE9PSBSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIC8vIEdpdmUgdGhlIGNvbXBvbmVudCB0aGF0IG9yaWdpbmFsbHkgY3JlYXRlZCB0aGlzIGNoaWxkLlxuICAgICAgY2hpbGRPd25lciA9IFwiIEl0IHdhcyBwYXNzZWQgYSBjaGlsZCBmcm9tIFwiICsgZ2V0Q29tcG9uZW50TmFtZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChBcnJheS5pc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZSh0eXBlKTtcbiAgICAgIGNoZWNrUHJvcFR5cGVzKHByb3BUeXBlcywgZWxlbWVudC5wcm9wcywgJ3Byb3AnLCBuYW1lLCBlbGVtZW50KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUuUHJvcFR5cGVzICE9PSB1bmRlZmluZWQgJiYgIXByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duKSB7XG4gICAgICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IHRydWU7IC8vIEludGVudGlvbmFsbHkgaW5zaWRlIHRvIGF2b2lkIHRyaWdnZXJpbmcgbGF6eSBpbml0aWFsaXplcnM6XG5cbiAgICAgIHZhciBfbmFtZSA9IGdldENvbXBvbmVudE5hbWUodHlwZSk7XG5cbiAgICAgIGVycm9yKCdDb21wb25lbnQgJXMgZGVjbGFyZWQgYFByb3BUeXBlc2AgaW5zdGVhZCBvZiBgcHJvcFR5cGVzYC4gRGlkIHlvdSBtaXNzcGVsbCB0aGUgcHJvcGVydHkgYXNzaWdubWVudD8nLCBfbmFtZSB8fCAnVW5rbm93bicpO1xuICAgIH1cblxuICAgIGlmICh0eXBlb2YgdHlwZS5nZXREZWZhdWx0UHJvcHMgPT09ICdmdW5jdGlvbicgJiYgIXR5cGUuZ2V0RGVmYXVsdFByb3BzLmlzUmVhY3RDbGFzc0FwcHJvdmVkKSB7XG4gICAgICBlcnJvcignZ2V0RGVmYXVsdFByb3BzIGlzIG9ubHkgdXNlZCBvbiBjbGFzc2ljIFJlYWN0LmNyZWF0ZUNsYXNzICcgKyAnZGVmaW5pdGlvbnMuIFVzZSBhIHN0YXRpYyBwcm9wZXJ0eSBuYW1lZCBgZGVmYXVsdFByb3BzYCBpbnN0ZWFkLicpO1xuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhIGZyYWdtZW50LCB2YWxpZGF0ZSB0aGF0IGl0IGNhbiBvbmx5IGJlIHByb3ZpZGVkIHdpdGggZnJhZ21lbnQgcHJvcHNcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBmcmFnbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVGcmFnbWVudFByb3BzKGZyYWdtZW50KSB7XG4gIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKGZyYWdtZW50LnByb3BzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGtleSA9IGtleXNbaV07XG5cbiAgICAgIGlmIChrZXkgIT09ICdjaGlsZHJlbicgJiYga2V5ICE9PSAna2V5Jykge1xuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGZyYWdtZW50KTtcblxuICAgICAgICBlcnJvcignSW52YWxpZCBwcm9wIGAlc2Agc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4gJyArICdSZWFjdC5GcmFnbWVudCBjYW4gb25seSBoYXZlIGBrZXlgIGFuZCBgY2hpbGRyZW5gIHByb3BzLicsIGtleSk7XG5cbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgIGVycm9yKCdJbnZhbGlkIGF0dHJpYnV0ZSBgcmVmYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLicpO1xuXG4gICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBqc3hXaXRoVmFsaWRhdGlvbih0eXBlLCBwcm9wcywga2V5LCBpc1N0YXRpY0NoaWxkcmVuLCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciB2YWxpZFR5cGUgPSBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSk7IC8vIFdlIHdhcm4gaW4gdGhpcyBjYXNlIGJ1dCBkb24ndCB0aHJvdy4gV2UgZXhwZWN0IHRoZSBlbGVtZW50IGNyZWF0aW9uIHRvXG4gICAgLy8gc3VjY2VlZCBhbmQgdGhlcmUgd2lsbCBsaWtlbHkgYmUgZXJyb3JzIGluIHJlbmRlci5cblxuICAgIGlmICghdmFsaWRUeXBlKSB7XG4gICAgICB2YXIgaW5mbyA9ICcnO1xuXG4gICAgICBpZiAodHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnb2JqZWN0JyAmJiB0eXBlICE9PSBudWxsICYmIE9iamVjdC5rZXlzKHR5cGUpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICBpbmZvICs9ICcgWW91IGxpa2VseSBmb3Jnb3QgdG8gZXhwb3J0IHlvdXIgY29tcG9uZW50IGZyb20gdGhlIGZpbGUgJyArIFwiaXQncyBkZWZpbmVkIGluLCBvciB5b3UgbWlnaHQgaGF2ZSBtaXhlZCB1cCBkZWZhdWx0IGFuZCBuYW1lZCBpbXBvcnRzLlwiO1xuICAgICAgfVxuXG4gICAgICB2YXIgc291cmNlSW5mbyA9IGdldFNvdXJjZUluZm9FcnJvckFkZGVuZHVtKHNvdXJjZSk7XG5cbiAgICAgIGlmIChzb3VyY2VJbmZvKSB7XG4gICAgICAgIGluZm8gKz0gc291cmNlSW5mbztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGluZm8gKz0gZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtKCk7XG4gICAgICB9XG5cbiAgICAgIHZhciB0eXBlU3RyaW5nO1xuXG4gICAgICBpZiAodHlwZSA9PT0gbnVsbCkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ251bGwnO1xuICAgICAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHR5cGUpKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnYXJyYXknO1xuICAgICAgfSBlbHNlIGlmICh0eXBlICE9PSB1bmRlZmluZWQgJiYgdHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSBcIjxcIiArIChnZXRDb21wb25lbnROYW1lKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBleHBvcnRzLkZyYWdtZW50KSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWJDEgPSAganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLmpzeERFViA9IGpzeERFViQxO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/react/cjs/react-jsx-dev-runtime.development.js\n");

/***/ }),

/***/ "./node_modules/react/jsx-dev-runtime.js":
/*!***********************************************!*\
  !*** ./node_modules/react/jsx-dev-runtime.js ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"./node_modules/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzLmpzIiwibWFwcGluZ3MiOiJBQUFhOztBQUViLElBQUksS0FBcUMsRUFBRSxFQUUxQyxDQUFDO0FBQ0YsRUFBRSx1SkFBc0U7QUFDeEUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz81Nzc3Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/react/jsx-dev-runtime.js\n");

/***/ }),

/***/ "./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty.js":
/*!**************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty.js ***!
  \**************************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ _defineProperty; }\n/* harmony export */ });\nfunction _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2RlZmluZVByb3BlcnR5LmpzLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTs7QUFFQTtBQUNBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZGVmaW5lUHJvcGVydHkuanM/MjUzMCJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZGVmYXVsdCBmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn0iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/compiled/@babel/runtime/helpers/esm/defineProperty.js\n");

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?page=%2F_app&absolutePagePath=private-next-pages%2F_app!"), __webpack_exec__("./node_modules/next/dist/client/router.js"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);